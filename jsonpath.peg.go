package jsonpath

// Code generated by peg -inline -switch jsonpath.peg DO NOT EDIT.

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpathQuery
	rulerootlessQuery
	rulejsonpathParameter
	rulerootIdentifier
	rulerootlessNode
	ruleparameterRootNode
	rulecurrentNodeIdentifier
	rulesegments
	rulesegment
	ruledescendantSegment
	rulechildSegment
	rulebracketedSelection
	rulefunction
	rulefunctionName
	rulememberNameShorthand
	rulesignsWithoutHyphenUnderscore
	ruleselectors
	ruleobjectElementSelectors
	ruleobjectElementSelector
	rulewildcardSelector
	rulesingleQuotedNameSelector
	ruledoubleQuotedNameSelector
	rulehexDigits
	rulehexDigit
	rulearrayElementSelectors
	rulearrayElementSelector
	rulearraySliceSelector
	ruleanyIndex
	ruleindexSelector
	ruleindexNumber
	rulesep
	rulesepArraySlice
	rulescriptSelector
	rulecommand
	rulefilterSelector
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptSelectorStart
	rulescriptSelectorEnd
	rulefilterSelectorStart
	rulefilterSelectorEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpathQuery",
	"rootlessQuery",
	"jsonpathParameter",
	"rootIdentifier",
	"rootlessNode",
	"parameterRootNode",
	"currentNodeIdentifier",
	"segments",
	"segment",
	"descendantSegment",
	"childSegment",
	"bracketedSelection",
	"function",
	"functionName",
	"memberNameShorthand",
	"signsWithoutHyphenUnderscore",
	"selectors",
	"objectElementSelectors",
	"objectElementSelector",
	"wildcardSelector",
	"singleQuotedNameSelector",
	"doubleQuotedNameSelector",
	"hexDigits",
	"hexDigit",
	"arrayElementSelectors",
	"arrayElementSelector",
	"arraySliceSelector",
	"anyIndex",
	"indexSelector",
	"indexNumber",
	"sep",
	"sepArraySlice",
	"scriptSelector",
	"command",
	"filterSelector",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptSelectorStart",
	"scriptSelectorEnd",
	"filterSelectorStart",
	"filterSelectorEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer         string
	buffer         []rune
	rules          [112]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
			p.setConnectedText(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.pushRootNodeIdentifier()

		case ruleAction3:

			p.pushRootNodeIdentifier()

		case ruleAction4:

			p.pushCurrentNodeIdentifier()

		case ruleAction5:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction6:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.setLastNodeText(text)

		case ruleAction9:

			p.pushFunction(text, p.pop().(string))

		case ruleAction10:

			p.push(text)

		case ruleAction11:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction12:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction13:

			p.pushChildWildcardIdentifier()

		case ruleAction14:

			p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))

		case ruleAction15:

			p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))

		case ruleAction16:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction17:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted {
				step.number = 1
			}

			if step.number >= 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction18:

			p.pushIndexSubscript(text)

		case ruleAction19:

			p.pushWildcardSubscript()

		case ruleAction20:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction21:

			p.pushIndexSubscript(`1`)

		case ruleAction22:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction23:

			p.pushScriptQualifier(text)

		case ruleAction24:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction25:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction26:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction27:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
				_, leftIsCurrentNode := checkQuery.leftParam.param.(*syntaxQueryParamCurrentNode)
				_, rightIsCurrentNode := checkQuery.rightParam.param.(*syntaxQueryParamCurrentNode)
				if leftIsCurrentNode && rightIsCurrentNode {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction28:

			_ = p.pop()
			jsonpathFilter := p.pop().(syntaxQuery)

			if text[0:1] == `!` {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction29:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction34:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction35:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction36:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction37:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction38:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction39:

			p.saveParams()

		case ruleAction40:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootNodeIdentifier:
				p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
				p.push(true)
			case *syntaxCurrentNodeIdentifier:
				p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
				p.push(false)
			}

		case ruleAction41:

			p.push(p.toFloat(text))

		case ruleAction42:

			p.push(true)

		case ruleAction43:

			p.push(false)

		case ruleAction44:

			p.push(p.unescape(text))

		case ruleAction45:

			p.push(p.unescape(text))

		case ruleAction46:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func DisableMemoize() func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.disableMemoize = true
		return nil
	}
}

type memo struct {
	Matched bool
	Partial []token32
}

type memoKey struct {
	Rule     uint32
	Position uint32
}

func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
		memoization          map[memoKey]memo
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey]memo)
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	memoize := func(rule uint32, begin uint32, tokenIndexStart uint32, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey{rule, begin}
		if !matched {
			memoization[key] = memo{Matched: false}
		} else {
			t := tree.tree[tokenIndexStart:tokenIndex]
			tokenCopy := make([]token32, len(t))
			copy(tokenCopy, t)
			memoization[key] = memo{Matched: true, Partial: tokenCopy}
		}
	}

	memoizedResult := func(m memo) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += uint32(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > max.end {
			max = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <(((jsonpathQuery / rootlessQuery) END Action0) / ((jsonpathQuery / rootlessQuery)? <.*> END Action1))> */
		func() bool {
			if memoized, ok := memoization[memoKey{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpathQuery]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[rulerootlessQuery]() {
							goto l3
						}
					}
				l4:
					if !_rules[ruleEND]() {
						goto l3
					}
					{
						add(ruleAction0, position)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position7, tokenIndex7 := position, tokenIndex
						{
							position9, tokenIndex9 := position, tokenIndex
							if !_rules[rulejsonpathQuery]() {
								goto l10
							}
							goto l9
						l10:
							position, tokenIndex = position9, tokenIndex9
							if !_rules[rulerootlessQuery]() {
								goto l7
							}
						}
					l9:
						goto l8
					l7:
						position, tokenIndex = position7, tokenIndex7
					}
				l8:
					{
						position11 := position
					l12:
						{
							position13, tokenIndex13 := position, tokenIndex
							if !matchDot() {
								goto l13
							}
							goto l12
						l13:
							position, tokenIndex = position13, tokenIndex13
						}
						add(rulePegText, position11)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					{
						add(ruleAction1, position)
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			if memoized, ok := memoization[memoKey{1, position}]; ok {
				return memoizedResult(memoized)
			}
			position15, tokenIndex15 := position, tokenIndex
			{
				position16 := position
				{
					position17, tokenIndex17 := position, tokenIndex
					if !matchDot() {
						goto l17
					}
					goto l15
				l17:
					position, tokenIndex = position17, tokenIndex17
				}
				add(ruleEND, position16)
			}
			memoize(1, position15, tokenIndex15, true)
			return true
		l15:
			memoize(1, position15, tokenIndex15, false)
			position, tokenIndex = position15, tokenIndex15
			return false
		},
		/* 2 jsonpathQuery <- <(space rootIdentifier segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				if !_rules[rulespace]() {
					goto l18
				}
				if !_rules[rulerootIdentifier]() {
					goto l18
				}
				if !_rules[rulesegments]() {
					goto l18
				}
				add(rulejsonpathQuery, position19)
			}
			memoize(2, position18, tokenIndex18, true)
			return true
		l18:
			memoize(2, position18, tokenIndex18, false)
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 3 rootlessQuery <- <(space rootlessNode segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey{3, position}]; ok {
				return memoizedResult(memoized)
			}
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				if !_rules[rulespace]() {
					goto l20
				}
				{
					position22 := position
					{
						add(ruleAction3, position)
					}
					{
						position24, tokenIndex24 := position, tokenIndex
						if !_rules[rulebracketedSelection]() {
							goto l25
						}
						goto l24
					l25:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[rulememberNameShorthand]() {
							goto l26
						}
						goto l24
					l26:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[ruledescendantSegment]() {
							goto l27
						}
						goto l24
					l27:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[rulechildSegment]() {
							goto l20
						}
					}
				l24:
					add(rulerootlessNode, position22)
				}
				if !_rules[rulesegments]() {
					goto l20
				}
				add(rulerootlessQuery, position21)
			}
			memoize(3, position20, tokenIndex20, true)
			return true
		l20:
			memoize(3, position20, tokenIndex20, false)
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 4 jsonpathParameter <- <(space parameterRootNode segments)> */
		nil,
		/* 5 rootIdentifier <- <('$' Action2)> */
		func() bool {
			if memoized, ok := memoization[memoKey{5, position}]; ok {
				return memoizedResult(memoized)
			}
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				if buffer[position] != rune('$') {
					goto l29
				}
				position++
				{
					add(ruleAction2, position)
				}
				add(rulerootIdentifier, position30)
			}
			memoize(5, position29, tokenIndex29, true)
			return true
		l29:
			memoize(5, position29, tokenIndex29, false)
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 6 rootlessNode <- <(Action3 (bracketedSelection / memberNameShorthand / descendantSegment / childSegment))> */
		nil,
		/* 7 parameterRootNode <- <(rootIdentifier / currentNodeIdentifier)> */
		nil,
		/* 8 currentNodeIdentifier <- <('@' Action4)> */
		nil,
		/* 9 segments <- <(segment* function* space Action5)> */
		func() bool {
			if memoized, ok := memoization[memoKey{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
			l37:
				{
					position38, tokenIndex38 := position, tokenIndex
					{
						position39 := position
						{
							position40, tokenIndex40 := position, tokenIndex
							if !_rules[ruledescendantSegment]() {
								goto l41
							}
							goto l40
						l41:
							position, tokenIndex = position40, tokenIndex40
							if !_rules[rulechildSegment]() {
								goto l38
							}
						}
					l40:
						add(rulesegment, position39)
					}
					goto l37
				l38:
					position, tokenIndex = position38, tokenIndex38
				}
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44 := position
						{
							position45 := position
							if buffer[position] != rune('.') {
								goto l43
							}
							position++
							{
								position46 := position
								{
									position47 := position
									{
										switch buffer[position] {
										case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
											position++
										case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
											position++
										case '_':
											position++
										case '-':
											position++
										default:
											if c := buffer[position]; c < rune('a') || c > rune('z') {
												goto l43
											}
											position++
										}
									}

								l48:
									{
										position49, tokenIndex49 := position, tokenIndex
										{
											switch buffer[position] {
											case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
												position++
											case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
												position++
											case '_':
												position++
											case '-':
												position++
											default:
												if c := buffer[position]; c < rune('a') || c > rune('z') {
													goto l49
												}
												position++
											}
										}

										goto l48
									l49:
										position, tokenIndex = position49, tokenIndex49
									}
									add(rulePegText, position47)
								}
								{
									add(ruleAction10, position)
								}
								add(rulefunctionName, position46)
							}
							if buffer[position] != rune('(') {
								goto l43
							}
							position++
							if buffer[position] != rune(')') {
								goto l43
							}
							position++
							add(rulePegText, position45)
						}
						{
							add(ruleAction9, position)
						}
						add(rulefunction, position44)
					}
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				if !_rules[rulespace]() {
					goto l35
				}
				{
					add(ruleAction5, position)
				}
				add(rulesegments, position36)
			}
			memoize(9, position35, tokenIndex35, true)
			return true
		l35:
			memoize(9, position35, tokenIndex35, false)
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 10 segment <- <(descendantSegment / childSegment)> */
		nil,
		/* 11 descendantSegment <- <('.' '.' (bracketedSelection / memberNameShorthand) Action6)> */
		func() bool {
			if memoized, ok := memoization[memoKey{11, position}]; ok {
				return memoizedResult(memoized)
			}
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if buffer[position] != rune('.') {
					goto l56
				}
				position++
				if buffer[position] != rune('.') {
					goto l56
				}
				position++
				{
					position58, tokenIndex58 := position, tokenIndex
					if !_rules[rulebracketedSelection]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position58, tokenIndex58
					if !_rules[rulememberNameShorthand]() {
						goto l56
					}
				}
			l58:
				{
					add(ruleAction6, position)
				}
				add(ruledescendantSegment, position57)
			}
			memoize(11, position56, tokenIndex56, true)
			return true
		l56:
			memoize(11, position56, tokenIndex56, false)
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 12 childSegment <- <((<('.' memberNameShorthand)> Action7) / bracketedSelection)> */
		func() bool {
			if memoized, ok := memoization[memoKey{12, position}]; ok {
				return memoizedResult(memoized)
			}
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				{
					position63, tokenIndex63 := position, tokenIndex
					{
						position65 := position
						if buffer[position] != rune('.') {
							goto l64
						}
						position++
						if !_rules[rulememberNameShorthand]() {
							goto l64
						}
						add(rulePegText, position65)
					}
					{
						add(ruleAction7, position)
					}
					goto l63
				l64:
					position, tokenIndex = position63, tokenIndex63
					if !_rules[rulebracketedSelection]() {
						goto l61
					}
				}
			l63:
				add(rulechildSegment, position62)
			}
			memoize(12, position61, tokenIndex61, true)
			return true
		l61:
			memoize(12, position61, tokenIndex61, false)
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 13 bracketedSelection <- <(<(squareBracketStart selectors squareBracketEnd)> Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				{
					position69 := position
					{
						position70 := position
						if buffer[position] != rune('[') {
							goto l67
						}
						position++
						if !_rules[rulespace]() {
							goto l67
						}
						add(rulesquareBracketStart, position70)
					}
					{
						position71 := position
						{
							position72, tokenIndex72 := position, tokenIndex
							{
								position74 := position
								if !_rules[ruleobjectElementSelector]() {
									goto l73
								}
							l75:
								{
									position76, tokenIndex76 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l76
									}
									if !_rules[ruleobjectElementSelector]() {
										goto l76
									}
									{
										add(ruleAction12, position)
									}
									goto l75
								l76:
									position, tokenIndex = position76, tokenIndex76
								}
								{
									position78, tokenIndex78 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l78
									}
									goto l73
								l78:
									position, tokenIndex = position78, tokenIndex78
								}
								add(ruleobjectElementSelectors, position74)
							}
							goto l72
						l73:
							position, tokenIndex = position72, tokenIndex72
							{
								switch buffer[position] {
								case '(':
									{
										position80 := position
										{
											position81 := position
											position++
											if !_rules[rulespace]() {
												goto l67
											}
											add(rulescriptSelectorStart, position81)
										}
										{
											position82 := position
											{
												position83 := position
												{
													position86, tokenIndex86 := position, tokenIndex
													if !_rules[rulescriptSelectorEnd]() {
														goto l86
													}
													goto l67
												l86:
													position, tokenIndex = position86, tokenIndex86
												}
												if !matchDot() {
													goto l67
												}
											l84:
												{
													position85, tokenIndex85 := position, tokenIndex
													{
														position87, tokenIndex87 := position, tokenIndex
														if !_rules[rulescriptSelectorEnd]() {
															goto l87
														}
														goto l85
													l87:
														position, tokenIndex = position87, tokenIndex87
													}
													if !matchDot() {
														goto l85
													}
													goto l84
												l85:
													position, tokenIndex = position85, tokenIndex85
												}
												add(rulecommand, position83)
											}
											add(rulePegText, position82)
										}
										if !_rules[rulescriptSelectorEnd]() {
											goto l67
										}
										{
											add(ruleAction23, position)
										}
										add(rulescriptSelector, position80)
									}
								case '?':
									{
										position89 := position
										{
											position90 := position
											position++
											if buffer[position] != rune('(') {
												goto l67
											}
											position++
											if !_rules[rulespace]() {
												goto l67
											}
											add(rulefilterSelectorStart, position90)
										}
										if !_rules[rulequery]() {
											goto l67
										}
										{
											position91 := position
											if !_rules[rulespace]() {
												goto l67
											}
											if buffer[position] != rune(')') {
												goto l67
											}
											position++
											add(rulefilterSelectorEnd, position91)
										}
										{
											add(ruleAction24, position)
										}
										add(rulefilterSelector, position89)
									}
								default:
									{
										position93 := position
										if !_rules[rulearrayElementSelector]() {
											goto l67
										}
									l94:
										{
											position95, tokenIndex95 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l95
											}
											if !_rules[rulearrayElementSelector]() {
												goto l95
											}
											{
												add(ruleAction16, position)
											}
											goto l94
										l95:
											position, tokenIndex = position95, tokenIndex95
										}
										{
											position97, tokenIndex97 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l97
											}
											goto l67
										l97:
											position, tokenIndex = position97, tokenIndex97
										}
										add(rulearrayElementSelectors, position93)
									}
								}
							}

						}
					l72:
						add(ruleselectors, position71)
					}
					{
						position98 := position
						if !_rules[rulespace]() {
							goto l67
						}
						if buffer[position] != rune(']') {
							goto l67
						}
						position++
						add(rulesquareBracketEnd, position98)
					}
					add(rulePegText, position69)
				}
				{
					add(ruleAction8, position)
				}
				add(rulebracketedSelection, position68)
			}
			memoize(13, position67, tokenIndex67, true)
			return true
		l67:
			memoize(13, position67, tokenIndex67, false)
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 14 function <- <(<('.' functionName ('(' ')'))> Action9)> */
		nil,
		/* 15 functionName <- <(<((&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> Action10)> */
		nil,
		/* 16 memberNameShorthand <- <(wildcardSelector / (<(('\\' signsWithoutHyphenUnderscore) / (!([\x00-\x1f] / '\x7f') !signsWithoutHyphenUnderscore .))+> !('(' ')') Action11))> */
		func() bool {
			if memoized, ok := memoization[memoKey{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					{
						position106 := position
						{
							position109, tokenIndex109 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l110
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l110
							}
							goto l109
						l110:
							position, tokenIndex = position109, tokenIndex109
							{
								position111, tokenIndex111 := position, tokenIndex
								{
									position112, tokenIndex112 := position, tokenIndex
									if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
										goto l113
									}
									position++
									goto l112
								l113:
									position, tokenIndex = position112, tokenIndex112
									if buffer[position] != rune('\x7f') {
										goto l111
									}
									position++
								}
							l112:
								goto l102
							l111:
								position, tokenIndex = position111, tokenIndex111
							}
							{
								position114, tokenIndex114 := position, tokenIndex
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l114
								}
								goto l102
							l114:
								position, tokenIndex = position114, tokenIndex114
							}
							if !matchDot() {
								goto l102
							}
						}
					l109:
					l107:
						{
							position108, tokenIndex108 := position, tokenIndex
							{
								position115, tokenIndex115 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l116
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l116
								}
								goto l115
							l116:
								position, tokenIndex = position115, tokenIndex115
								{
									position117, tokenIndex117 := position, tokenIndex
									{
										position118, tokenIndex118 := position, tokenIndex
										if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
											goto l119
										}
										position++
										goto l118
									l119:
										position, tokenIndex = position118, tokenIndex118
										if buffer[position] != rune('\x7f') {
											goto l117
										}
										position++
									}
								l118:
									goto l108
								l117:
									position, tokenIndex = position117, tokenIndex117
								}
								{
									position120, tokenIndex120 := position, tokenIndex
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l120
									}
									goto l108
								l120:
									position, tokenIndex = position120, tokenIndex120
								}
								if !matchDot() {
									goto l108
								}
							}
						l115:
							goto l107
						l108:
							position, tokenIndex = position108, tokenIndex108
						}
						add(rulePegText, position106)
					}
					{
						position121, tokenIndex121 := position, tokenIndex
						if buffer[position] != rune('(') {
							goto l121
						}
						position++
						if buffer[position] != rune(')') {
							goto l121
						}
						position++
						goto l102
					l121:
						position, tokenIndex = position121, tokenIndex121
					}
					{
						add(ruleAction11, position)
					}
				}
			l104:
				add(rulememberNameShorthand, position103)
			}
			memoize(16, position102, tokenIndex102, true)
			return true
		l102:
			memoize(16, position102, tokenIndex102, false)
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 17 signsWithoutHyphenUnderscore <- <((&('{' | '|' | '}' | '~') [{-~]) | (&('`') '`') | (&('[' | '\\' | ']' | '^') [[-^]) | (&(':' | ';' | '<' | '=' | '>' | '?' | '@') [:-@]) | (&('/') '/') | (&('.') '.') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',') [ -,]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				{
					switch buffer[position] {
					case '{', '|', '}', '~':
						position++
					case '`':
						position++
					case '[', '\\', ']', '^':
						position++
					case ':', ';', '<', '=', '>', '?', '@':
						position++
					case '/':
						position++
					case '.':
						position++
					default:
						if c := buffer[position]; c < rune(' ') || c > rune(',') {
							goto l123
						}
						position++
					}
				}

				add(rulesignsWithoutHyphenUnderscore, position124)
			}
			memoize(17, position123, tokenIndex123, true)
			return true
		l123:
			memoize(17, position123, tokenIndex123, false)
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 18 selectors <- <(objectElementSelectors / ((&('(') scriptSelector) | (&('?') filterSelector) | (&(' ' | '*' | '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':') arrayElementSelectors)))> */
		nil,
		/* 19 objectElementSelectors <- <(objectElementSelector (sep objectElementSelector Action12)* !sep)> */
		nil,
		/* 20 objectElementSelector <- <((&('"') doubleQuotedNameSelector) | (&('\'') singleQuotedNameSelector) | (&('*') wildcardSelector))> */
		func() bool {
			if memoized, ok := memoization[memoKey{20, position}]; ok {
				return memoizedResult(memoized)
			}
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				{
					switch buffer[position] {
					case '"':
						{
							position131 := position
							position++
							{
								position132 := position
							l133:
								{
									position134, tokenIndex134 := position, tokenIndex
									{
										position135, tokenIndex135 := position, tokenIndex
										if buffer[position] != rune('\\') {
											goto l136
										}
										position++
										{
											switch buffer[position] {
											case 'u':
												if !_rules[rulehexDigits]() {
													goto l136
												}
											case 't':
												position++
											case 'r':
												position++
											case 'n':
												position++
											case 'f':
												position++
											case 'b':
												position++
											case '\\':
												position++
											case '/':
												position++
											default:
												if buffer[position] != rune('"') {
													goto l136
												}
												position++
											}
										}

										goto l135
									l136:
										position, tokenIndex = position135, tokenIndex135
										{
											position138, tokenIndex138 := position, tokenIndex
											{
												position139, tokenIndex139 := position, tokenIndex
												if buffer[position] != rune('"') {
													goto l140
												}
												position++
												goto l139
											l140:
												position, tokenIndex = position139, tokenIndex139
												if buffer[position] != rune('\\') {
													goto l138
												}
												position++
											}
										l139:
											goto l134
										l138:
											position, tokenIndex = position138, tokenIndex138
										}
										if !matchDot() {
											goto l134
										}
									}
								l135:
									goto l133
								l134:
									position, tokenIndex = position134, tokenIndex134
								}
								add(rulePegText, position132)
							}
							if buffer[position] != rune('"') {
								goto l128
							}
							position++
							{
								add(ruleAction15, position)
							}
							add(ruledoubleQuotedNameSelector, position131)
						}
					case '\'':
						{
							position142 := position
							position++
							{
								position143 := position
							l144:
								{
									position145, tokenIndex145 := position, tokenIndex
									{
										position146, tokenIndex146 := position, tokenIndex
										if buffer[position] != rune('\\') {
											goto l147
										}
										position++
										{
											switch buffer[position] {
											case 'u':
												if !_rules[rulehexDigits]() {
													goto l147
												}
											case 't':
												position++
											case 'r':
												position++
											case 'n':
												position++
											case 'f':
												position++
											case 'b':
												position++
											case '\\':
												position++
											case '/':
												position++
											default:
												if buffer[position] != rune('\'') {
													goto l147
												}
												position++
											}
										}

										goto l146
									l147:
										position, tokenIndex = position146, tokenIndex146
										{
											position149, tokenIndex149 := position, tokenIndex
											{
												position150, tokenIndex150 := position, tokenIndex
												if buffer[position] != rune('\'') {
													goto l151
												}
												position++
												goto l150
											l151:
												position, tokenIndex = position150, tokenIndex150
												if buffer[position] != rune('\\') {
													goto l149
												}
												position++
											}
										l150:
											goto l145
										l149:
											position, tokenIndex = position149, tokenIndex149
										}
										if !matchDot() {
											goto l145
										}
									}
								l146:
									goto l144
								l145:
									position, tokenIndex = position145, tokenIndex145
								}
								add(rulePegText, position143)
							}
							if buffer[position] != rune('\'') {
								goto l128
							}
							position++
							{
								add(ruleAction14, position)
							}
							add(rulesingleQuotedNameSelector, position142)
						}
					default:
						if !_rules[rulewildcardSelector]() {
							goto l128
						}
					}
				}

				add(ruleobjectElementSelector, position129)
			}
			memoize(20, position128, tokenIndex128, true)
			return true
		l128:
			memoize(20, position128, tokenIndex128, false)
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 21 wildcardSelector <- <('*' Action13)> */
		func() bool {
			if memoized, ok := memoization[memoKey{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				if buffer[position] != rune('*') {
					goto l153
				}
				position++
				{
					add(ruleAction13, position)
				}
				add(rulewildcardSelector, position154)
			}
			memoize(21, position153, tokenIndex153, true)
			return true
		l153:
			memoize(21, position153, tokenIndex153, false)
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 22 singleQuotedNameSelector <- <('\'' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('\'') '\''))) / (!('\'' / '\\') .))*> '\'' Action14)> */
		nil,
		/* 23 doubleQuotedNameSelector <- <('"' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('"') '"'))) / (!('"' / '\\') .))*> '"' Action15)> */
		nil,
		/* 24 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			if memoized, ok := memoization[memoKey{24, position}]; ok {
				return memoizedResult(memoized)
			}
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				if buffer[position] != rune('u') {
					goto l158
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l158
				}
				if !_rules[rulehexDigit]() {
					goto l158
				}
				if !_rules[rulehexDigit]() {
					goto l158
				}
				if !_rules[rulehexDigit]() {
					goto l158
				}
				add(rulehexDigits, position159)
			}
			memoize(24, position158, tokenIndex158, true)
			return true
		l158:
			memoize(24, position158, tokenIndex158, false)
			position, tokenIndex = position158, tokenIndex158
			return false
		},
		/* 25 hexDigit <- <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{25, position}]; ok {
				return memoizedResult(memoized)
			}
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				{
					switch buffer[position] {
					case 'A', 'B', 'C', 'D', 'E', 'F':
						position++
					case 'a', 'b', 'c', 'd', 'e', 'f':
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l160
						}
						position++
					}
				}

				add(rulehexDigit, position161)
			}
			memoize(25, position160, tokenIndex160, true)
			return true
		l160:
			memoize(25, position160, tokenIndex160, false)
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 26 arrayElementSelectors <- <(arrayElementSelector (sep arrayElementSelector Action16)* !sep)> */
		nil,
		/* 27 arrayElementSelector <- <(((arraySliceSelector Action17) / (<indexSelector> Action18) / ('*' Action19)) Action20)> */
		func() bool {
			if memoized, ok := memoization[memoKey{27, position}]; ok {
				return memoizedResult(memoized)
			}
			position164, tokenIndex164 := position, tokenIndex
			{
				position165 := position
				{
					position166, tokenIndex166 := position, tokenIndex
					{
						position168 := position
						if !_rules[ruleanyIndex]() {
							goto l167
						}
						if !_rules[rulesepArraySlice]() {
							goto l167
						}
						if !_rules[ruleanyIndex]() {
							goto l167
						}
						{
							position169, tokenIndex169 := position, tokenIndex
							if !_rules[rulesepArraySlice]() {
								goto l170
							}
							if !_rules[ruleanyIndex]() {
								goto l170
							}
							goto l169
						l170:
							position, tokenIndex = position169, tokenIndex169
							if !_rules[rulespace]() {
								goto l167
							}
							{
								add(ruleAction21, position)
							}
						}
					l169:
						add(rulearraySliceSelector, position168)
					}
					{
						add(ruleAction17, position)
					}
					goto l166
				l167:
					position, tokenIndex = position166, tokenIndex166
					{
						position174 := position
						{
							position175 := position
							if !_rules[ruleindexNumber]() {
								goto l173
							}
							add(ruleindexSelector, position175)
						}
						add(rulePegText, position174)
					}
					{
						add(ruleAction18, position)
					}
					goto l166
				l173:
					position, tokenIndex = position166, tokenIndex166
					if buffer[position] != rune('*') {
						goto l164
					}
					position++
					{
						add(ruleAction19, position)
					}
				}
			l166:
				{
					add(ruleAction20, position)
				}
				add(rulearrayElementSelector, position165)
			}
			memoize(27, position164, tokenIndex164, true)
			return true
		l164:
			memoize(27, position164, tokenIndex164, false)
			position, tokenIndex = position164, tokenIndex164
			return false
		},
		/* 28 arraySliceSelector <- <(anyIndex sepArraySlice anyIndex ((sepArraySlice anyIndex) / (space Action21)))> */
		nil,
		/* 29 anyIndex <- <(<indexNumber?> Action22)> */
		func() bool {
			if memoized, ok := memoization[memoKey{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				{
					position182 := position
					{
						position183, tokenIndex183 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l183
						}
						goto l184
					l183:
						position, tokenIndex = position183, tokenIndex183
					}
				l184:
					add(rulePegText, position182)
				}
				{
					add(ruleAction22, position)
				}
				add(ruleanyIndex, position181)
			}
			memoize(29, position180, tokenIndex180, true)
			return true
		},
		/* 30 indexSelector <- <indexNumber> */
		nil,
		/* 31 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			if memoized, ok := memoization[memoKey{31, position}]; ok {
				return memoizedResult(memoized)
			}
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				{
					position189, tokenIndex189 := position, tokenIndex
					{
						position191, tokenIndex191 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l192
						}
						position++
						goto l191
					l192:
						position, tokenIndex = position191, tokenIndex191
						if buffer[position] != rune('+') {
							goto l189
						}
						position++
					}
				l191:
					goto l190
				l189:
					position, tokenIndex = position189, tokenIndex189
				}
			l190:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l187
				}
				position++
			l193:
				{
					position194, tokenIndex194 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l194
					}
					position++
					goto l193
				l194:
					position, tokenIndex = position194, tokenIndex194
				}
				add(ruleindexNumber, position188)
			}
			memoize(31, position187, tokenIndex187, true)
			return true
		l187:
			memoize(31, position187, tokenIndex187, false)
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 32 sep <- <(space ',' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{32, position}]; ok {
				return memoizedResult(memoized)
			}
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				if !_rules[rulespace]() {
					goto l195
				}
				if buffer[position] != rune(',') {
					goto l195
				}
				position++
				if !_rules[rulespace]() {
					goto l195
				}
				add(rulesep, position196)
			}
			memoize(32, position195, tokenIndex195, true)
			return true
		l195:
			memoize(32, position195, tokenIndex195, false)
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 33 sepArraySlice <- <(space ':' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position197, tokenIndex197 := position, tokenIndex
			{
				position198 := position
				if !_rules[rulespace]() {
					goto l197
				}
				if buffer[position] != rune(':') {
					goto l197
				}
				position++
				if !_rules[rulespace]() {
					goto l197
				}
				add(rulesepArraySlice, position198)
			}
			memoize(33, position197, tokenIndex197, true)
			return true
		l197:
			memoize(33, position197, tokenIndex197, false)
			position, tokenIndex = position197, tokenIndex197
			return false
		},
		/* 34 scriptSelector <- <(scriptSelectorStart <command> scriptSelectorEnd Action23)> */
		nil,
		/* 35 command <- <(!scriptSelectorEnd .)+> */
		nil,
		/* 36 filterSelector <- <(filterSelectorStart query filterSelectorEnd Action24)> */
		nil,
		/* 37 query <- <(andQuery (logicOr andQuery Action25)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{37, position}]; ok {
				return memoizedResult(memoized)
			}
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				if !_rules[ruleandQuery]() {
					goto l202
				}
			l204:
				{
					position205, tokenIndex205 := position, tokenIndex
					{
						position206 := position
						if !_rules[rulespace]() {
							goto l205
						}
						if buffer[position] != rune('|') {
							goto l205
						}
						position++
						if buffer[position] != rune('|') {
							goto l205
						}
						position++
						if !_rules[rulespace]() {
							goto l205
						}
						add(rulelogicOr, position206)
					}
					if !_rules[ruleandQuery]() {
						goto l205
					}
					{
						add(ruleAction25, position)
					}
					goto l204
				l205:
					position, tokenIndex = position205, tokenIndex205
				}
				add(rulequery, position203)
			}
			memoize(37, position202, tokenIndex202, true)
			return true
		l202:
			memoize(37, position202, tokenIndex202, false)
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 38 andQuery <- <(basicQuery (logicAnd basicQuery Action26)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{38, position}]; ok {
				return memoizedResult(memoized)
			}
			position208, tokenIndex208 := position, tokenIndex
			{
				position209 := position
				if !_rules[rulebasicQuery]() {
					goto l208
				}
			l210:
				{
					position211, tokenIndex211 := position, tokenIndex
					{
						position212 := position
						if !_rules[rulespace]() {
							goto l211
						}
						if buffer[position] != rune('&') {
							goto l211
						}
						position++
						if buffer[position] != rune('&') {
							goto l211
						}
						position++
						if !_rules[rulespace]() {
							goto l211
						}
						add(rulelogicAnd, position212)
					}
					if !_rules[rulebasicQuery]() {
						goto l211
					}
					{
						add(ruleAction26, position)
					}
					goto l210
				l211:
					position, tokenIndex = position211, tokenIndex211
				}
				add(ruleandQuery, position209)
			}
			memoize(38, position208, tokenIndex208, true)
			return true
		l208:
			memoize(38, position208, tokenIndex208, false)
			position, tokenIndex = position208, tokenIndex208
			return false
		},
		/* 39 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action27) / (<(logicNot? jsonpathFilter)> Action28))> */
		func() bool {
			if memoized, ok := memoization[memoKey{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position214, tokenIndex214 := position, tokenIndex
			{
				position215 := position
				{
					position216, tokenIndex216 := position, tokenIndex
					{
						position218 := position
						if buffer[position] != rune('(') {
							goto l217
						}
						position++
						if !_rules[rulespace]() {
							goto l217
						}
						add(rulesubQueryStart, position218)
					}
					if !_rules[rulequery]() {
						goto l217
					}
					{
						position219 := position
						if !_rules[rulespace]() {
							goto l217
						}
						if buffer[position] != rune(')') {
							goto l217
						}
						position++
						add(rulesubQueryEnd, position219)
					}
					goto l216
				l217:
					position, tokenIndex = position216, tokenIndex216
					{
						position221 := position
						{
							position222 := position
							{
								position223, tokenIndex223 := position, tokenIndex
								if !_rules[ruleqParam]() {
									goto l224
								}
								if !_rules[rulespace]() {
									goto l224
								}
								{
									position225, tokenIndex225 := position, tokenIndex
									if buffer[position] != rune('=') {
										goto l226
									}
									position++
									if buffer[position] != rune('=') {
										goto l226
									}
									position++
									if !_rules[rulespace]() {
										goto l226
									}
									if !_rules[ruleqParam]() {
										goto l226
									}
									{
										add(ruleAction29, position)
									}
									goto l225
								l226:
									position, tokenIndex = position225, tokenIndex225
									if buffer[position] != rune('!') {
										goto l224
									}
									position++
									if buffer[position] != rune('=') {
										goto l224
									}
									position++
									if !_rules[rulespace]() {
										goto l224
									}
									if !_rules[ruleqParam]() {
										goto l224
									}
									{
										add(ruleAction30, position)
									}
								}
							l225:
								goto l223
							l224:
								position, tokenIndex = position223, tokenIndex223
								if !_rules[ruleqNumericParam]() {
									goto l229
								}
								if !_rules[rulespace]() {
									goto l229
								}
								{
									position230, tokenIndex230 := position, tokenIndex
									if buffer[position] != rune('<') {
										goto l231
									}
									position++
									if buffer[position] != rune('=') {
										goto l231
									}
									position++
									if !_rules[rulespace]() {
										goto l231
									}
									if !_rules[ruleqNumericParam]() {
										goto l231
									}
									{
										add(ruleAction31, position)
									}
									goto l230
								l231:
									position, tokenIndex = position230, tokenIndex230
									if buffer[position] != rune('<') {
										goto l233
									}
									position++
									if !_rules[rulespace]() {
										goto l233
									}
									if !_rules[ruleqNumericParam]() {
										goto l233
									}
									{
										add(ruleAction32, position)
									}
									goto l230
								l233:
									position, tokenIndex = position230, tokenIndex230
									if buffer[position] != rune('>') {
										goto l235
									}
									position++
									if buffer[position] != rune('=') {
										goto l235
									}
									position++
									if !_rules[rulespace]() {
										goto l235
									}
									if !_rules[ruleqNumericParam]() {
										goto l235
									}
									{
										add(ruleAction33, position)
									}
									goto l230
								l235:
									position, tokenIndex = position230, tokenIndex230
									if buffer[position] != rune('>') {
										goto l229
									}
									position++
									if !_rules[rulespace]() {
										goto l229
									}
									if !_rules[ruleqNumericParam]() {
										goto l229
									}
									{
										add(ruleAction34, position)
									}
								}
							l230:
								goto l223
							l229:
								position, tokenIndex = position223, tokenIndex223
								if !_rules[rulesingleJsonpathFilter]() {
									goto l220
								}
								if !_rules[rulespace]() {
									goto l220
								}
								if buffer[position] != rune('=') {
									goto l220
								}
								position++
								if buffer[position] != rune('~') {
									goto l220
								}
								position++
								if !_rules[rulespace]() {
									goto l220
								}
								if buffer[position] != rune('/') {
									goto l220
								}
								position++
								{
									position238 := position
									{
										position239 := position
									l240:
										{
											position241, tokenIndex241 := position, tokenIndex
											{
												position242, tokenIndex242 := position, tokenIndex
												if buffer[position] != rune('\\') {
													goto l243
												}
												position++
												{
													position244, tokenIndex244 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l245
													}
													position++
													goto l244
												l245:
													position, tokenIndex = position244, tokenIndex244
													if buffer[position] != rune('/') {
														goto l243
													}
													position++
												}
											l244:
												goto l242
											l243:
												position, tokenIndex = position242, tokenIndex242
												{
													position246, tokenIndex246 := position, tokenIndex
													if buffer[position] != rune('/') {
														goto l246
													}
													position++
													goto l241
												l246:
													position, tokenIndex = position246, tokenIndex246
												}
												if !matchDot() {
													goto l241
												}
											}
										l242:
											goto l240
										l241:
											position, tokenIndex = position241, tokenIndex241
										}
										add(ruleregex, position239)
									}
									add(rulePegText, position238)
								}
								if buffer[position] != rune('/') {
									goto l220
								}
								position++
								{
									add(ruleAction35, position)
								}
							}
						l223:
							add(rulecomparator, position222)
						}
						add(rulePegText, position221)
					}
					{
						add(ruleAction27, position)
					}
					goto l216
				l220:
					position, tokenIndex = position216, tokenIndex216
					{
						position249 := position
						{
							position250, tokenIndex250 := position, tokenIndex
							{
								position252 := position
								if buffer[position] != rune('!') {
									goto l250
								}
								position++
								if !_rules[rulespace]() {
									goto l250
								}
								add(rulelogicNot, position252)
							}
							goto l251
						l250:
							position, tokenIndex = position250, tokenIndex250
						}
					l251:
						if !_rules[rulejsonpathFilter]() {
							goto l214
						}
						add(rulePegText, position249)
					}
					{
						add(ruleAction28, position)
					}
				}
			l216:
				add(rulebasicQuery, position215)
			}
			memoize(39, position214, tokenIndex214, true)
			return true
		l214:
			memoize(39, position214, tokenIndex214, false)
			position, tokenIndex = position214, tokenIndex214
			return false
		},
		/* 40 logicOr <- <(space ('|' '|') space)> */
		nil,
		/* 41 logicAnd <- <(space ('&' '&') space)> */
		nil,
		/* 42 logicNot <- <('!' space)> */
		nil,
		/* 43 comparator <- <((qParam space (('=' '=' space qParam Action29) / ('!' '=' space qParam Action30))) / (qNumericParam space (('<' '=' space qNumericParam Action31) / ('<' space qNumericParam Action32) / ('>' '=' space qNumericParam Action33) / ('>' space qNumericParam Action34))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action35))> */
		nil,
		/* 44 qParam <- <((qLiteral Action36) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position258, tokenIndex258 := position, tokenIndex
			{
				position259 := position
				{
					position260, tokenIndex260 := position, tokenIndex
					{
						position262 := position
						{
							switch buffer[position] {
							case 'N', 'n':
								{
									position264 := position
									{
										position265, tokenIndex265 := position, tokenIndex
										if buffer[position] != rune('n') {
											goto l266
										}
										position++
										if buffer[position] != rune('u') {
											goto l266
										}
										position++
										if buffer[position] != rune('l') {
											goto l266
										}
										position++
										if buffer[position] != rune('l') {
											goto l266
										}
										position++
										goto l265
									l266:
										position, tokenIndex = position265, tokenIndex265
										if buffer[position] != rune('N') {
											goto l267
										}
										position++
										if buffer[position] != rune('u') {
											goto l267
										}
										position++
										if buffer[position] != rune('l') {
											goto l267
										}
										position++
										if buffer[position] != rune('l') {
											goto l267
										}
										position++
										goto l265
									l267:
										position, tokenIndex = position265, tokenIndex265
										if buffer[position] != rune('N') {
											goto l261
										}
										position++
										if buffer[position] != rune('U') {
											goto l261
										}
										position++
										if buffer[position] != rune('L') {
											goto l261
										}
										position++
										if buffer[position] != rune('L') {
											goto l261
										}
										position++
									}
								l265:
									{
										add(ruleAction46, position)
									}
									add(rulelNull, position264)
								}
							case '"', '\'':
								{
									position269 := position
									{
										position270, tokenIndex270 := position, tokenIndex
										if buffer[position] != rune('\'') {
											goto l271
										}
										position++
										{
											position272 := position
										l273:
											{
												position274, tokenIndex274 := position, tokenIndex
												{
													position275, tokenIndex275 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l276
													}
													position++
													{
														position277, tokenIndex277 := position, tokenIndex
														if buffer[position] != rune('\\') {
															goto l278
														}
														position++
														goto l277
													l278:
														position, tokenIndex = position277, tokenIndex277
														if buffer[position] != rune('\'') {
															goto l276
														}
														position++
													}
												l277:
													goto l275
												l276:
													position, tokenIndex = position275, tokenIndex275
													{
														position279, tokenIndex279 := position, tokenIndex
														if buffer[position] != rune('\'') {
															goto l279
														}
														position++
														goto l274
													l279:
														position, tokenIndex = position279, tokenIndex279
													}
													if !matchDot() {
														goto l274
													}
												}
											l275:
												goto l273
											l274:
												position, tokenIndex = position274, tokenIndex274
											}
											add(rulePegText, position272)
										}
										if buffer[position] != rune('\'') {
											goto l271
										}
										position++
										{
											add(ruleAction44, position)
										}
										goto l270
									l271:
										position, tokenIndex = position270, tokenIndex270
										if buffer[position] != rune('"') {
											goto l261
										}
										position++
										{
											position281 := position
										l282:
											{
												position283, tokenIndex283 := position, tokenIndex
												{
													position284, tokenIndex284 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l285
													}
													position++
													{
														position286, tokenIndex286 := position, tokenIndex
														if buffer[position] != rune('\\') {
															goto l287
														}
														position++
														goto l286
													l287:
														position, tokenIndex = position286, tokenIndex286
														if buffer[position] != rune('"') {
															goto l285
														}
														position++
													}
												l286:
													goto l284
												l285:
													position, tokenIndex = position284, tokenIndex284
													{
														position288, tokenIndex288 := position, tokenIndex
														if buffer[position] != rune('"') {
															goto l288
														}
														position++
														goto l283
													l288:
														position, tokenIndex = position288, tokenIndex288
													}
													if !matchDot() {
														goto l283
													}
												}
											l284:
												goto l282
											l283:
												position, tokenIndex = position283, tokenIndex283
											}
											add(rulePegText, position281)
										}
										if buffer[position] != rune('"') {
											goto l261
										}
										position++
										{
											add(ruleAction45, position)
										}
									}
								l270:
									add(rulelString, position269)
								}
							case 'F', 'T', 'f', 't':
								{
									position290 := position
									{
										position291, tokenIndex291 := position, tokenIndex
										{
											position293, tokenIndex293 := position, tokenIndex
											if buffer[position] != rune('t') {
												goto l294
											}
											position++
											if buffer[position] != rune('r') {
												goto l294
											}
											position++
											if buffer[position] != rune('u') {
												goto l294
											}
											position++
											if buffer[position] != rune('e') {
												goto l294
											}
											position++
											goto l293
										l294:
											position, tokenIndex = position293, tokenIndex293
											if buffer[position] != rune('T') {
												goto l295
											}
											position++
											if buffer[position] != rune('r') {
												goto l295
											}
											position++
											if buffer[position] != rune('u') {
												goto l295
											}
											position++
											if buffer[position] != rune('e') {
												goto l295
											}
											position++
											goto l293
										l295:
											position, tokenIndex = position293, tokenIndex293
											if buffer[position] != rune('T') {
												goto l292
											}
											position++
											if buffer[position] != rune('R') {
												goto l292
											}
											position++
											if buffer[position] != rune('U') {
												goto l292
											}
											position++
											if buffer[position] != rune('E') {
												goto l292
											}
											position++
										}
									l293:
										{
											add(ruleAction42, position)
										}
										goto l291
									l292:
										position, tokenIndex = position291, tokenIndex291
										{
											position297, tokenIndex297 := position, tokenIndex
											if buffer[position] != rune('f') {
												goto l298
											}
											position++
											if buffer[position] != rune('a') {
												goto l298
											}
											position++
											if buffer[position] != rune('l') {
												goto l298
											}
											position++
											if buffer[position] != rune('s') {
												goto l298
											}
											position++
											if buffer[position] != rune('e') {
												goto l298
											}
											position++
											goto l297
										l298:
											position, tokenIndex = position297, tokenIndex297
											if buffer[position] != rune('F') {
												goto l299
											}
											position++
											if buffer[position] != rune('a') {
												goto l299
											}
											position++
											if buffer[position] != rune('l') {
												goto l299
											}
											position++
											if buffer[position] != rune('s') {
												goto l299
											}
											position++
											if buffer[position] != rune('e') {
												goto l299
											}
											position++
											goto l297
										l299:
											position, tokenIndex = position297, tokenIndex297
											if buffer[position] != rune('F') {
												goto l261
											}
											position++
											if buffer[position] != rune('A') {
												goto l261
											}
											position++
											if buffer[position] != rune('L') {
												goto l261
											}
											position++
											if buffer[position] != rune('S') {
												goto l261
											}
											position++
											if buffer[position] != rune('E') {
												goto l261
											}
											position++
										}
									l297:
										{
											add(ruleAction43, position)
										}
									}
								l291:
									add(rulelBool, position290)
								}
							default:
								if !_rules[rulelNumber]() {
									goto l261
								}
							}
						}

						add(ruleqLiteral, position262)
					}
					{
						add(ruleAction36, position)
					}
					goto l260
				l261:
					position, tokenIndex = position260, tokenIndex260
					if !_rules[rulesingleJsonpathFilter]() {
						goto l258
					}
				}
			l260:
				add(ruleqParam, position259)
			}
			memoize(44, position258, tokenIndex258, true)
			return true
		l258:
			memoize(44, position258, tokenIndex258, false)
			position, tokenIndex = position258, tokenIndex258
			return false
		},
		/* 45 qNumericParam <- <((lNumber Action37) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position302, tokenIndex302 := position, tokenIndex
			{
				position303 := position
				{
					position304, tokenIndex304 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l305
					}
					{
						add(ruleAction37, position)
					}
					goto l304
				l305:
					position, tokenIndex = position304, tokenIndex304
					if !_rules[rulesingleJsonpathFilter]() {
						goto l302
					}
				}
			l304:
				add(ruleqNumericParam, position303)
			}
			memoize(45, position302, tokenIndex302, true)
			return true
		l302:
			memoize(45, position302, tokenIndex302, false)
			position, tokenIndex = position302, tokenIndex302
			return false
		},
		/* 46 qLiteral <- <((&('N' | 'n') lNull) | (&('"' | '\'') lString) | (&('F' | 'T' | 'f' | 't') lBool) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') lNumber))> */
		nil,
		/* 47 singleJsonpathFilter <- <(<jsonpathFilter> Action38)> */
		func() bool {
			if memoized, ok := memoization[memoKey{47, position}]; ok {
				return memoizedResult(memoized)
			}
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				{
					position310 := position
					if !_rules[rulejsonpathFilter]() {
						goto l308
					}
					add(rulePegText, position310)
				}
				{
					add(ruleAction38, position)
				}
				add(rulesingleJsonpathFilter, position309)
			}
			memoize(47, position308, tokenIndex308, true)
			return true
		l308:
			memoize(47, position308, tokenIndex308, false)
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 48 jsonpathFilter <- <(Action39 jsonpathParameter Action40)> */
		func() bool {
			if memoized, ok := memoization[memoKey{48, position}]; ok {
				return memoizedResult(memoized)
			}
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				{
					add(ruleAction39, position)
				}
				{
					position315 := position
					if !_rules[rulespace]() {
						goto l312
					}
					{
						position316 := position
						{
							position317, tokenIndex317 := position, tokenIndex
							if !_rules[rulerootIdentifier]() {
								goto l318
							}
							goto l317
						l318:
							position, tokenIndex = position317, tokenIndex317
							{
								position319 := position
								if buffer[position] != rune('@') {
									goto l312
								}
								position++
								{
									add(ruleAction4, position)
								}
								add(rulecurrentNodeIdentifier, position319)
							}
						}
					l317:
						add(ruleparameterRootNode, position316)
					}
					if !_rules[rulesegments]() {
						goto l312
					}
					add(rulejsonpathParameter, position315)
				}
				{
					add(ruleAction40, position)
				}
				add(rulejsonpathFilter, position313)
			}
			memoize(48, position312, tokenIndex312, true)
			return true
		l312:
			memoize(48, position312, tokenIndex312, false)
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 49 lNumber <- <(<(('-' / '+')? [0-9] ((&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('.') '.') | (&('+') '+') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action41)> */
		func() bool {
			if memoized, ok := memoization[memoKey{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position322, tokenIndex322 := position, tokenIndex
			{
				position323 := position
				{
					position324 := position
					{
						position325, tokenIndex325 := position, tokenIndex
						{
							position327, tokenIndex327 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l328
							}
							position++
							goto l327
						l328:
							position, tokenIndex = position327, tokenIndex327
							if buffer[position] != rune('+') {
								goto l325
							}
							position++
						}
					l327:
						goto l326
					l325:
						position, tokenIndex = position325, tokenIndex325
					}
				l326:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l322
					}
					position++
				l329:
					{
						position330, tokenIndex330 := position, tokenIndex
						{
							switch buffer[position] {
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								position++
							case '.':
								position++
							case '+':
								position++
							case '-':
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								position++
							default:
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l330
								}
								position++
							}
						}

						goto l329
					l330:
						position, tokenIndex = position330, tokenIndex330
					}
					add(rulePegText, position324)
				}
				{
					add(ruleAction41, position)
				}
				add(rulelNumber, position323)
			}
			memoize(49, position322, tokenIndex322, true)
			return true
		l322:
			memoize(49, position322, tokenIndex322, false)
			position, tokenIndex = position322, tokenIndex322
			return false
		},
		/* 50 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action42) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action43))> */
		nil,
		/* 51 lString <- <(('\'' <(('\\' ('\\' / '\'')) / (!'\'' .))*> '\'' Action44) / ('"' <(('\\' ('\\' / '"')) / (!'"' .))*> '"' Action45))> */
		nil,
		/* 52 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action46)> */
		nil,
		/* 53 regex <- <(('\\' ('\\' / '/')) / (!'/' .))*> */
		nil,
		/* 54 squareBracketStart <- <('[' space)> */
		nil,
		/* 55 squareBracketEnd <- <(space ']')> */
		nil,
		/* 56 scriptSelectorStart <- <('(' space)> */
		nil,
		/* 57 scriptSelectorEnd <- <(space ')')> */
		func() bool {
			if memoized, ok := memoization[memoKey{57, position}]; ok {
				return memoizedResult(memoized)
			}
			position340, tokenIndex340 := position, tokenIndex
			{
				position341 := position
				if !_rules[rulespace]() {
					goto l340
				}
				if buffer[position] != rune(')') {
					goto l340
				}
				position++
				add(rulescriptSelectorEnd, position341)
			}
			memoize(57, position340, tokenIndex340, true)
			return true
		l340:
			memoize(57, position340, tokenIndex340, false)
			position, tokenIndex = position340, tokenIndex340
			return false
		},
		/* 58 filterSelectorStart <- <('?' '(' space)> */
		nil,
		/* 59 filterSelectorEnd <- <(space ')')> */
		nil,
		/* 60 subQueryStart <- <('(' space)> */
		nil,
		/* 61 subQueryEnd <- <(space ')')> */
		nil,
		/* 62 space <- <' '*> */
		func() bool {
			if memoized, ok := memoization[memoKey{62, position}]; ok {
				return memoizedResult(memoized)
			}
			position346, tokenIndex346 := position, tokenIndex
			{
				position347 := position
			l348:
				{
					position349, tokenIndex349 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l349
					}
					position++
					goto l348
				l349:
					position, tokenIndex = position349, tokenIndex349
				}
				add(rulespace, position347)
			}
			memoize(62, position346, tokenIndex346, true)
			return true
		},
		/* 64 Action0 <- <{
		    p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
		    p.setConnectedText(p.root)
		}> */
		nil,
		nil,
		/* 66 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		nil,
		/* 67 Action2 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 68 Action3 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 69 Action4 <- <{
		    p.pushCurrentNodeIdentifier()
		}> */
		nil,
		/* 70 Action5 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		nil,
		/* 71 Action6 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		nil,
		/* 72 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		nil,
		/* 73 Action8 <- <{
		    p.setLastNodeText(text)
		}> */
		nil,
		/* 74 Action9 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		nil,
		/* 75 Action10 <- <{
		    p.push(text)
		}> */
		nil,
		/* 76 Action11 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		nil,
		/* 77 Action12 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		nil,
		/* 78 Action13 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		nil,
		/* 79 Action14 <- <{
		    p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))
		}> */
		nil,
		/* 80 Action15 <- <{
		    p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))
		}> */
		nil,
		/* 81 Action16 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		nil,
		/* 82 Action17 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted {
		        step.number = 1
		    }

		    if step.number >= 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		nil,
		/* 83 Action18 <- <{
		    p.pushIndexSubscript(text)
		}> */
		nil,
		/* 84 Action19 <- <{
		    p.pushWildcardSubscript()
		}> */
		nil,
		/* 85 Action20 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		nil,
		/* 86 Action21 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		nil,
		/* 87 Action22 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		nil,
		/* 88 Action23 <- <{
		    p.pushScriptQualifier(text)
		}> */
		nil,
		/* 89 Action24 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		nil,
		/* 90 Action25 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		nil,
		/* 91 Action26 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		nil,
		/* 92 Action27 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		        _, leftIsCurrentNode := checkQuery.leftParam.param.(*syntaxQueryParamCurrentNode)
		        _, rightIsCurrentNode := checkQuery.rightParam.param.(*syntaxQueryParamCurrentNode)
		        if leftIsCurrentNode && rightIsCurrentNode {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		nil,
		/* 93 Action28 <- <{
		    _ = p.pop()
		    jsonpathFilter := p.pop().(syntaxQuery)

		    if text[0:1] == `!` {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		nil,
		/* 94 Action29 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		nil,
		/* 95 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		nil,
		/* 96 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		nil,
		/* 97 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		nil,
		/* 98 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		nil,
		/* 99 Action34 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		nil,
		/* 100 Action35 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		nil,
		/* 101 Action36 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 102 Action37 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 103 Action38 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		nil,
		/* 104 Action39 <- <{
		    p.saveParams()
		}> */
		nil,
		/* 105 Action40 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootNodeIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
		        p.push(true)
		    case *syntaxCurrentNodeIdentifier:
		        p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
		        p.push(false)
		    }
		}> */
		nil,
		/* 106 Action41 <- <{
		    p.push(p.toFloat(text))
		}> */
		nil,
		/* 107 Action42 <- <{
		    p.push(true)
		}> */
		nil,
		/* 108 Action43 <- <{
		    p.push(false)
		}> */
		nil,
		/* 109 Action44 <- <{
		    p.push(p.unescape(text))
		}> */
		nil,
		/* 110 Action45 <- <{
		    p.push(p.unescape(text))
		}> */
		nil,
		/* 111 Action46 <- <{
		    p.push(nil)
		}> */
		nil,
	}
	p.rules = _rules
	return nil
}
