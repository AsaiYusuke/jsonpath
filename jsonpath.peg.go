package jsonpath

// Code generated by peg -inline -switch jsonpath.peg DO NOT EDIT.

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpath
	rulejsonpathParameter
	rulecontinuedJsonpath
	rulerootNode
	ruleparameterRootNode
	rulechildNode
	rulefunction
	rulefunctionName
	rulebracketNode
	rulerootIdentifier
	rulecurrentRootIdentifier
	ruledotChildIdentifier
	rulesignsWithoutHyphenUnderscore
	rulebracketChildIdentifier
	rulebracketNodeIdentifier
	rulewildcardIdentifier
	rulesingleQuotedNodeIdentifier
	ruledoubleQuotedNodeIdentifier
	rulehexDigits
	rulehexDigit
	rulequalifier
	ruleunion
	ruleindex
	ruleslice
	ruleanyIndex
	ruleindexNumber
	rulesep
	rulesepSlice
	rulescript
	rulecommand
	rulefilter
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptStart
	rulescriptEnd
	rulefilterStart
	rulefilterEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpath",
	"jsonpathParameter",
	"continuedJsonpath",
	"rootNode",
	"parameterRootNode",
	"childNode",
	"function",
	"functionName",
	"bracketNode",
	"rootIdentifier",
	"currentRootIdentifier",
	"dotChildIdentifier",
	"signsWithoutHyphenUnderscore",
	"bracketChildIdentifier",
	"bracketNodeIdentifier",
	"wildcardIdentifier",
	"singleQuotedNodeIdentifier",
	"doubleQuotedNodeIdentifier",
	"hexDigits",
	"hexDigit",
	"qualifier",
	"union",
	"index",
	"slice",
	"anyIndex",
	"indexNumber",
	"sep",
	"sepSlice",
	"script",
	"command",
	"filter",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptStart",
	"scriptEnd",
	"filterStart",
	"filterEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer         string
	buffer         []rune
	rules          [107]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootIdentifier(p.pop().(syntaxNode))
			p.setConnectedText(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction3:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction4:

			p.setLastNodeText(text)

		case ruleAction5:

			p.pushFunction(text, p.pop().(string))

		case ruleAction6:

			p.push(text)

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.pushRootIdentifier()

		case ruleAction9:

			p.pushCurrentRootIdentifier()

		case ruleAction10:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction11:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction12:

			p.pushChildWildcardIdentifier()

		case ruleAction13:

			p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))

		case ruleAction14:

			p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))

		case ruleAction15:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction16:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted {
				step.number = 1
			}

			if step.number >= 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction17:

			p.pushIndexSubscript(text)

		case ruleAction18:

			p.pushWildcardSubscript()

		case ruleAction19:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction20:

			p.pushIndexSubscript(`1`)

		case ruleAction21:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction22:

			p.pushScriptQualifier(text)

		case ruleAction23:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction24:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction25:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction26:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
				_, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
				_, rightIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
				if leftIsCurrentRoot && rightIsCurrentRoot {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction27:

			_ = p.pop()
			jsonpathFilter := p.pop().(syntaxQuery)

			if text[0:1] == `!` {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction28:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction29:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction34:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction35:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction36:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction37:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction38:

			p.saveParams()

		case ruleAction39:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootIdentifier:
				p.pushCompareParameterRoot(p.deleteRootIdentifier(node))
				p.push(true)
			case *syntaxCurrentRootIdentifier:
				p.pushCompareParameterCurrentRoot(p.deleteRootIdentifier(node))
				p.push(false)
			}

		case ruleAction40:

			p.push(p.toFloat(text))

		case ruleAction41:

			p.push(true)

		case ruleAction42:

			p.push(false)

		case ruleAction43:

			p.push(p.unescape(text))

		case ruleAction44:

			p.push(p.unescape(text))

		case ruleAction45:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func DisableMemoize() func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.disableMemoize = true
		return nil
	}
}

type memo struct {
	Matched bool
	Partial []token32
}

type memoKey struct {
	Rule     uint32
	Position uint32
}

func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
		memoization          map[memoKey]memo
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey]memo)
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	memoize := func(rule uint32, begin uint32, tokenIndexStart uint32, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey{rule, begin}
		if !matched {
			memoization[key] = memo{Matched: false}
		} else {
			t := tree.tree[tokenIndexStart:tokenIndex]
			tokenCopy := make([]token32, len(t))
			copy(tokenCopy, t)
			memoization[key] = memo{Matched: true, Partial: tokenCopy}
		}
	}

	memoizedResult := func(m memo) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += uint32(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > max.end {
			max = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <((jsonpath END Action0) / (jsonpath? <.*> END Action1))> */
		func() bool {
			if memoized, ok := memoization[memoKey{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[rulejsonpath]() {
						goto l3
					}
					if !_rules[ruleEND]() {
						goto l3
					}
					{
						add(ruleAction0, position)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position5, tokenIndex5 := position, tokenIndex
						if !_rules[rulejsonpath]() {
							goto l5
						}
						goto l6
					l5:
						position, tokenIndex = position5, tokenIndex5
					}
				l6:
					{
						position7 := position
					l8:
						{
							position9, tokenIndex9 := position, tokenIndex
							if !matchDot() {
								goto l9
							}
							goto l8
						l9:
							position, tokenIndex = position9, tokenIndex9
						}
						add(rulePegText, position7)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					{
						add(ruleAction1, position)
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			if memoized, ok := memoization[memoKey{1, position}]; ok {
				return memoizedResult(memoized)
			}
			position11, tokenIndex11 := position, tokenIndex
			{
				position12 := position
				{
					position13, tokenIndex13 := position, tokenIndex
					if !matchDot() {
						goto l13
					}
					goto l11
				l13:
					position, tokenIndex = position13, tokenIndex13
				}
				add(ruleEND, position12)
			}
			memoize(1, position11, tokenIndex11, true)
			return true
		l11:
			memoize(1, position11, tokenIndex11, false)
			position, tokenIndex = position11, tokenIndex11
			return false
		},
		/* 2 jsonpath <- <(space rootNode continuedJsonpath)> */
		func() bool {
			if memoized, ok := memoization[memoKey{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[rulespace]() {
					goto l14
				}
				{
					position16 := position
					{
						position17, tokenIndex17 := position, tokenIndex
						if !_rules[rulerootIdentifier]() {
							goto l18
						}
						goto l17
					l18:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[rulebracketNode]() {
							goto l19
						}
						goto l17
					l19:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruledotChildIdentifier]() {
							goto l14
						}
					}
				l17:
					add(rulerootNode, position16)
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l14
				}
				add(rulejsonpath, position15)
			}
			memoize(2, position14, tokenIndex14, true)
			return true
		l14:
			memoize(2, position14, tokenIndex14, false)
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 jsonpathParameter <- <(space parameterRootNode continuedJsonpath)> */
		nil,
		/* 4 continuedJsonpath <- <(childNode* function* space Action2)> */
		func() bool {
			if memoized, ok := memoization[memoKey{4, position}]; ok {
				return memoizedResult(memoized)
			}
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
			l23:
				{
					position24, tokenIndex24 := position, tokenIndex
					{
						position25 := position
						{
							position26, tokenIndex26 := position, tokenIndex
							if buffer[position] != rune('.') {
								goto l27
							}
							position++
							if buffer[position] != rune('.') {
								goto l27
							}
							position++
							{
								position28, tokenIndex28 := position, tokenIndex
								if !_rules[rulebracketNode]() {
									goto l29
								}
								goto l28
							l29:
								position, tokenIndex = position28, tokenIndex28
								if !_rules[ruledotChildIdentifier]() {
									goto l27
								}
							}
						l28:
							{
								add(ruleAction3, position)
							}
							goto l26
						l27:
							position, tokenIndex = position26, tokenIndex26
							{
								position32 := position
								if buffer[position] != rune('.') {
									goto l31
								}
								position++
								if !_rules[ruledotChildIdentifier]() {
									goto l31
								}
								add(rulePegText, position32)
							}
							{
								add(ruleAction4, position)
							}
							goto l26
						l31:
							position, tokenIndex = position26, tokenIndex26
							if !_rules[rulebracketNode]() {
								goto l24
							}
						}
					l26:
						add(rulechildNode, position25)
					}
					goto l23
				l24:
					position, tokenIndex = position24, tokenIndex24
				}
			l34:
				{
					position35, tokenIndex35 := position, tokenIndex
					{
						position36 := position
						{
							position37 := position
							if buffer[position] != rune('.') {
								goto l35
							}
							position++
							{
								position38 := position
								{
									position39 := position
									{
										switch buffer[position] {
										case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
											position++
										case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
											position++
										case '_':
											position++
										case '-':
											position++
										default:
											if c := buffer[position]; c < rune('a') || c > rune('z') {
												goto l35
											}
											position++
										}
									}

								l40:
									{
										position41, tokenIndex41 := position, tokenIndex
										{
											switch buffer[position] {
											case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
												position++
											case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
												position++
											case '_':
												position++
											case '-':
												position++
											default:
												if c := buffer[position]; c < rune('a') || c > rune('z') {
													goto l41
												}
												position++
											}
										}

										goto l40
									l41:
										position, tokenIndex = position41, tokenIndex41
									}
									add(rulePegText, position39)
								}
								{
									add(ruleAction6, position)
								}
								add(rulefunctionName, position38)
							}
							if buffer[position] != rune('(') {
								goto l35
							}
							position++
							if buffer[position] != rune(')') {
								goto l35
							}
							position++
							add(rulePegText, position37)
						}
						{
							add(ruleAction5, position)
						}
						add(rulefunction, position36)
					}
					goto l34
				l35:
					position, tokenIndex = position35, tokenIndex35
				}
				if !_rules[rulespace]() {
					goto l21
				}
				{
					add(ruleAction2, position)
				}
				add(rulecontinuedJsonpath, position22)
			}
			memoize(4, position21, tokenIndex21, true)
			return true
		l21:
			memoize(4, position21, tokenIndex21, false)
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 5 rootNode <- <(rootIdentifier / bracketNode / dotChildIdentifier)> */
		nil,
		/* 6 parameterRootNode <- <(rootIdentifier / currentRootIdentifier)> */
		nil,
		/* 7 childNode <- <(('.' '.' (bracketNode / dotChildIdentifier) Action3) / (<('.' dotChildIdentifier)> Action4) / bracketNode)> */
		nil,
		/* 8 function <- <(<('.' functionName ('(' ')'))> Action5)> */
		nil,
		/* 9 functionName <- <(<((&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> Action6)> */
		nil,
		/* 10 bracketNode <- <(<(squareBracketStart (bracketChildIdentifier / qualifier) squareBracketEnd)> Action7)> */
		func() bool {
			if memoized, ok := memoization[memoKey{10, position}]; ok {
				return memoizedResult(memoized)
			}
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				{
					position54 := position
					{
						position55 := position
						if buffer[position] != rune('[') {
							goto l52
						}
						position++
						if !_rules[rulespace]() {
							goto l52
						}
						add(rulesquareBracketStart, position55)
					}
					{
						position56, tokenIndex56 := position, tokenIndex
						{
							position58 := position
							if !_rules[rulebracketNodeIdentifier]() {
								goto l57
							}
						l59:
							{
								position60, tokenIndex60 := position, tokenIndex
								if !_rules[rulesep]() {
									goto l60
								}
								if !_rules[rulebracketNodeIdentifier]() {
									goto l60
								}
								{
									add(ruleAction11, position)
								}
								goto l59
							l60:
								position, tokenIndex = position60, tokenIndex60
							}
							{
								position62, tokenIndex62 := position, tokenIndex
								if !_rules[rulesep]() {
									goto l62
								}
								goto l57
							l62:
								position, tokenIndex = position62, tokenIndex62
							}
							add(rulebracketChildIdentifier, position58)
						}
						goto l56
					l57:
						position, tokenIndex = position56, tokenIndex56
						{
							position63 := position
							{
								switch buffer[position] {
								case '?':
									{
										position65 := position
										{
											position66 := position
											position++
											if buffer[position] != rune('(') {
												goto l52
											}
											position++
											if !_rules[rulespace]() {
												goto l52
											}
											add(rulefilterStart, position66)
										}
										if !_rules[rulequery]() {
											goto l52
										}
										{
											position67 := position
											if !_rules[rulespace]() {
												goto l52
											}
											if buffer[position] != rune(')') {
												goto l52
											}
											position++
											add(rulefilterEnd, position67)
										}
										{
											add(ruleAction23, position)
										}
										add(rulefilter, position65)
									}
								case '(':
									{
										position69 := position
										{
											position70 := position
											position++
											if !_rules[rulespace]() {
												goto l52
											}
											add(rulescriptStart, position70)
										}
										{
											position71 := position
											{
												position72 := position
												{
													position75, tokenIndex75 := position, tokenIndex
													if !_rules[rulescriptEnd]() {
														goto l75
													}
													goto l52
												l75:
													position, tokenIndex = position75, tokenIndex75
												}
												if !matchDot() {
													goto l52
												}
											l73:
												{
													position74, tokenIndex74 := position, tokenIndex
													{
														position76, tokenIndex76 := position, tokenIndex
														if !_rules[rulescriptEnd]() {
															goto l76
														}
														goto l74
													l76:
														position, tokenIndex = position76, tokenIndex76
													}
													if !matchDot() {
														goto l74
													}
													goto l73
												l74:
													position, tokenIndex = position74, tokenIndex74
												}
												add(rulecommand, position72)
											}
											add(rulePegText, position71)
										}
										if !_rules[rulescriptEnd]() {
											goto l52
										}
										{
											add(ruleAction22, position)
										}
										add(rulescript, position69)
									}
								default:
									{
										position78 := position
										if !_rules[ruleindex]() {
											goto l52
										}
									l79:
										{
											position80, tokenIndex80 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l80
											}
											if !_rules[ruleindex]() {
												goto l80
											}
											{
												add(ruleAction15, position)
											}
											goto l79
										l80:
											position, tokenIndex = position80, tokenIndex80
										}
										{
											position82, tokenIndex82 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l82
											}
											goto l52
										l82:
											position, tokenIndex = position82, tokenIndex82
										}
										add(ruleunion, position78)
									}
								}
							}

							add(rulequalifier, position63)
						}
					}
				l56:
					{
						position83 := position
						if !_rules[rulespace]() {
							goto l52
						}
						if buffer[position] != rune(']') {
							goto l52
						}
						position++
						add(rulesquareBracketEnd, position83)
					}
					add(rulePegText, position54)
				}
				{
					add(ruleAction7, position)
				}
				add(rulebracketNode, position53)
			}
			memoize(10, position52, tokenIndex52, true)
			return true
		l52:
			memoize(10, position52, tokenIndex52, false)
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 11 rootIdentifier <- <('$' Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey{11, position}]; ok {
				return memoizedResult(memoized)
			}
			position85, tokenIndex85 := position, tokenIndex
			{
				position86 := position
				if buffer[position] != rune('$') {
					goto l85
				}
				position++
				{
					add(ruleAction8, position)
				}
				add(rulerootIdentifier, position86)
			}
			memoize(11, position85, tokenIndex85, true)
			return true
		l85:
			memoize(11, position85, tokenIndex85, false)
			position, tokenIndex = position85, tokenIndex85
			return false
		},
		/* 12 currentRootIdentifier <- <('@' Action9)> */
		nil,
		/* 13 dotChildIdentifier <- <(wildcardIdentifier / (<(('\\' signsWithoutHyphenUnderscore) / (!([\x00-\x1f] / '\x7f') !signsWithoutHyphenUnderscore .))+> !('(' ')') Action10))> */
		func() bool {
			if memoized, ok := memoization[memoKey{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				{
					position91, tokenIndex91 := position, tokenIndex
					if !_rules[rulewildcardIdentifier]() {
						goto l92
					}
					goto l91
				l92:
					position, tokenIndex = position91, tokenIndex91
					{
						position93 := position
						{
							position96, tokenIndex96 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l97
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l97
							}
							goto l96
						l97:
							position, tokenIndex = position96, tokenIndex96
							{
								position98, tokenIndex98 := position, tokenIndex
								{
									position99, tokenIndex99 := position, tokenIndex
									if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
										goto l100
									}
									position++
									goto l99
								l100:
									position, tokenIndex = position99, tokenIndex99
									if buffer[position] != rune('\x7f') {
										goto l98
									}
									position++
								}
							l99:
								goto l89
							l98:
								position, tokenIndex = position98, tokenIndex98
							}
							{
								position101, tokenIndex101 := position, tokenIndex
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l101
								}
								goto l89
							l101:
								position, tokenIndex = position101, tokenIndex101
							}
							if !matchDot() {
								goto l89
							}
						}
					l96:
					l94:
						{
							position95, tokenIndex95 := position, tokenIndex
							{
								position102, tokenIndex102 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l103
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l103
								}
								goto l102
							l103:
								position, tokenIndex = position102, tokenIndex102
								{
									position104, tokenIndex104 := position, tokenIndex
									{
										position105, tokenIndex105 := position, tokenIndex
										if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
											goto l106
										}
										position++
										goto l105
									l106:
										position, tokenIndex = position105, tokenIndex105
										if buffer[position] != rune('\x7f') {
											goto l104
										}
										position++
									}
								l105:
									goto l95
								l104:
									position, tokenIndex = position104, tokenIndex104
								}
								{
									position107, tokenIndex107 := position, tokenIndex
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l107
									}
									goto l95
								l107:
									position, tokenIndex = position107, tokenIndex107
								}
								if !matchDot() {
									goto l95
								}
							}
						l102:
							goto l94
						l95:
							position, tokenIndex = position95, tokenIndex95
						}
						add(rulePegText, position93)
					}
					{
						position108, tokenIndex108 := position, tokenIndex
						if buffer[position] != rune('(') {
							goto l108
						}
						position++
						if buffer[position] != rune(')') {
							goto l108
						}
						position++
						goto l89
					l108:
						position, tokenIndex = position108, tokenIndex108
					}
					{
						add(ruleAction10, position)
					}
				}
			l91:
				add(ruledotChildIdentifier, position90)
			}
			memoize(13, position89, tokenIndex89, true)
			return true
		l89:
			memoize(13, position89, tokenIndex89, false)
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 14 signsWithoutHyphenUnderscore <- <((&('{' | '|' | '}' | '~') [{-~]) | (&('`') '`') | (&('[' | '\\' | ']' | '^') [[-^]) | (&(':' | ';' | '<' | '=' | '>' | '?' | '@') [:-@]) | (&('/') '/') | (&('.') '.') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',') [ -,]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{14, position}]; ok {
				return memoizedResult(memoized)
			}
			position110, tokenIndex110 := position, tokenIndex
			{
				position111 := position
				{
					switch buffer[position] {
					case '{', '|', '}', '~':
						position++
					case '`':
						position++
					case '[', '\\', ']', '^':
						position++
					case ':', ';', '<', '=', '>', '?', '@':
						position++
					case '/':
						position++
					case '.':
						position++
					default:
						if c := buffer[position]; c < rune(' ') || c > rune(',') {
							goto l110
						}
						position++
					}
				}

				add(rulesignsWithoutHyphenUnderscore, position111)
			}
			memoize(14, position110, tokenIndex110, true)
			return true
		l110:
			memoize(14, position110, tokenIndex110, false)
			position, tokenIndex = position110, tokenIndex110
			return false
		},
		/* 15 bracketChildIdentifier <- <(bracketNodeIdentifier (sep bracketNodeIdentifier Action11)* !sep)> */
		nil,
		/* 16 bracketNodeIdentifier <- <((&('"') doubleQuotedNodeIdentifier) | (&('\'') singleQuotedNodeIdentifier) | (&('*') wildcardIdentifier))> */
		func() bool {
			if memoized, ok := memoization[memoKey{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				{
					switch buffer[position] {
					case '"':
						{
							position117 := position
							position++
							{
								position118 := position
							l119:
								{
									position120, tokenIndex120 := position, tokenIndex
									{
										position121, tokenIndex121 := position, tokenIndex
										if buffer[position] != rune('\\') {
											goto l122
										}
										position++
										{
											switch buffer[position] {
											case 'u':
												if !_rules[rulehexDigits]() {
													goto l122
												}
											case 't':
												position++
											case 'r':
												position++
											case 'n':
												position++
											case 'f':
												position++
											case 'b':
												position++
											case '\\':
												position++
											case '/':
												position++
											default:
												if buffer[position] != rune('"') {
													goto l122
												}
												position++
											}
										}

										goto l121
									l122:
										position, tokenIndex = position121, tokenIndex121
										{
											position124, tokenIndex124 := position, tokenIndex
											{
												position125, tokenIndex125 := position, tokenIndex
												if buffer[position] != rune('"') {
													goto l126
												}
												position++
												goto l125
											l126:
												position, tokenIndex = position125, tokenIndex125
												if buffer[position] != rune('\\') {
													goto l124
												}
												position++
											}
										l125:
											goto l120
										l124:
											position, tokenIndex = position124, tokenIndex124
										}
										if !matchDot() {
											goto l120
										}
									}
								l121:
									goto l119
								l120:
									position, tokenIndex = position120, tokenIndex120
								}
								add(rulePegText, position118)
							}
							if buffer[position] != rune('"') {
								goto l114
							}
							position++
							{
								add(ruleAction14, position)
							}
							add(ruledoubleQuotedNodeIdentifier, position117)
						}
					case '\'':
						{
							position128 := position
							position++
							{
								position129 := position
							l130:
								{
									position131, tokenIndex131 := position, tokenIndex
									{
										position132, tokenIndex132 := position, tokenIndex
										if buffer[position] != rune('\\') {
											goto l133
										}
										position++
										{
											switch buffer[position] {
											case 'u':
												if !_rules[rulehexDigits]() {
													goto l133
												}
											case 't':
												position++
											case 'r':
												position++
											case 'n':
												position++
											case 'f':
												position++
											case 'b':
												position++
											case '\\':
												position++
											case '/':
												position++
											default:
												if buffer[position] != rune('\'') {
													goto l133
												}
												position++
											}
										}

										goto l132
									l133:
										position, tokenIndex = position132, tokenIndex132
										{
											position135, tokenIndex135 := position, tokenIndex
											{
												position136, tokenIndex136 := position, tokenIndex
												if buffer[position] != rune('\'') {
													goto l137
												}
												position++
												goto l136
											l137:
												position, tokenIndex = position136, tokenIndex136
												if buffer[position] != rune('\\') {
													goto l135
												}
												position++
											}
										l136:
											goto l131
										l135:
											position, tokenIndex = position135, tokenIndex135
										}
										if !matchDot() {
											goto l131
										}
									}
								l132:
									goto l130
								l131:
									position, tokenIndex = position131, tokenIndex131
								}
								add(rulePegText, position129)
							}
							if buffer[position] != rune('\'') {
								goto l114
							}
							position++
							{
								add(ruleAction13, position)
							}
							add(rulesingleQuotedNodeIdentifier, position128)
						}
					default:
						if !_rules[rulewildcardIdentifier]() {
							goto l114
						}
					}
				}

				add(rulebracketNodeIdentifier, position115)
			}
			memoize(16, position114, tokenIndex114, true)
			return true
		l114:
			memoize(16, position114, tokenIndex114, false)
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 17 wildcardIdentifier <- <('*' Action12)> */
		func() bool {
			if memoized, ok := memoization[memoKey{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				if buffer[position] != rune('*') {
					goto l139
				}
				position++
				{
					add(ruleAction12, position)
				}
				add(rulewildcardIdentifier, position140)
			}
			memoize(17, position139, tokenIndex139, true)
			return true
		l139:
			memoize(17, position139, tokenIndex139, false)
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 18 singleQuotedNodeIdentifier <- <('\'' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('\'') '\''))) / (!('\'' / '\\') .))*> '\'' Action13)> */
		nil,
		/* 19 doubleQuotedNodeIdentifier <- <('"' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('"') '"'))) / (!('"' / '\\') .))*> '"' Action14)> */
		nil,
		/* 20 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			if memoized, ok := memoization[memoKey{20, position}]; ok {
				return memoizedResult(memoized)
			}
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if buffer[position] != rune('u') {
					goto l144
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l144
				}
				if !_rules[rulehexDigit]() {
					goto l144
				}
				if !_rules[rulehexDigit]() {
					goto l144
				}
				if !_rules[rulehexDigit]() {
					goto l144
				}
				add(rulehexDigits, position145)
			}
			memoize(20, position144, tokenIndex144, true)
			return true
		l144:
			memoize(20, position144, tokenIndex144, false)
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 21 hexDigit <- <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				{
					switch buffer[position] {
					case 'A', 'B', 'C', 'D', 'E', 'F':
						position++
					case 'a', 'b', 'c', 'd', 'e', 'f':
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l146
						}
						position++
					}
				}

				add(rulehexDigit, position147)
			}
			memoize(21, position146, tokenIndex146, true)
			return true
		l146:
			memoize(21, position146, tokenIndex146, false)
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 22 qualifier <- <((&('?') filter) | (&('(') script) | (&(' ' | '*' | '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':') union))> */
		nil,
		/* 23 union <- <(index (sep index Action15)* !sep)> */
		nil,
		/* 24 index <- <(((slice Action16) / (<indexNumber> Action17) / ('*' Action18)) Action19)> */
		func() bool {
			if memoized, ok := memoization[memoKey{24, position}]; ok {
				return memoizedResult(memoized)
			}
			position151, tokenIndex151 := position, tokenIndex
			{
				position152 := position
				{
					position153, tokenIndex153 := position, tokenIndex
					{
						position155 := position
						if !_rules[ruleanyIndex]() {
							goto l154
						}
						if !_rules[rulesepSlice]() {
							goto l154
						}
						if !_rules[ruleanyIndex]() {
							goto l154
						}
						{
							position156, tokenIndex156 := position, tokenIndex
							if !_rules[rulesepSlice]() {
								goto l157
							}
							if !_rules[ruleanyIndex]() {
								goto l157
							}
							goto l156
						l157:
							position, tokenIndex = position156, tokenIndex156
							if !_rules[rulespace]() {
								goto l154
							}
							{
								add(ruleAction20, position)
							}
						}
					l156:
						add(ruleslice, position155)
					}
					{
						add(ruleAction16, position)
					}
					goto l153
				l154:
					position, tokenIndex = position153, tokenIndex153
					{
						position161 := position
						if !_rules[ruleindexNumber]() {
							goto l160
						}
						add(rulePegText, position161)
					}
					{
						add(ruleAction17, position)
					}
					goto l153
				l160:
					position, tokenIndex = position153, tokenIndex153
					if buffer[position] != rune('*') {
						goto l151
					}
					position++
					{
						add(ruleAction18, position)
					}
				}
			l153:
				{
					add(ruleAction19, position)
				}
				add(ruleindex, position152)
			}
			memoize(24, position151, tokenIndex151, true)
			return true
		l151:
			memoize(24, position151, tokenIndex151, false)
			position, tokenIndex = position151, tokenIndex151
			return false
		},
		/* 25 slice <- <(anyIndex sepSlice anyIndex ((sepSlice anyIndex) / (space Action20)))> */
		nil,
		/* 26 anyIndex <- <(<indexNumber?> Action21)> */
		func() bool {
			if memoized, ok := memoization[memoKey{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				{
					position168 := position
					{
						position169, tokenIndex169 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l169
						}
						goto l170
					l169:
						position, tokenIndex = position169, tokenIndex169
					}
				l170:
					add(rulePegText, position168)
				}
				{
					add(ruleAction21, position)
				}
				add(ruleanyIndex, position167)
			}
			memoize(26, position166, tokenIndex166, true)
			return true
		},
		/* 27 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			if memoized, ok := memoization[memoKey{27, position}]; ok {
				return memoizedResult(memoized)
			}
			position172, tokenIndex172 := position, tokenIndex
			{
				position173 := position
				{
					position174, tokenIndex174 := position, tokenIndex
					{
						position176, tokenIndex176 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l177
						}
						position++
						goto l176
					l177:
						position, tokenIndex = position176, tokenIndex176
						if buffer[position] != rune('+') {
							goto l174
						}
						position++
					}
				l176:
					goto l175
				l174:
					position, tokenIndex = position174, tokenIndex174
				}
			l175:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l172
				}
				position++
			l178:
				{
					position179, tokenIndex179 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l179
					}
					position++
					goto l178
				l179:
					position, tokenIndex = position179, tokenIndex179
				}
				add(ruleindexNumber, position173)
			}
			memoize(27, position172, tokenIndex172, true)
			return true
		l172:
			memoize(27, position172, tokenIndex172, false)
			position, tokenIndex = position172, tokenIndex172
			return false
		},
		/* 28 sep <- <(space ',' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				if !_rules[rulespace]() {
					goto l180
				}
				if buffer[position] != rune(',') {
					goto l180
				}
				position++
				if !_rules[rulespace]() {
					goto l180
				}
				add(rulesep, position181)
			}
			memoize(28, position180, tokenIndex180, true)
			return true
		l180:
			memoize(28, position180, tokenIndex180, false)
			position, tokenIndex = position180, tokenIndex180
			return false
		},
		/* 29 sepSlice <- <(space ':' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position182, tokenIndex182 := position, tokenIndex
			{
				position183 := position
				if !_rules[rulespace]() {
					goto l182
				}
				if buffer[position] != rune(':') {
					goto l182
				}
				position++
				if !_rules[rulespace]() {
					goto l182
				}
				add(rulesepSlice, position183)
			}
			memoize(29, position182, tokenIndex182, true)
			return true
		l182:
			memoize(29, position182, tokenIndex182, false)
			position, tokenIndex = position182, tokenIndex182
			return false
		},
		/* 30 script <- <(scriptStart <command> scriptEnd Action22)> */
		nil,
		/* 31 command <- <(!scriptEnd .)+> */
		nil,
		/* 32 filter <- <(filterStart query filterEnd Action23)> */
		nil,
		/* 33 query <- <(andQuery (logicOr andQuery Action24)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				if !_rules[ruleandQuery]() {
					goto l187
				}
			l189:
				{
					position190, tokenIndex190 := position, tokenIndex
					{
						position191 := position
						if !_rules[rulespace]() {
							goto l190
						}
						if buffer[position] != rune('|') {
							goto l190
						}
						position++
						if buffer[position] != rune('|') {
							goto l190
						}
						position++
						if !_rules[rulespace]() {
							goto l190
						}
						add(rulelogicOr, position191)
					}
					if !_rules[ruleandQuery]() {
						goto l190
					}
					{
						add(ruleAction24, position)
					}
					goto l189
				l190:
					position, tokenIndex = position190, tokenIndex190
				}
				add(rulequery, position188)
			}
			memoize(33, position187, tokenIndex187, true)
			return true
		l187:
			memoize(33, position187, tokenIndex187, false)
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 34 andQuery <- <(basicQuery (logicAnd basicQuery Action25)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{34, position}]; ok {
				return memoizedResult(memoized)
			}
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				if !_rules[rulebasicQuery]() {
					goto l193
				}
			l195:
				{
					position196, tokenIndex196 := position, tokenIndex
					{
						position197 := position
						if !_rules[rulespace]() {
							goto l196
						}
						if buffer[position] != rune('&') {
							goto l196
						}
						position++
						if buffer[position] != rune('&') {
							goto l196
						}
						position++
						if !_rules[rulespace]() {
							goto l196
						}
						add(rulelogicAnd, position197)
					}
					if !_rules[rulebasicQuery]() {
						goto l196
					}
					{
						add(ruleAction25, position)
					}
					goto l195
				l196:
					position, tokenIndex = position196, tokenIndex196
				}
				add(ruleandQuery, position194)
			}
			memoize(34, position193, tokenIndex193, true)
			return true
		l193:
			memoize(34, position193, tokenIndex193, false)
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 35 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action26) / (<(logicNot? jsonpathFilter)> Action27))> */
		func() bool {
			if memoized, ok := memoization[memoKey{35, position}]; ok {
				return memoizedResult(memoized)
			}
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					{
						position203 := position
						if buffer[position] != rune('(') {
							goto l202
						}
						position++
						if !_rules[rulespace]() {
							goto l202
						}
						add(rulesubQueryStart, position203)
					}
					if !_rules[rulequery]() {
						goto l202
					}
					{
						position204 := position
						if !_rules[rulespace]() {
							goto l202
						}
						if buffer[position] != rune(')') {
							goto l202
						}
						position++
						add(rulesubQueryEnd, position204)
					}
					goto l201
				l202:
					position, tokenIndex = position201, tokenIndex201
					{
						position206 := position
						{
							position207 := position
							{
								position208, tokenIndex208 := position, tokenIndex
								if !_rules[ruleqParam]() {
									goto l209
								}
								if !_rules[rulespace]() {
									goto l209
								}
								{
									position210, tokenIndex210 := position, tokenIndex
									if buffer[position] != rune('=') {
										goto l211
									}
									position++
									if buffer[position] != rune('=') {
										goto l211
									}
									position++
									if !_rules[rulespace]() {
										goto l211
									}
									if !_rules[ruleqParam]() {
										goto l211
									}
									{
										add(ruleAction28, position)
									}
									goto l210
								l211:
									position, tokenIndex = position210, tokenIndex210
									if buffer[position] != rune('!') {
										goto l209
									}
									position++
									if buffer[position] != rune('=') {
										goto l209
									}
									position++
									if !_rules[rulespace]() {
										goto l209
									}
									if !_rules[ruleqParam]() {
										goto l209
									}
									{
										add(ruleAction29, position)
									}
								}
							l210:
								goto l208
							l209:
								position, tokenIndex = position208, tokenIndex208
								if !_rules[ruleqNumericParam]() {
									goto l214
								}
								if !_rules[rulespace]() {
									goto l214
								}
								{
									position215, tokenIndex215 := position, tokenIndex
									if buffer[position] != rune('<') {
										goto l216
									}
									position++
									if buffer[position] != rune('=') {
										goto l216
									}
									position++
									if !_rules[rulespace]() {
										goto l216
									}
									if !_rules[ruleqNumericParam]() {
										goto l216
									}
									{
										add(ruleAction30, position)
									}
									goto l215
								l216:
									position, tokenIndex = position215, tokenIndex215
									if buffer[position] != rune('<') {
										goto l218
									}
									position++
									if !_rules[rulespace]() {
										goto l218
									}
									if !_rules[ruleqNumericParam]() {
										goto l218
									}
									{
										add(ruleAction31, position)
									}
									goto l215
								l218:
									position, tokenIndex = position215, tokenIndex215
									if buffer[position] != rune('>') {
										goto l220
									}
									position++
									if buffer[position] != rune('=') {
										goto l220
									}
									position++
									if !_rules[rulespace]() {
										goto l220
									}
									if !_rules[ruleqNumericParam]() {
										goto l220
									}
									{
										add(ruleAction32, position)
									}
									goto l215
								l220:
									position, tokenIndex = position215, tokenIndex215
									if buffer[position] != rune('>') {
										goto l214
									}
									position++
									if !_rules[rulespace]() {
										goto l214
									}
									if !_rules[ruleqNumericParam]() {
										goto l214
									}
									{
										add(ruleAction33, position)
									}
								}
							l215:
								goto l208
							l214:
								position, tokenIndex = position208, tokenIndex208
								if !_rules[rulesingleJsonpathFilter]() {
									goto l205
								}
								if !_rules[rulespace]() {
									goto l205
								}
								if buffer[position] != rune('=') {
									goto l205
								}
								position++
								if buffer[position] != rune('~') {
									goto l205
								}
								position++
								if !_rules[rulespace]() {
									goto l205
								}
								if buffer[position] != rune('/') {
									goto l205
								}
								position++
								{
									position223 := position
									{
										position224 := position
									l225:
										{
											position226, tokenIndex226 := position, tokenIndex
											{
												position227, tokenIndex227 := position, tokenIndex
												if buffer[position] != rune('\\') {
													goto l228
												}
												position++
												{
													position229, tokenIndex229 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l230
													}
													position++
													goto l229
												l230:
													position, tokenIndex = position229, tokenIndex229
													if buffer[position] != rune('/') {
														goto l228
													}
													position++
												}
											l229:
												goto l227
											l228:
												position, tokenIndex = position227, tokenIndex227
												{
													position231, tokenIndex231 := position, tokenIndex
													if buffer[position] != rune('/') {
														goto l231
													}
													position++
													goto l226
												l231:
													position, tokenIndex = position231, tokenIndex231
												}
												if !matchDot() {
													goto l226
												}
											}
										l227:
											goto l225
										l226:
											position, tokenIndex = position226, tokenIndex226
										}
										add(ruleregex, position224)
									}
									add(rulePegText, position223)
								}
								if buffer[position] != rune('/') {
									goto l205
								}
								position++
								{
									add(ruleAction34, position)
								}
							}
						l208:
							add(rulecomparator, position207)
						}
						add(rulePegText, position206)
					}
					{
						add(ruleAction26, position)
					}
					goto l201
				l205:
					position, tokenIndex = position201, tokenIndex201
					{
						position234 := position
						{
							position235, tokenIndex235 := position, tokenIndex
							{
								position237 := position
								if buffer[position] != rune('!') {
									goto l235
								}
								position++
								if !_rules[rulespace]() {
									goto l235
								}
								add(rulelogicNot, position237)
							}
							goto l236
						l235:
							position, tokenIndex = position235, tokenIndex235
						}
					l236:
						if !_rules[rulejsonpathFilter]() {
							goto l199
						}
						add(rulePegText, position234)
					}
					{
						add(ruleAction27, position)
					}
				}
			l201:
				add(rulebasicQuery, position200)
			}
			memoize(35, position199, tokenIndex199, true)
			return true
		l199:
			memoize(35, position199, tokenIndex199, false)
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 36 logicOr <- <(space ('|' '|') space)> */
		nil,
		/* 37 logicAnd <- <(space ('&' '&') space)> */
		nil,
		/* 38 logicNot <- <('!' space)> */
		nil,
		/* 39 comparator <- <((qParam space (('=' '=' space qParam Action28) / ('!' '=' space qParam Action29))) / (qNumericParam space (('<' '=' space qNumericParam Action30) / ('<' space qNumericParam Action31) / ('>' '=' space qNumericParam Action32) / ('>' space qNumericParam Action33))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action34))> */
		nil,
		/* 40 qParam <- <((qLiteral Action35) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey{40, position}]; ok {
				return memoizedResult(memoized)
			}
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					{
						position247 := position
						{
							switch buffer[position] {
							case 'N', 'n':
								{
									position249 := position
									{
										position250, tokenIndex250 := position, tokenIndex
										if buffer[position] != rune('n') {
											goto l251
										}
										position++
										if buffer[position] != rune('u') {
											goto l251
										}
										position++
										if buffer[position] != rune('l') {
											goto l251
										}
										position++
										if buffer[position] != rune('l') {
											goto l251
										}
										position++
										goto l250
									l251:
										position, tokenIndex = position250, tokenIndex250
										if buffer[position] != rune('N') {
											goto l252
										}
										position++
										if buffer[position] != rune('u') {
											goto l252
										}
										position++
										if buffer[position] != rune('l') {
											goto l252
										}
										position++
										if buffer[position] != rune('l') {
											goto l252
										}
										position++
										goto l250
									l252:
										position, tokenIndex = position250, tokenIndex250
										if buffer[position] != rune('N') {
											goto l246
										}
										position++
										if buffer[position] != rune('U') {
											goto l246
										}
										position++
										if buffer[position] != rune('L') {
											goto l246
										}
										position++
										if buffer[position] != rune('L') {
											goto l246
										}
										position++
									}
								l250:
									{
										add(ruleAction45, position)
									}
									add(rulelNull, position249)
								}
							case '"', '\'':
								{
									position254 := position
									{
										position255, tokenIndex255 := position, tokenIndex
										if buffer[position] != rune('\'') {
											goto l256
										}
										position++
										{
											position257 := position
										l258:
											{
												position259, tokenIndex259 := position, tokenIndex
												{
													position260, tokenIndex260 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l261
													}
													position++
													{
														position262, tokenIndex262 := position, tokenIndex
														if buffer[position] != rune('\\') {
															goto l263
														}
														position++
														goto l262
													l263:
														position, tokenIndex = position262, tokenIndex262
														if buffer[position] != rune('\'') {
															goto l261
														}
														position++
													}
												l262:
													goto l260
												l261:
													position, tokenIndex = position260, tokenIndex260
													{
														position264, tokenIndex264 := position, tokenIndex
														if buffer[position] != rune('\'') {
															goto l264
														}
														position++
														goto l259
													l264:
														position, tokenIndex = position264, tokenIndex264
													}
													if !matchDot() {
														goto l259
													}
												}
											l260:
												goto l258
											l259:
												position, tokenIndex = position259, tokenIndex259
											}
											add(rulePegText, position257)
										}
										if buffer[position] != rune('\'') {
											goto l256
										}
										position++
										{
											add(ruleAction43, position)
										}
										goto l255
									l256:
										position, tokenIndex = position255, tokenIndex255
										if buffer[position] != rune('"') {
											goto l246
										}
										position++
										{
											position266 := position
										l267:
											{
												position268, tokenIndex268 := position, tokenIndex
												{
													position269, tokenIndex269 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l270
													}
													position++
													{
														position271, tokenIndex271 := position, tokenIndex
														if buffer[position] != rune('\\') {
															goto l272
														}
														position++
														goto l271
													l272:
														position, tokenIndex = position271, tokenIndex271
														if buffer[position] != rune('"') {
															goto l270
														}
														position++
													}
												l271:
													goto l269
												l270:
													position, tokenIndex = position269, tokenIndex269
													{
														position273, tokenIndex273 := position, tokenIndex
														if buffer[position] != rune('"') {
															goto l273
														}
														position++
														goto l268
													l273:
														position, tokenIndex = position273, tokenIndex273
													}
													if !matchDot() {
														goto l268
													}
												}
											l269:
												goto l267
											l268:
												position, tokenIndex = position268, tokenIndex268
											}
											add(rulePegText, position266)
										}
										if buffer[position] != rune('"') {
											goto l246
										}
										position++
										{
											add(ruleAction44, position)
										}
									}
								l255:
									add(rulelString, position254)
								}
							case 'F', 'T', 'f', 't':
								{
									position275 := position
									{
										position276, tokenIndex276 := position, tokenIndex
										{
											position278, tokenIndex278 := position, tokenIndex
											if buffer[position] != rune('t') {
												goto l279
											}
											position++
											if buffer[position] != rune('r') {
												goto l279
											}
											position++
											if buffer[position] != rune('u') {
												goto l279
											}
											position++
											if buffer[position] != rune('e') {
												goto l279
											}
											position++
											goto l278
										l279:
											position, tokenIndex = position278, tokenIndex278
											if buffer[position] != rune('T') {
												goto l280
											}
											position++
											if buffer[position] != rune('r') {
												goto l280
											}
											position++
											if buffer[position] != rune('u') {
												goto l280
											}
											position++
											if buffer[position] != rune('e') {
												goto l280
											}
											position++
											goto l278
										l280:
											position, tokenIndex = position278, tokenIndex278
											if buffer[position] != rune('T') {
												goto l277
											}
											position++
											if buffer[position] != rune('R') {
												goto l277
											}
											position++
											if buffer[position] != rune('U') {
												goto l277
											}
											position++
											if buffer[position] != rune('E') {
												goto l277
											}
											position++
										}
									l278:
										{
											add(ruleAction41, position)
										}
										goto l276
									l277:
										position, tokenIndex = position276, tokenIndex276
										{
											position282, tokenIndex282 := position, tokenIndex
											if buffer[position] != rune('f') {
												goto l283
											}
											position++
											if buffer[position] != rune('a') {
												goto l283
											}
											position++
											if buffer[position] != rune('l') {
												goto l283
											}
											position++
											if buffer[position] != rune('s') {
												goto l283
											}
											position++
											if buffer[position] != rune('e') {
												goto l283
											}
											position++
											goto l282
										l283:
											position, tokenIndex = position282, tokenIndex282
											if buffer[position] != rune('F') {
												goto l284
											}
											position++
											if buffer[position] != rune('a') {
												goto l284
											}
											position++
											if buffer[position] != rune('l') {
												goto l284
											}
											position++
											if buffer[position] != rune('s') {
												goto l284
											}
											position++
											if buffer[position] != rune('e') {
												goto l284
											}
											position++
											goto l282
										l284:
											position, tokenIndex = position282, tokenIndex282
											if buffer[position] != rune('F') {
												goto l246
											}
											position++
											if buffer[position] != rune('A') {
												goto l246
											}
											position++
											if buffer[position] != rune('L') {
												goto l246
											}
											position++
											if buffer[position] != rune('S') {
												goto l246
											}
											position++
											if buffer[position] != rune('E') {
												goto l246
											}
											position++
										}
									l282:
										{
											add(ruleAction42, position)
										}
									}
								l276:
									add(rulelBool, position275)
								}
							default:
								if !_rules[rulelNumber]() {
									goto l246
								}
							}
						}

						add(ruleqLiteral, position247)
					}
					{
						add(ruleAction35, position)
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[rulesingleJsonpathFilter]() {
						goto l243
					}
				}
			l245:
				add(ruleqParam, position244)
			}
			memoize(40, position243, tokenIndex243, true)
			return true
		l243:
			memoize(40, position243, tokenIndex243, false)
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 41 qNumericParam <- <((lNumber Action36) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey{41, position}]; ok {
				return memoizedResult(memoized)
			}
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				{
					position289, tokenIndex289 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l290
					}
					{
						add(ruleAction36, position)
					}
					goto l289
				l290:
					position, tokenIndex = position289, tokenIndex289
					if !_rules[rulesingleJsonpathFilter]() {
						goto l287
					}
				}
			l289:
				add(ruleqNumericParam, position288)
			}
			memoize(41, position287, tokenIndex287, true)
			return true
		l287:
			memoize(41, position287, tokenIndex287, false)
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 42 qLiteral <- <((&('N' | 'n') lNull) | (&('"' | '\'') lString) | (&('F' | 'T' | 'f' | 't') lBool) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') lNumber))> */
		nil,
		/* 43 singleJsonpathFilter <- <(<jsonpathFilter> Action37)> */
		func() bool {
			if memoized, ok := memoization[memoKey{43, position}]; ok {
				return memoizedResult(memoized)
			}
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				{
					position295 := position
					if !_rules[rulejsonpathFilter]() {
						goto l293
					}
					add(rulePegText, position295)
				}
				{
					add(ruleAction37, position)
				}
				add(rulesingleJsonpathFilter, position294)
			}
			memoize(43, position293, tokenIndex293, true)
			return true
		l293:
			memoize(43, position293, tokenIndex293, false)
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 44 jsonpathFilter <- <(Action38 jsonpathParameter Action39)> */
		func() bool {
			if memoized, ok := memoization[memoKey{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				{
					add(ruleAction38, position)
				}
				{
					position300 := position
					if !_rules[rulespace]() {
						goto l297
					}
					{
						position301 := position
						{
							position302, tokenIndex302 := position, tokenIndex
							if !_rules[rulerootIdentifier]() {
								goto l303
							}
							goto l302
						l303:
							position, tokenIndex = position302, tokenIndex302
							{
								position304 := position
								if buffer[position] != rune('@') {
									goto l297
								}
								position++
								{
									add(ruleAction9, position)
								}
								add(rulecurrentRootIdentifier, position304)
							}
						}
					l302:
						add(ruleparameterRootNode, position301)
					}
					if !_rules[rulecontinuedJsonpath]() {
						goto l297
					}
					add(rulejsonpathParameter, position300)
				}
				{
					add(ruleAction39, position)
				}
				add(rulejsonpathFilter, position298)
			}
			memoize(44, position297, tokenIndex297, true)
			return true
		l297:
			memoize(44, position297, tokenIndex297, false)
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 45 lNumber <- <(<(('-' / '+')? [0-9] ((&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('.') '.') | (&('+') '+') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action40)> */
		func() bool {
			if memoized, ok := memoization[memoKey{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position307, tokenIndex307 := position, tokenIndex
			{
				position308 := position
				{
					position309 := position
					{
						position310, tokenIndex310 := position, tokenIndex
						{
							position312, tokenIndex312 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l313
							}
							position++
							goto l312
						l313:
							position, tokenIndex = position312, tokenIndex312
							if buffer[position] != rune('+') {
								goto l310
							}
							position++
						}
					l312:
						goto l311
					l310:
						position, tokenIndex = position310, tokenIndex310
					}
				l311:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l307
					}
					position++
				l314:
					{
						position315, tokenIndex315 := position, tokenIndex
						{
							switch buffer[position] {
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								position++
							case '.':
								position++
							case '+':
								position++
							case '-':
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								position++
							default:
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l315
								}
								position++
							}
						}

						goto l314
					l315:
						position, tokenIndex = position315, tokenIndex315
					}
					add(rulePegText, position309)
				}
				{
					add(ruleAction40, position)
				}
				add(rulelNumber, position308)
			}
			memoize(45, position307, tokenIndex307, true)
			return true
		l307:
			memoize(45, position307, tokenIndex307, false)
			position, tokenIndex = position307, tokenIndex307
			return false
		},
		/* 46 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action41) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action42))> */
		nil,
		/* 47 lString <- <(('\'' <(('\\' ('\\' / '\'')) / (!'\'' .))*> '\'' Action43) / ('"' <(('\\' ('\\' / '"')) / (!'"' .))*> '"' Action44))> */
		nil,
		/* 48 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action45)> */
		nil,
		/* 49 regex <- <(('\\' ('\\' / '/')) / (!'/' .))*> */
		nil,
		/* 50 squareBracketStart <- <('[' space)> */
		nil,
		/* 51 squareBracketEnd <- <(space ']')> */
		nil,
		/* 52 scriptStart <- <('(' space)> */
		nil,
		/* 53 scriptEnd <- <(space ')')> */
		func() bool {
			if memoized, ok := memoization[memoKey{53, position}]; ok {
				return memoizedResult(memoized)
			}
			position325, tokenIndex325 := position, tokenIndex
			{
				position326 := position
				if !_rules[rulespace]() {
					goto l325
				}
				if buffer[position] != rune(')') {
					goto l325
				}
				position++
				add(rulescriptEnd, position326)
			}
			memoize(53, position325, tokenIndex325, true)
			return true
		l325:
			memoize(53, position325, tokenIndex325, false)
			position, tokenIndex = position325, tokenIndex325
			return false
		},
		/* 54 filterStart <- <('?' '(' space)> */
		nil,
		/* 55 filterEnd <- <(space ')')> */
		nil,
		/* 56 subQueryStart <- <('(' space)> */
		nil,
		/* 57 subQueryEnd <- <(space ')')> */
		nil,
		/* 58 space <- <' '*> */
		func() bool {
			if memoized, ok := memoization[memoKey{58, position}]; ok {
				return memoizedResult(memoized)
			}
			position331, tokenIndex331 := position, tokenIndex
			{
				position332 := position
			l333:
				{
					position334, tokenIndex334 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l334
					}
					position++
					goto l333
				l334:
					position, tokenIndex = position334, tokenIndex334
				}
				add(rulespace, position332)
			}
			memoize(58, position331, tokenIndex331, true)
			return true
		},
		/* 60 Action0 <- <{
		    p.root = p.deleteRootIdentifier(p.pop().(syntaxNode))
		    p.setConnectedText(p.root)
		}> */
		nil,
		nil,
		/* 62 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		nil,
		/* 63 Action2 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		nil,
		/* 64 Action3 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		nil,
		/* 65 Action4 <- <{
		    p.setLastNodeText(text)
		}> */
		nil,
		/* 66 Action5 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		nil,
		/* 67 Action6 <- <{
		    p.push(text)
		}> */
		nil,
		/* 68 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		nil,
		/* 69 Action8 <- <{
		    p.pushRootIdentifier()
		}> */
		nil,
		/* 70 Action9 <- <{
		    p.pushCurrentRootIdentifier()
		}> */
		nil,
		/* 71 Action10 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		nil,
		/* 72 Action11 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		nil,
		/* 73 Action12 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		nil,
		/* 74 Action13 <- <{
		    p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))
		}> */
		nil,
		/* 75 Action14 <- <{
		    p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))
		}> */
		nil,
		/* 76 Action15 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		nil,
		/* 77 Action16 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted {
		        step.number = 1
		    }

		    if step.number >= 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		nil,
		/* 78 Action17 <- <{
		    p.pushIndexSubscript(text)
		}> */
		nil,
		/* 79 Action18 <- <{
		    p.pushWildcardSubscript()
		}> */
		nil,
		/* 80 Action19 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		nil,
		/* 81 Action20 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		nil,
		/* 82 Action21 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		nil,
		/* 83 Action22 <- <{
		    p.pushScriptQualifier(text)
		}> */
		nil,
		/* 84 Action23 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		nil,
		/* 85 Action24 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		nil,
		/* 86 Action25 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		nil,
		/* 87 Action26 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		        _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
		        _, rightIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
		        if leftIsCurrentRoot && rightIsCurrentRoot {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		nil,
		/* 88 Action27 <- <{
		    _ = p.pop()
		    jsonpathFilter := p.pop().(syntaxQuery)

		    if text[0:1] == `!` {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		nil,
		/* 89 Action28 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		nil,
		/* 90 Action29 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		nil,
		/* 91 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		nil,
		/* 92 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		nil,
		/* 93 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		nil,
		/* 94 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		nil,
		/* 95 Action34 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		nil,
		/* 96 Action35 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 97 Action36 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 98 Action37 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		nil,
		/* 99 Action38 <- <{
		    p.saveParams()
		}> */
		nil,
		/* 100 Action39 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootIdentifier(node))
		        p.push(true)
		    case *syntaxCurrentRootIdentifier:
		        p.pushCompareParameterCurrentRoot(p.deleteRootIdentifier(node))
		        p.push(false)
		    }
		}> */
		nil,
		/* 101 Action40 <- <{
		    p.push(p.toFloat(text))
		}> */
		nil,
		/* 102 Action41 <- <{
		    p.push(true)
		}> */
		nil,
		/* 103 Action42 <- <{
		    p.push(false)
		}> */
		nil,
		/* 104 Action43 <- <{
		    p.push(p.unescape(text))
		}> */
		nil,
		/* 105 Action44 <- <{
		    p.push(p.unescape(text))
		}> */
		nil,
		/* 106 Action45 <- <{
		    p.push(nil)
		}> */
		nil,
	}
	p.rules = _rules
	return nil
}
