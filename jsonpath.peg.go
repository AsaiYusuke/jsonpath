package jsonpath

// Code generated by C:\Users\prome\go\bin\peg.exe jsonpath.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpath
	rulerootNode
	rulechildNode
	rulefunction
	rulefunctionName
	rulebracketNode
	rulerootIdentifier
	rulecurrentRootIdentifier
	ruledotChildIdentifier
	rulebracketChildIdentifier
	rulebracketNodeIdentifiers
	rulebracketNodeIdentifier
	rulesingleQuotedNodeIdentifier
	ruledoubleQuotedNodeIdentifier
	rulesepBracketIdentifier
	rulequalifier
	ruleunion
	ruleindex
	ruleslice
	ruleanyIndex
	ruleindexNumber
	rulesepUnion
	rulesepSlice
	rulescript
	rulecommand
	rulefilter
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptStart
	rulescriptEnd
	rulefilterStart
	rulefilterEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpath",
	"rootNode",
	"childNode",
	"function",
	"functionName",
	"bracketNode",
	"rootIdentifier",
	"currentRootIdentifier",
	"dotChildIdentifier",
	"bracketChildIdentifier",
	"bracketNodeIdentifiers",
	"bracketNodeIdentifier",
	"singleQuotedNodeIdentifier",
	"doubleQuotedNodeIdentifier",
	"sepBracketIdentifier",
	"qualifier",
	"union",
	"index",
	"slice",
	"anyIndex",
	"indexNumber",
	"sepUnion",
	"sepSlice",
	"script",
	"command",
	"filter",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptStart",
	"scriptEnd",
	"filterStart",
	"filterEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer string
	buffer []rune
	rules  [106]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.pop().(syntaxNode)

		case ruleAction1:

			p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)

		case ruleAction2:

			p.saveParams()

		case ruleAction3:

			p.setNodeChain()
			p.updateRootValueGroup()
			p.loadParams()

		case ruleAction4:

			if len(p.paramsList) == 0 {
				p.syntaxErr(begin, msgErrorInvalidSyntaxUseBeginAtsign, buffer)
			}

		case ruleAction5:

			if len(p.paramsList) != 0 {
				p.syntaxErr(begin, msgErrorInvalidSyntaxOmitDollar, buffer)
			}

		case ruleAction6:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.pushFunction(text, p.pop().(string))

		case ruleAction9:

			p.push(text)

		case ruleAction10:

			p.setLastNodeText(text)

		case ruleAction11:

			p.pushRootIdentifier()

		case ruleAction12:

			p.pushCurrentRootIdentifier()

		case ruleAction13:

			unescapedText := p.unescape(text)
			if unescapedText == `*` {
				p.pushChildWildcardIdentifier(unescapedText)
			} else {
				p.pushChildSingleIdentifier(unescapedText)
			}

		case ruleAction14:

			identifier := p.pop().([]string)
			if len(identifier) > 1 {
				p.pushChildMultiIdentifier(identifier)
			} else {
				p.pushChildSingleIdentifier(identifier[0])
			}

		case ruleAction15:

			identifier2 := p.pop().([]string)
			identifier1 := p.pop().([]string)
			p.push(append(identifier1, identifier2...))

		case ruleAction16:

			p.push([]string{p.pop().(string)})

		case ruleAction17:

			p.push(p.unescape(text))

		case ruleAction18:
			// '
			p.push(p.unescape(text))

		case ruleAction19:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction20:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted || step.number == 0 {
				step.number = 1
			}

			if step.number > 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction21:

			p.pushIndexSubscript(text)

		case ruleAction22:

			p.pushWildcardSubscript()

		case ruleAction23:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction24:

			p.pushIndexSubscript(`1`)

		case ruleAction25:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction26:

			p.pushScriptQualifier(text)

		case ruleAction27:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction28:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction29:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction30:

			if !p.hasErr() {
				query := p.pop().(syntaxQuery)
				p.push(query)

				if logicalNot, ok := query.(*syntaxLogicalNot); ok {
					query = (*logicalNot).query
				}
				if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
					_, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
					_, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
					if leftIsCurrentRoot && rigthIsCurrentRoot {
						p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
					}
				}
			}

		case ruleAction31:

			p.push(len(text) > 0 && text[0:1] == `!`)

		case ruleAction32:

			_ = p.pop().(bool)
			jsonpathFilter := p.pop().(syntaxQuery)
			isLogicalNot := p.pop().(bool)
			if isLogicalNot {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction34:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction35:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction36:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction37:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction38:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction39:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction40:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction41:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction42:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if !p.hasErr() && param.isValueGroupParameter() {
				p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction43:

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootIdentifier:
				p.pushCompareParameterRoot(node)
				p.push(true)
			case *syntaxCurrentRootIdentifier:
				p.pushCompareParameterCurrentRoot(node)
				p.push(false)
			default:
				p.push(&syntaxQueryParamRoot{})
				p.push(true)
			}

		case ruleAction44:

			p.push(p.toFloat(text))

		case ruleAction45:

			p.push(true)

		case ruleAction46:

			p.push(false)

		case ruleAction47:

			p.push(p.unescape(text))

		case ruleAction48:
			// '
			p.push(p.unescape(text))

		case ruleAction49:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <((jsonpath END Action0) / (jsonpath? <.*> END Action1))> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[rulejsonpath]() {
						goto l3
					}
					if !_rules[ruleEND]() {
						goto l3
					}
					if !_rules[ruleAction0]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpath]() {
							goto l4
						}
						goto l5
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
				l5:
					{
						position6 := position
					l7:
						{
							position8, tokenIndex8 := position, tokenIndex
							if !matchDot() {
								goto l8
							}
							goto l7
						l8:
							position, tokenIndex = position8, tokenIndex8
						}
						add(rulePegText, position6)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					if !_rules[ruleAction1]() {
						goto l0
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position11, tokenIndex11 := position, tokenIndex
					if !matchDot() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position11, tokenIndex11
				}
				add(ruleEND, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 2 jsonpath <- <(space Action2 rootNode childNode* function* space Action3)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[rulespace]() {
					goto l12
				}
				if !_rules[ruleAction2]() {
					goto l12
				}
				if !_rules[rulerootNode]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[rulechildNode]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
			l16:
				{
					position17, tokenIndex17 := position, tokenIndex
					if !_rules[rulefunction]() {
						goto l17
					}
					goto l16
				l17:
					position, tokenIndex = position17, tokenIndex17
				}
				if !_rules[rulespace]() {
					goto l12
				}
				if !_rules[ruleAction3]() {
					goto l12
				}
				add(rulejsonpath, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 rootNode <- <(rootIdentifier / (<currentRootIdentifier> Action4) / (<(bracketNode / dotChildIdentifier)> Action5))> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				{
					position20, tokenIndex20 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position20, tokenIndex20
					{
						position23 := position
						if !_rules[rulecurrentRootIdentifier]() {
							goto l22
						}
						add(rulePegText, position23)
					}
					if !_rules[ruleAction4]() {
						goto l22
					}
					goto l20
				l22:
					position, tokenIndex = position20, tokenIndex20
					{
						position24 := position
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulebracketNode]() {
								goto l26
							}
							goto l25
						l26:
							position, tokenIndex = position25, tokenIndex25
							if !_rules[ruledotChildIdentifier]() {
								goto l18
							}
						}
					l25:
						add(rulePegText, position24)
					}
					if !_rules[ruleAction5]() {
						goto l18
					}
				}
			l20:
				add(rulerootNode, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 4 childNode <- <(('.' '.' (bracketNode / dotChildIdentifier) Action6) / (<('.' dotChildIdentifier)> Action7) / bracketNode)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				{
					position29, tokenIndex29 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l30
					}
					position++
					if buffer[position] != rune('.') {
						goto l30
					}
					position++
					{
						position31, tokenIndex31 := position, tokenIndex
						if !_rules[rulebracketNode]() {
							goto l32
						}
						goto l31
					l32:
						position, tokenIndex = position31, tokenIndex31
						if !_rules[ruledotChildIdentifier]() {
							goto l30
						}
					}
				l31:
					if !_rules[ruleAction6]() {
						goto l30
					}
					goto l29
				l30:
					position, tokenIndex = position29, tokenIndex29
					{
						position34 := position
						if buffer[position] != rune('.') {
							goto l33
						}
						position++
						if !_rules[ruledotChildIdentifier]() {
							goto l33
						}
						add(rulePegText, position34)
					}
					if !_rules[ruleAction7]() {
						goto l33
					}
					goto l29
				l33:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[rulebracketNode]() {
						goto l27
					}
				}
			l29:
				add(rulechildNode, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 5 function <- <(<('.' functionName ('(' ')'))> Action8)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37 := position
					if buffer[position] != rune('.') {
						goto l35
					}
					position++
					if !_rules[rulefunctionName]() {
						goto l35
					}
					if buffer[position] != rune('(') {
						goto l35
					}
					position++
					if buffer[position] != rune(')') {
						goto l35
					}
					position++
					add(rulePegText, position37)
				}
				if !_rules[ruleAction8]() {
					goto l35
				}
				add(rulefunction, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 6 functionName <- <(<('-' / '_' / [a-z] / [A-Z])+> Action9)> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				{
					position40 := position
					{
						position43, tokenIndex43 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l44
						}
						position++
						goto l43
					l44:
						position, tokenIndex = position43, tokenIndex43
						if buffer[position] != rune('_') {
							goto l45
						}
						position++
						goto l43
					l45:
						position, tokenIndex = position43, tokenIndex43
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l46
						}
						position++
						goto l43
					l46:
						position, tokenIndex = position43, tokenIndex43
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l38
						}
						position++
					}
				l43:
				l41:
					{
						position42, tokenIndex42 := position, tokenIndex
						{
							position47, tokenIndex47 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l48
							}
							position++
							goto l47
						l48:
							position, tokenIndex = position47, tokenIndex47
							if buffer[position] != rune('_') {
								goto l49
							}
							position++
							goto l47
						l49:
							position, tokenIndex = position47, tokenIndex47
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l50
							}
							position++
							goto l47
						l50:
							position, tokenIndex = position47, tokenIndex47
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l42
							}
							position++
						}
					l47:
						goto l41
					l42:
						position, tokenIndex = position42, tokenIndex42
					}
					add(rulePegText, position40)
				}
				if !_rules[ruleAction9]() {
					goto l38
				}
				add(rulefunctionName, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 7 bracketNode <- <(<(squareBracketStart (bracketChildIdentifier / qualifier) squareBracketEnd)> Action10)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				{
					position53 := position
					if !_rules[rulesquareBracketStart]() {
						goto l51
					}
					{
						position54, tokenIndex54 := position, tokenIndex
						if !_rules[rulebracketChildIdentifier]() {
							goto l55
						}
						goto l54
					l55:
						position, tokenIndex = position54, tokenIndex54
						if !_rules[rulequalifier]() {
							goto l51
						}
					}
				l54:
					if !_rules[rulesquareBracketEnd]() {
						goto l51
					}
					add(rulePegText, position53)
				}
				if !_rules[ruleAction10]() {
					goto l51
				}
				add(rulebracketNode, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 8 rootIdentifier <- <('$' Action11)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if buffer[position] != rune('$') {
					goto l56
				}
				position++
				if !_rules[ruleAction11]() {
					goto l56
				}
				add(rulerootIdentifier, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 9 currentRootIdentifier <- <('@' Action12)> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				if buffer[position] != rune('@') {
					goto l58
				}
				position++
				if !_rules[ruleAction12]() {
					goto l58
				}
				add(rulecurrentRootIdentifier, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 10 dotChildIdentifier <- <(<(('\\' '\\') / ('\\' ('.' / '[' / '(' / ')' / '=' / '!' / '>' / '<' / '\t' / '\r' / '\n' / ' ')) / (!('\\' / '.' / '[' / '(' / ')' / '=' / '!' / '>' / '<' / '\t' / '\r' / '\n' / ' ') .))+> !('(' ')') Action13)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				{
					position62 := position
					{
						position65, tokenIndex65 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l66
						}
						position++
						if buffer[position] != rune('\\') {
							goto l66
						}
						position++
						goto l65
					l66:
						position, tokenIndex = position65, tokenIndex65
						if buffer[position] != rune('\\') {
							goto l67
						}
						position++
						{
							position68, tokenIndex68 := position, tokenIndex
							if buffer[position] != rune('.') {
								goto l69
							}
							position++
							goto l68
						l69:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('[') {
								goto l70
							}
							position++
							goto l68
						l70:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('(') {
								goto l71
							}
							position++
							goto l68
						l71:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune(')') {
								goto l72
							}
							position++
							goto l68
						l72:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('=') {
								goto l73
							}
							position++
							goto l68
						l73:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('!') {
								goto l74
							}
							position++
							goto l68
						l74:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('>') {
								goto l75
							}
							position++
							goto l68
						l75:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('<') {
								goto l76
							}
							position++
							goto l68
						l76:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('\t') {
								goto l77
							}
							position++
							goto l68
						l77:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('\r') {
								goto l78
							}
							position++
							goto l68
						l78:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune('\n') {
								goto l79
							}
							position++
							goto l68
						l79:
							position, tokenIndex = position68, tokenIndex68
							if buffer[position] != rune(' ') {
								goto l67
							}
							position++
						}
					l68:
						goto l65
					l67:
						position, tokenIndex = position65, tokenIndex65
						{
							position80, tokenIndex80 := position, tokenIndex
							{
								position81, tokenIndex81 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l82
								}
								position++
								goto l81
							l82:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('.') {
									goto l83
								}
								position++
								goto l81
							l83:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('[') {
									goto l84
								}
								position++
								goto l81
							l84:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('(') {
									goto l85
								}
								position++
								goto l81
							l85:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune(')') {
									goto l86
								}
								position++
								goto l81
							l86:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('=') {
									goto l87
								}
								position++
								goto l81
							l87:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('!') {
									goto l88
								}
								position++
								goto l81
							l88:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('>') {
									goto l89
								}
								position++
								goto l81
							l89:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('<') {
									goto l90
								}
								position++
								goto l81
							l90:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('\t') {
									goto l91
								}
								position++
								goto l81
							l91:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('\r') {
									goto l92
								}
								position++
								goto l81
							l92:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune('\n') {
									goto l93
								}
								position++
								goto l81
							l93:
								position, tokenIndex = position81, tokenIndex81
								if buffer[position] != rune(' ') {
									goto l80
								}
								position++
							}
						l81:
							goto l60
						l80:
							position, tokenIndex = position80, tokenIndex80
						}
						if !matchDot() {
							goto l60
						}
					}
				l65:
				l63:
					{
						position64, tokenIndex64 := position, tokenIndex
						{
							position94, tokenIndex94 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l95
							}
							position++
							if buffer[position] != rune('\\') {
								goto l95
							}
							position++
							goto l94
						l95:
							position, tokenIndex = position94, tokenIndex94
							if buffer[position] != rune('\\') {
								goto l96
							}
							position++
							{
								position97, tokenIndex97 := position, tokenIndex
								if buffer[position] != rune('.') {
									goto l98
								}
								position++
								goto l97
							l98:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('[') {
									goto l99
								}
								position++
								goto l97
							l99:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('(') {
									goto l100
								}
								position++
								goto l97
							l100:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune(')') {
									goto l101
								}
								position++
								goto l97
							l101:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('=') {
									goto l102
								}
								position++
								goto l97
							l102:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('!') {
									goto l103
								}
								position++
								goto l97
							l103:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('>') {
									goto l104
								}
								position++
								goto l97
							l104:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('<') {
									goto l105
								}
								position++
								goto l97
							l105:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('\t') {
									goto l106
								}
								position++
								goto l97
							l106:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('\r') {
									goto l107
								}
								position++
								goto l97
							l107:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune('\n') {
									goto l108
								}
								position++
								goto l97
							l108:
								position, tokenIndex = position97, tokenIndex97
								if buffer[position] != rune(' ') {
									goto l96
								}
								position++
							}
						l97:
							goto l94
						l96:
							position, tokenIndex = position94, tokenIndex94
							{
								position109, tokenIndex109 := position, tokenIndex
								{
									position110, tokenIndex110 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l111
									}
									position++
									goto l110
								l111:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('.') {
										goto l112
									}
									position++
									goto l110
								l112:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('[') {
										goto l113
									}
									position++
									goto l110
								l113:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('(') {
										goto l114
									}
									position++
									goto l110
								l114:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune(')') {
										goto l115
									}
									position++
									goto l110
								l115:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('=') {
										goto l116
									}
									position++
									goto l110
								l116:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('!') {
										goto l117
									}
									position++
									goto l110
								l117:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('>') {
										goto l118
									}
									position++
									goto l110
								l118:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('<') {
										goto l119
									}
									position++
									goto l110
								l119:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('\t') {
										goto l120
									}
									position++
									goto l110
								l120:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('\r') {
										goto l121
									}
									position++
									goto l110
								l121:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune('\n') {
										goto l122
									}
									position++
									goto l110
								l122:
									position, tokenIndex = position110, tokenIndex110
									if buffer[position] != rune(' ') {
										goto l109
									}
									position++
								}
							l110:
								goto l64
							l109:
								position, tokenIndex = position109, tokenIndex109
							}
							if !matchDot() {
								goto l64
							}
						}
					l94:
						goto l63
					l64:
						position, tokenIndex = position64, tokenIndex64
					}
					add(rulePegText, position62)
				}
				{
					position123, tokenIndex123 := position, tokenIndex
					if buffer[position] != rune('(') {
						goto l123
					}
					position++
					if buffer[position] != rune(')') {
						goto l123
					}
					position++
					goto l60
				l123:
					position, tokenIndex = position123, tokenIndex123
				}
				if !_rules[ruleAction13]() {
					goto l60
				}
				add(ruledotChildIdentifier, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 11 bracketChildIdentifier <- <(bracketNodeIdentifiers Action14)> */
		func() bool {
			position124, tokenIndex124 := position, tokenIndex
			{
				position125 := position
				if !_rules[rulebracketNodeIdentifiers]() {
					goto l124
				}
				if !_rules[ruleAction14]() {
					goto l124
				}
				add(rulebracketChildIdentifier, position125)
			}
			return true
		l124:
			position, tokenIndex = position124, tokenIndex124
			return false
		},
		/* 12 bracketNodeIdentifiers <- <(bracketNodeIdentifier (sepBracketIdentifier bracketNodeIdentifier Action15)*)> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if !_rules[rulebracketNodeIdentifier]() {
					goto l126
				}
			l128:
				{
					position129, tokenIndex129 := position, tokenIndex
					if !_rules[rulesepBracketIdentifier]() {
						goto l129
					}
					if !_rules[rulebracketNodeIdentifier]() {
						goto l129
					}
					if !_rules[ruleAction15]() {
						goto l129
					}
					goto l128
				l129:
					position, tokenIndex = position129, tokenIndex129
				}
				add(rulebracketNodeIdentifiers, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 13 bracketNodeIdentifier <- <((singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier) Action16)> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				{
					position132, tokenIndex132 := position, tokenIndex
					if !_rules[rulesingleQuotedNodeIdentifier]() {
						goto l133
					}
					goto l132
				l133:
					position, tokenIndex = position132, tokenIndex132
					if !_rules[ruledoubleQuotedNodeIdentifier]() {
						goto l130
					}
				}
			l132:
				if !_rules[ruleAction16]() {
					goto l130
				}
				add(rulebracketNodeIdentifier, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 14 singleQuotedNodeIdentifier <- <('\'' <(('\\' '\\') / ('\\' '\'') / (!('\\' / '\'') .))*> '\'' Action17)> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if buffer[position] != rune('\'') {
					goto l134
				}
				position++
				{
					position136 := position
				l137:
					{
						position138, tokenIndex138 := position, tokenIndex
						{
							position139, tokenIndex139 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l140
							}
							position++
							if buffer[position] != rune('\\') {
								goto l140
							}
							position++
							goto l139
						l140:
							position, tokenIndex = position139, tokenIndex139
							if buffer[position] != rune('\\') {
								goto l141
							}
							position++
							if buffer[position] != rune('\'') {
								goto l141
							}
							position++
							goto l139
						l141:
							position, tokenIndex = position139, tokenIndex139
							{
								position142, tokenIndex142 := position, tokenIndex
								{
									position143, tokenIndex143 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l144
									}
									position++
									goto l143
								l144:
									position, tokenIndex = position143, tokenIndex143
									if buffer[position] != rune('\'') {
										goto l142
									}
									position++
								}
							l143:
								goto l138
							l142:
								position, tokenIndex = position142, tokenIndex142
							}
							if !matchDot() {
								goto l138
							}
						}
					l139:
						goto l137
					l138:
						position, tokenIndex = position138, tokenIndex138
					}
					add(rulePegText, position136)
				}
				if buffer[position] != rune('\'') {
					goto l134
				}
				position++
				if !_rules[ruleAction17]() {
					goto l134
				}
				add(rulesingleQuotedNodeIdentifier, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 15 doubleQuotedNodeIdentifier <- <('"' <(('\\' '\\') / ('\\' '"') / (!('\\' / '"') .))*> '"' Action18)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune('"') {
					goto l145
				}
				position++
				{
					position147 := position
				l148:
					{
						position149, tokenIndex149 := position, tokenIndex
						{
							position150, tokenIndex150 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l151
							}
							position++
							if buffer[position] != rune('\\') {
								goto l151
							}
							position++
							goto l150
						l151:
							position, tokenIndex = position150, tokenIndex150
							if buffer[position] != rune('\\') {
								goto l152
							}
							position++
							if buffer[position] != rune('"') {
								goto l152
							}
							position++
							goto l150
						l152:
							position, tokenIndex = position150, tokenIndex150
							{
								position153, tokenIndex153 := position, tokenIndex
								{
									position154, tokenIndex154 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l155
									}
									position++
									goto l154
								l155:
									position, tokenIndex = position154, tokenIndex154
									if buffer[position] != rune('"') {
										goto l153
									}
									position++
								}
							l154:
								goto l149
							l153:
								position, tokenIndex = position153, tokenIndex153
							}
							if !matchDot() {
								goto l149
							}
						}
					l150:
						goto l148
					l149:
						position, tokenIndex = position149, tokenIndex149
					}
					add(rulePegText, position147)
				}
				if buffer[position] != rune('"') {
					goto l145
				}
				position++
				if !_rules[ruleAction18]() {
					goto l145
				}
				add(ruledoubleQuotedNodeIdentifier, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 16 sepBracketIdentifier <- <(space ',' space)> */
		func() bool {
			position156, tokenIndex156 := position, tokenIndex
			{
				position157 := position
				if !_rules[rulespace]() {
					goto l156
				}
				if buffer[position] != rune(',') {
					goto l156
				}
				position++
				if !_rules[rulespace]() {
					goto l156
				}
				add(rulesepBracketIdentifier, position157)
			}
			return true
		l156:
			position, tokenIndex = position156, tokenIndex156
			return false
		},
		/* 17 qualifier <- <(union / script / filter)> */
		func() bool {
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				{
					position160, tokenIndex160 := position, tokenIndex
					if !_rules[ruleunion]() {
						goto l161
					}
					goto l160
				l161:
					position, tokenIndex = position160, tokenIndex160
					if !_rules[rulescript]() {
						goto l162
					}
					goto l160
				l162:
					position, tokenIndex = position160, tokenIndex160
					if !_rules[rulefilter]() {
						goto l158
					}
				}
			l160:
				add(rulequalifier, position159)
			}
			return true
		l158:
			position, tokenIndex = position158, tokenIndex158
			return false
		},
		/* 18 union <- <(index (sepUnion index Action19)*)> */
		func() bool {
			position163, tokenIndex163 := position, tokenIndex
			{
				position164 := position
				if !_rules[ruleindex]() {
					goto l163
				}
			l165:
				{
					position166, tokenIndex166 := position, tokenIndex
					if !_rules[rulesepUnion]() {
						goto l166
					}
					if !_rules[ruleindex]() {
						goto l166
					}
					if !_rules[ruleAction19]() {
						goto l166
					}
					goto l165
				l166:
					position, tokenIndex = position166, tokenIndex166
				}
				add(ruleunion, position164)
			}
			return true
		l163:
			position, tokenIndex = position163, tokenIndex163
			return false
		},
		/* 19 index <- <(((slice Action20) / (<indexNumber> Action21) / ('*' Action22)) Action23)> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				{
					position169, tokenIndex169 := position, tokenIndex
					if !_rules[ruleslice]() {
						goto l170
					}
					if !_rules[ruleAction20]() {
						goto l170
					}
					goto l169
				l170:
					position, tokenIndex = position169, tokenIndex169
					{
						position172 := position
						if !_rules[ruleindexNumber]() {
							goto l171
						}
						add(rulePegText, position172)
					}
					if !_rules[ruleAction21]() {
						goto l171
					}
					goto l169
				l171:
					position, tokenIndex = position169, tokenIndex169
					if buffer[position] != rune('*') {
						goto l167
					}
					position++
					if !_rules[ruleAction22]() {
						goto l167
					}
				}
			l169:
				if !_rules[ruleAction23]() {
					goto l167
				}
				add(ruleindex, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 20 slice <- <(anyIndex sepSlice anyIndex ((sepSlice anyIndex) / (space Action24)))> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if !_rules[ruleanyIndex]() {
					goto l173
				}
				if !_rules[rulesepSlice]() {
					goto l173
				}
				if !_rules[ruleanyIndex]() {
					goto l173
				}
				{
					position175, tokenIndex175 := position, tokenIndex
					if !_rules[rulesepSlice]() {
						goto l176
					}
					if !_rules[ruleanyIndex]() {
						goto l176
					}
					goto l175
				l176:
					position, tokenIndex = position175, tokenIndex175
					if !_rules[rulespace]() {
						goto l173
					}
					if !_rules[ruleAction24]() {
						goto l173
					}
				}
			l175:
				add(ruleslice, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 21 anyIndex <- <(<indexNumber?> Action25)> */
		func() bool {
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				{
					position179 := position
					{
						position180, tokenIndex180 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l180
						}
						goto l181
					l180:
						position, tokenIndex = position180, tokenIndex180
					}
				l181:
					add(rulePegText, position179)
				}
				if !_rules[ruleAction25]() {
					goto l177
				}
				add(ruleanyIndex, position178)
			}
			return true
		l177:
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 22 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			position182, tokenIndex182 := position, tokenIndex
			{
				position183 := position
				{
					position184, tokenIndex184 := position, tokenIndex
					{
						position186, tokenIndex186 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l187
						}
						position++
						goto l186
					l187:
						position, tokenIndex = position186, tokenIndex186
						if buffer[position] != rune('+') {
							goto l184
						}
						position++
					}
				l186:
					goto l185
				l184:
					position, tokenIndex = position184, tokenIndex184
				}
			l185:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l182
				}
				position++
			l188:
				{
					position189, tokenIndex189 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l189
					}
					position++
					goto l188
				l189:
					position, tokenIndex = position189, tokenIndex189
				}
				add(ruleindexNumber, position183)
			}
			return true
		l182:
			position, tokenIndex = position182, tokenIndex182
			return false
		},
		/* 23 sepUnion <- <(space ',' space)> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				if !_rules[rulespace]() {
					goto l190
				}
				if buffer[position] != rune(',') {
					goto l190
				}
				position++
				if !_rules[rulespace]() {
					goto l190
				}
				add(rulesepUnion, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 24 sepSlice <- <(space ':' space)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				if !_rules[rulespace]() {
					goto l192
				}
				if buffer[position] != rune(':') {
					goto l192
				}
				position++
				if !_rules[rulespace]() {
					goto l192
				}
				add(rulesepSlice, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 25 script <- <(scriptStart <command> scriptEnd Action26)> */
		func() bool {
			position194, tokenIndex194 := position, tokenIndex
			{
				position195 := position
				if !_rules[rulescriptStart]() {
					goto l194
				}
				{
					position196 := position
					if !_rules[rulecommand]() {
						goto l194
					}
					add(rulePegText, position196)
				}
				if !_rules[rulescriptEnd]() {
					goto l194
				}
				if !_rules[ruleAction26]() {
					goto l194
				}
				add(rulescript, position195)
			}
			return true
		l194:
			position, tokenIndex = position194, tokenIndex194
			return false
		},
		/* 26 command <- <(!')' .)+> */
		func() bool {
			position197, tokenIndex197 := position, tokenIndex
			{
				position198 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if buffer[position] != rune(')') {
						goto l201
					}
					position++
					goto l197
				l201:
					position, tokenIndex = position201, tokenIndex201
				}
				if !matchDot() {
					goto l197
				}
			l199:
				{
					position200, tokenIndex200 := position, tokenIndex
					{
						position202, tokenIndex202 := position, tokenIndex
						if buffer[position] != rune(')') {
							goto l202
						}
						position++
						goto l200
					l202:
						position, tokenIndex = position202, tokenIndex202
					}
					if !matchDot() {
						goto l200
					}
					goto l199
				l200:
					position, tokenIndex = position200, tokenIndex200
				}
				add(rulecommand, position198)
			}
			return true
		l197:
			position, tokenIndex = position197, tokenIndex197
			return false
		},
		/* 27 filter <- <(filterStart query filterEnd Action27)> */
		func() bool {
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				if !_rules[rulefilterStart]() {
					goto l203
				}
				if !_rules[rulequery]() {
					goto l203
				}
				if !_rules[rulefilterEnd]() {
					goto l203
				}
				if !_rules[ruleAction27]() {
					goto l203
				}
				add(rulefilter, position204)
			}
			return true
		l203:
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 28 query <- <(andQuery (logicOr andQuery Action28)*)> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				if !_rules[ruleandQuery]() {
					goto l205
				}
			l207:
				{
					position208, tokenIndex208 := position, tokenIndex
					if !_rules[rulelogicOr]() {
						goto l208
					}
					if !_rules[ruleandQuery]() {
						goto l208
					}
					if !_rules[ruleAction28]() {
						goto l208
					}
					goto l207
				l208:
					position, tokenIndex = position208, tokenIndex208
				}
				add(rulequery, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 29 andQuery <- <(basicQuery (logicAnd basicQuery Action29)*)> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if !_rules[rulebasicQuery]() {
					goto l209
				}
			l211:
				{
					position212, tokenIndex212 := position, tokenIndex
					if !_rules[rulelogicAnd]() {
						goto l212
					}
					if !_rules[rulebasicQuery]() {
						goto l212
					}
					if !_rules[ruleAction29]() {
						goto l212
					}
					goto l211
				l212:
					position, tokenIndex = position212, tokenIndex212
				}
				add(ruleandQuery, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 30 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action30) / (<logicNot?> Action31 jsonpathFilter Action32))> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				{
					position215, tokenIndex215 := position, tokenIndex
					if !_rules[rulesubQueryStart]() {
						goto l216
					}
					if !_rules[rulequery]() {
						goto l216
					}
					if !_rules[rulesubQueryEnd]() {
						goto l216
					}
					goto l215
				l216:
					position, tokenIndex = position215, tokenIndex215
					{
						position218 := position
						if !_rules[rulecomparator]() {
							goto l217
						}
						add(rulePegText, position218)
					}
					if !_rules[ruleAction30]() {
						goto l217
					}
					goto l215
				l217:
					position, tokenIndex = position215, tokenIndex215
					{
						position219 := position
						{
							position220, tokenIndex220 := position, tokenIndex
							if !_rules[rulelogicNot]() {
								goto l220
							}
							goto l221
						l220:
							position, tokenIndex = position220, tokenIndex220
						}
					l221:
						add(rulePegText, position219)
					}
					if !_rules[ruleAction31]() {
						goto l213
					}
					if !_rules[rulejsonpathFilter]() {
						goto l213
					}
					if !_rules[ruleAction32]() {
						goto l213
					}
				}
			l215:
				add(rulebasicQuery, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 31 logicOr <- <(space ('|' '|') space)> */
		func() bool {
			position222, tokenIndex222 := position, tokenIndex
			{
				position223 := position
				if !_rules[rulespace]() {
					goto l222
				}
				if buffer[position] != rune('|') {
					goto l222
				}
				position++
				if buffer[position] != rune('|') {
					goto l222
				}
				position++
				if !_rules[rulespace]() {
					goto l222
				}
				add(rulelogicOr, position223)
			}
			return true
		l222:
			position, tokenIndex = position222, tokenIndex222
			return false
		},
		/* 32 logicAnd <- <(space ('&' '&') space)> */
		func() bool {
			position224, tokenIndex224 := position, tokenIndex
			{
				position225 := position
				if !_rules[rulespace]() {
					goto l224
				}
				if buffer[position] != rune('&') {
					goto l224
				}
				position++
				if buffer[position] != rune('&') {
					goto l224
				}
				position++
				if !_rules[rulespace]() {
					goto l224
				}
				add(rulelogicAnd, position225)
			}
			return true
		l224:
			position, tokenIndex = position224, tokenIndex224
			return false
		},
		/* 33 logicNot <- <('!' space)> */
		func() bool {
			position226, tokenIndex226 := position, tokenIndex
			{
				position227 := position
				if buffer[position] != rune('!') {
					goto l226
				}
				position++
				if !_rules[rulespace]() {
					goto l226
				}
				add(rulelogicNot, position227)
			}
			return true
		l226:
			position, tokenIndex = position226, tokenIndex226
			return false
		},
		/* 34 comparator <- <((qParam space (('=' '=' space qParam Action33) / ('!' '=' space qParam Action34))) / (qNumericParam space (('<' '=' space qNumericParam Action35) / ('<' space qNumericParam Action36) / ('>' '=' space qNumericParam Action37) / ('>' space qNumericParam Action38))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action39))> */
		func() bool {
			position228, tokenIndex228 := position, tokenIndex
			{
				position229 := position
				{
					position230, tokenIndex230 := position, tokenIndex
					if !_rules[ruleqParam]() {
						goto l231
					}
					if !_rules[rulespace]() {
						goto l231
					}
					{
						position232, tokenIndex232 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l233
						}
						position++
						if buffer[position] != rune('=') {
							goto l233
						}
						position++
						if !_rules[rulespace]() {
							goto l233
						}
						if !_rules[ruleqParam]() {
							goto l233
						}
						if !_rules[ruleAction33]() {
							goto l233
						}
						goto l232
					l233:
						position, tokenIndex = position232, tokenIndex232
						if buffer[position] != rune('!') {
							goto l231
						}
						position++
						if buffer[position] != rune('=') {
							goto l231
						}
						position++
						if !_rules[rulespace]() {
							goto l231
						}
						if !_rules[ruleqParam]() {
							goto l231
						}
						if !_rules[ruleAction34]() {
							goto l231
						}
					}
				l232:
					goto l230
				l231:
					position, tokenIndex = position230, tokenIndex230
					if !_rules[ruleqNumericParam]() {
						goto l234
					}
					if !_rules[rulespace]() {
						goto l234
					}
					{
						position235, tokenIndex235 := position, tokenIndex
						if buffer[position] != rune('<') {
							goto l236
						}
						position++
						if buffer[position] != rune('=') {
							goto l236
						}
						position++
						if !_rules[rulespace]() {
							goto l236
						}
						if !_rules[ruleqNumericParam]() {
							goto l236
						}
						if !_rules[ruleAction35]() {
							goto l236
						}
						goto l235
					l236:
						position, tokenIndex = position235, tokenIndex235
						if buffer[position] != rune('<') {
							goto l237
						}
						position++
						if !_rules[rulespace]() {
							goto l237
						}
						if !_rules[ruleqNumericParam]() {
							goto l237
						}
						if !_rules[ruleAction36]() {
							goto l237
						}
						goto l235
					l237:
						position, tokenIndex = position235, tokenIndex235
						if buffer[position] != rune('>') {
							goto l238
						}
						position++
						if buffer[position] != rune('=') {
							goto l238
						}
						position++
						if !_rules[rulespace]() {
							goto l238
						}
						if !_rules[ruleqNumericParam]() {
							goto l238
						}
						if !_rules[ruleAction37]() {
							goto l238
						}
						goto l235
					l238:
						position, tokenIndex = position235, tokenIndex235
						if buffer[position] != rune('>') {
							goto l234
						}
						position++
						if !_rules[rulespace]() {
							goto l234
						}
						if !_rules[ruleqNumericParam]() {
							goto l234
						}
						if !_rules[ruleAction38]() {
							goto l234
						}
					}
				l235:
					goto l230
				l234:
					position, tokenIndex = position230, tokenIndex230
					if !_rules[rulesingleJsonpathFilter]() {
						goto l228
					}
					if !_rules[rulespace]() {
						goto l228
					}
					if buffer[position] != rune('=') {
						goto l228
					}
					position++
					if buffer[position] != rune('~') {
						goto l228
					}
					position++
					if !_rules[rulespace]() {
						goto l228
					}
					if buffer[position] != rune('/') {
						goto l228
					}
					position++
					{
						position239 := position
						if !_rules[ruleregex]() {
							goto l228
						}
						add(rulePegText, position239)
					}
					if buffer[position] != rune('/') {
						goto l228
					}
					position++
					if !_rules[ruleAction39]() {
						goto l228
					}
				}
			l230:
				add(rulecomparator, position229)
			}
			return true
		l228:
			position, tokenIndex = position228, tokenIndex228
			return false
		},
		/* 35 qParam <- <((qLiteral Action40) / singleJsonpathFilter)> */
		func() bool {
			position240, tokenIndex240 := position, tokenIndex
			{
				position241 := position
				{
					position242, tokenIndex242 := position, tokenIndex
					if !_rules[ruleqLiteral]() {
						goto l243
					}
					if !_rules[ruleAction40]() {
						goto l243
					}
					goto l242
				l243:
					position, tokenIndex = position242, tokenIndex242
					if !_rules[rulesingleJsonpathFilter]() {
						goto l240
					}
				}
			l242:
				add(ruleqParam, position241)
			}
			return true
		l240:
			position, tokenIndex = position240, tokenIndex240
			return false
		},
		/* 36 qNumericParam <- <((lNumber Action41) / singleJsonpathFilter)> */
		func() bool {
			position244, tokenIndex244 := position, tokenIndex
			{
				position245 := position
				{
					position246, tokenIndex246 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l247
					}
					if !_rules[ruleAction41]() {
						goto l247
					}
					goto l246
				l247:
					position, tokenIndex = position246, tokenIndex246
					if !_rules[rulesingleJsonpathFilter]() {
						goto l244
					}
				}
			l246:
				add(ruleqNumericParam, position245)
			}
			return true
		l244:
			position, tokenIndex = position244, tokenIndex244
			return false
		},
		/* 37 qLiteral <- <(lNumber / lBool / lString / lNull)> */
		func() bool {
			position248, tokenIndex248 := position, tokenIndex
			{
				position249 := position
				{
					position250, tokenIndex250 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l251
					}
					goto l250
				l251:
					position, tokenIndex = position250, tokenIndex250
					if !_rules[rulelBool]() {
						goto l252
					}
					goto l250
				l252:
					position, tokenIndex = position250, tokenIndex250
					if !_rules[rulelString]() {
						goto l253
					}
					goto l250
				l253:
					position, tokenIndex = position250, tokenIndex250
					if !_rules[rulelNull]() {
						goto l248
					}
				}
			l250:
				add(ruleqLiteral, position249)
			}
			return true
		l248:
			position, tokenIndex = position248, tokenIndex248
			return false
		},
		/* 38 singleJsonpathFilter <- <(jsonpathFilter Action42)> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				if !_rules[rulejsonpathFilter]() {
					goto l254
				}
				if !_rules[ruleAction42]() {
					goto l254
				}
				add(rulesingleJsonpathFilter, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 39 jsonpathFilter <- <(<jsonpath> Action43)> */
		func() bool {
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				{
					position258 := position
					if !_rules[rulejsonpath]() {
						goto l256
					}
					add(rulePegText, position258)
				}
				if !_rules[ruleAction43]() {
					goto l256
				}
				add(rulejsonpathFilter, position257)
			}
			return true
		l256:
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 40 lNumber <- <(<(('-' / '+')? [0-9] ('-' / '+' / '.' / [0-9] / [a-z] / [A-Z])*)> Action44)> */
		func() bool {
			position259, tokenIndex259 := position, tokenIndex
			{
				position260 := position
				{
					position261 := position
					{
						position262, tokenIndex262 := position, tokenIndex
						{
							position264, tokenIndex264 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l265
							}
							position++
							goto l264
						l265:
							position, tokenIndex = position264, tokenIndex264
							if buffer[position] != rune('+') {
								goto l262
							}
							position++
						}
					l264:
						goto l263
					l262:
						position, tokenIndex = position262, tokenIndex262
					}
				l263:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l259
					}
					position++
				l266:
					{
						position267, tokenIndex267 := position, tokenIndex
						{
							position268, tokenIndex268 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l269
							}
							position++
							goto l268
						l269:
							position, tokenIndex = position268, tokenIndex268
							if buffer[position] != rune('+') {
								goto l270
							}
							position++
							goto l268
						l270:
							position, tokenIndex = position268, tokenIndex268
							if buffer[position] != rune('.') {
								goto l271
							}
							position++
							goto l268
						l271:
							position, tokenIndex = position268, tokenIndex268
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l272
							}
							position++
							goto l268
						l272:
							position, tokenIndex = position268, tokenIndex268
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l273
							}
							position++
							goto l268
						l273:
							position, tokenIndex = position268, tokenIndex268
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l267
							}
							position++
						}
					l268:
						goto l266
					l267:
						position, tokenIndex = position267, tokenIndex267
					}
					add(rulePegText, position261)
				}
				if !_rules[ruleAction44]() {
					goto l259
				}
				add(rulelNumber, position260)
			}
			return true
		l259:
			position, tokenIndex = position259, tokenIndex259
			return false
		},
		/* 41 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action45) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action46))> */
		func() bool {
			position274, tokenIndex274 := position, tokenIndex
			{
				position275 := position
				{
					position276, tokenIndex276 := position, tokenIndex
					{
						position278, tokenIndex278 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l279
						}
						position++
						if buffer[position] != rune('r') {
							goto l279
						}
						position++
						if buffer[position] != rune('u') {
							goto l279
						}
						position++
						if buffer[position] != rune('e') {
							goto l279
						}
						position++
						goto l278
					l279:
						position, tokenIndex = position278, tokenIndex278
						if buffer[position] != rune('T') {
							goto l280
						}
						position++
						if buffer[position] != rune('r') {
							goto l280
						}
						position++
						if buffer[position] != rune('u') {
							goto l280
						}
						position++
						if buffer[position] != rune('e') {
							goto l280
						}
						position++
						goto l278
					l280:
						position, tokenIndex = position278, tokenIndex278
						if buffer[position] != rune('T') {
							goto l277
						}
						position++
						if buffer[position] != rune('R') {
							goto l277
						}
						position++
						if buffer[position] != rune('U') {
							goto l277
						}
						position++
						if buffer[position] != rune('E') {
							goto l277
						}
						position++
					}
				l278:
					if !_rules[ruleAction45]() {
						goto l277
					}
					goto l276
				l277:
					position, tokenIndex = position276, tokenIndex276
					{
						position281, tokenIndex281 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l282
						}
						position++
						if buffer[position] != rune('a') {
							goto l282
						}
						position++
						if buffer[position] != rune('l') {
							goto l282
						}
						position++
						if buffer[position] != rune('s') {
							goto l282
						}
						position++
						if buffer[position] != rune('e') {
							goto l282
						}
						position++
						goto l281
					l282:
						position, tokenIndex = position281, tokenIndex281
						if buffer[position] != rune('F') {
							goto l283
						}
						position++
						if buffer[position] != rune('a') {
							goto l283
						}
						position++
						if buffer[position] != rune('l') {
							goto l283
						}
						position++
						if buffer[position] != rune('s') {
							goto l283
						}
						position++
						if buffer[position] != rune('e') {
							goto l283
						}
						position++
						goto l281
					l283:
						position, tokenIndex = position281, tokenIndex281
						if buffer[position] != rune('F') {
							goto l274
						}
						position++
						if buffer[position] != rune('A') {
							goto l274
						}
						position++
						if buffer[position] != rune('L') {
							goto l274
						}
						position++
						if buffer[position] != rune('S') {
							goto l274
						}
						position++
						if buffer[position] != rune('E') {
							goto l274
						}
						position++
					}
				l281:
					if !_rules[ruleAction46]() {
						goto l274
					}
				}
			l276:
				add(rulelBool, position275)
			}
			return true
		l274:
			position, tokenIndex = position274, tokenIndex274
			return false
		},
		/* 42 lString <- <(('\'' <(('\\' '\\') / ('\\' '\'') / (!'\'' .))*> '\'' Action47) / ('"' <(('\\' '\\') / ('\\' '"') / (!'"' .))*> '"' Action48))> */
		func() bool {
			position284, tokenIndex284 := position, tokenIndex
			{
				position285 := position
				{
					position286, tokenIndex286 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l287
					}
					position++
					{
						position288 := position
					l289:
						{
							position290, tokenIndex290 := position, tokenIndex
							{
								position291, tokenIndex291 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l292
								}
								position++
								if buffer[position] != rune('\\') {
									goto l292
								}
								position++
								goto l291
							l292:
								position, tokenIndex = position291, tokenIndex291
								if buffer[position] != rune('\\') {
									goto l293
								}
								position++
								if buffer[position] != rune('\'') {
									goto l293
								}
								position++
								goto l291
							l293:
								position, tokenIndex = position291, tokenIndex291
								{
									position294, tokenIndex294 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l294
									}
									position++
									goto l290
								l294:
									position, tokenIndex = position294, tokenIndex294
								}
								if !matchDot() {
									goto l290
								}
							}
						l291:
							goto l289
						l290:
							position, tokenIndex = position290, tokenIndex290
						}
						add(rulePegText, position288)
					}
					if buffer[position] != rune('\'') {
						goto l287
					}
					position++
					if !_rules[ruleAction47]() {
						goto l287
					}
					goto l286
				l287:
					position, tokenIndex = position286, tokenIndex286
					if buffer[position] != rune('"') {
						goto l284
					}
					position++
					{
						position295 := position
					l296:
						{
							position297, tokenIndex297 := position, tokenIndex
							{
								position298, tokenIndex298 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l299
								}
								position++
								if buffer[position] != rune('\\') {
									goto l299
								}
								position++
								goto l298
							l299:
								position, tokenIndex = position298, tokenIndex298
								if buffer[position] != rune('\\') {
									goto l300
								}
								position++
								if buffer[position] != rune('"') {
									goto l300
								}
								position++
								goto l298
							l300:
								position, tokenIndex = position298, tokenIndex298
								{
									position301, tokenIndex301 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l301
									}
									position++
									goto l297
								l301:
									position, tokenIndex = position301, tokenIndex301
								}
								if !matchDot() {
									goto l297
								}
							}
						l298:
							goto l296
						l297:
							position, tokenIndex = position297, tokenIndex297
						}
						add(rulePegText, position295)
					}
					if buffer[position] != rune('"') {
						goto l284
					}
					position++
					if !_rules[ruleAction48]() {
						goto l284
					}
				}
			l286:
				add(rulelString, position285)
			}
			return true
		l284:
			position, tokenIndex = position284, tokenIndex284
			return false
		},
		/* 43 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action49)> */
		func() bool {
			position302, tokenIndex302 := position, tokenIndex
			{
				position303 := position
				{
					position304, tokenIndex304 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l305
					}
					position++
					if buffer[position] != rune('u') {
						goto l305
					}
					position++
					if buffer[position] != rune('l') {
						goto l305
					}
					position++
					if buffer[position] != rune('l') {
						goto l305
					}
					position++
					goto l304
				l305:
					position, tokenIndex = position304, tokenIndex304
					if buffer[position] != rune('N') {
						goto l306
					}
					position++
					if buffer[position] != rune('u') {
						goto l306
					}
					position++
					if buffer[position] != rune('l') {
						goto l306
					}
					position++
					if buffer[position] != rune('l') {
						goto l306
					}
					position++
					goto l304
				l306:
					position, tokenIndex = position304, tokenIndex304
					if buffer[position] != rune('N') {
						goto l302
					}
					position++
					if buffer[position] != rune('U') {
						goto l302
					}
					position++
					if buffer[position] != rune('L') {
						goto l302
					}
					position++
					if buffer[position] != rune('L') {
						goto l302
					}
					position++
				}
			l304:
				if !_rules[ruleAction49]() {
					goto l302
				}
				add(rulelNull, position303)
			}
			return true
		l302:
			position, tokenIndex = position302, tokenIndex302
			return false
		},
		/* 44 regex <- <(('\\' '\\') / ('\\' '/') / (!'/' .))*> */
		func() bool {
			{
				position308 := position
			l309:
				{
					position310, tokenIndex310 := position, tokenIndex
					{
						position311, tokenIndex311 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l312
						}
						position++
						if buffer[position] != rune('\\') {
							goto l312
						}
						position++
						goto l311
					l312:
						position, tokenIndex = position311, tokenIndex311
						if buffer[position] != rune('\\') {
							goto l313
						}
						position++
						if buffer[position] != rune('/') {
							goto l313
						}
						position++
						goto l311
					l313:
						position, tokenIndex = position311, tokenIndex311
						{
							position314, tokenIndex314 := position, tokenIndex
							if buffer[position] != rune('/') {
								goto l314
							}
							position++
							goto l310
						l314:
							position, tokenIndex = position314, tokenIndex314
						}
						if !matchDot() {
							goto l310
						}
					}
				l311:
					goto l309
				l310:
					position, tokenIndex = position310, tokenIndex310
				}
				add(ruleregex, position308)
			}
			return true
		},
		/* 45 squareBracketStart <- <('[' space)> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if buffer[position] != rune('[') {
					goto l315
				}
				position++
				if !_rules[rulespace]() {
					goto l315
				}
				add(rulesquareBracketStart, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 46 squareBracketEnd <- <(space ']')> */
		func() bool {
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if !_rules[rulespace]() {
					goto l317
				}
				if buffer[position] != rune(']') {
					goto l317
				}
				position++
				add(rulesquareBracketEnd, position318)
			}
			return true
		l317:
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 47 scriptStart <- <('(' space)> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				if buffer[position] != rune('(') {
					goto l319
				}
				position++
				if !_rules[rulespace]() {
					goto l319
				}
				add(rulescriptStart, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 48 scriptEnd <- <(space ')')> */
		func() bool {
			position321, tokenIndex321 := position, tokenIndex
			{
				position322 := position
				if !_rules[rulespace]() {
					goto l321
				}
				if buffer[position] != rune(')') {
					goto l321
				}
				position++
				add(rulescriptEnd, position322)
			}
			return true
		l321:
			position, tokenIndex = position321, tokenIndex321
			return false
		},
		/* 49 filterStart <- <('?' '(' space)> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				if buffer[position] != rune('?') {
					goto l323
				}
				position++
				if buffer[position] != rune('(') {
					goto l323
				}
				position++
				if !_rules[rulespace]() {
					goto l323
				}
				add(rulefilterStart, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 50 filterEnd <- <(space ')')> */
		func() bool {
			position325, tokenIndex325 := position, tokenIndex
			{
				position326 := position
				if !_rules[rulespace]() {
					goto l325
				}
				if buffer[position] != rune(')') {
					goto l325
				}
				position++
				add(rulefilterEnd, position326)
			}
			return true
		l325:
			position, tokenIndex = position325, tokenIndex325
			return false
		},
		/* 51 subQueryStart <- <('(' space)> */
		func() bool {
			position327, tokenIndex327 := position, tokenIndex
			{
				position328 := position
				if buffer[position] != rune('(') {
					goto l327
				}
				position++
				if !_rules[rulespace]() {
					goto l327
				}
				add(rulesubQueryStart, position328)
			}
			return true
		l327:
			position, tokenIndex = position327, tokenIndex327
			return false
		},
		/* 52 subQueryEnd <- <(space ')')> */
		func() bool {
			position329, tokenIndex329 := position, tokenIndex
			{
				position330 := position
				if !_rules[rulespace]() {
					goto l329
				}
				if buffer[position] != rune(')') {
					goto l329
				}
				position++
				add(rulesubQueryEnd, position330)
			}
			return true
		l329:
			position, tokenIndex = position329, tokenIndex329
			return false
		},
		/* 53 space <- <(' ' / '\t')*> */
		func() bool {
			{
				position332 := position
			l333:
				{
					position334, tokenIndex334 := position, tokenIndex
					{
						position335, tokenIndex335 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l336
						}
						position++
						goto l335
					l336:
						position, tokenIndex = position335, tokenIndex335
						if buffer[position] != rune('\t') {
							goto l334
						}
						position++
					}
				l335:
					goto l333
				l334:
					position, tokenIndex = position334, tokenIndex334
				}
				add(rulespace, position332)
			}
			return true
		},
		/* 55 Action0 <- <{
		    p.root = p.pop().(syntaxNode)
		}> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		nil,
		/* 57 Action1 <- <{
		    p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)
		}> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 58 Action2 <- <{
		    p.saveParams()
		}> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 59 Action3 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		    p.loadParams()
		}> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 60 Action4 <- <{
		    if len(p.paramsList) == 0 {
		        p.syntaxErr(begin, msgErrorInvalidSyntaxUseBeginAtsign, buffer)
		    }
		}> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 61 Action5 <- <{
		    if len(p.paramsList) != 0 {
		        p.syntaxErr(begin, msgErrorInvalidSyntaxOmitDollar, buffer)
		    }
		}> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 62 Action6 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 63 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 64 Action8 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 65 Action9 <- <{
		    p.push(text)
		}> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 66 Action10 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 67 Action11 <- <{
		    p.pushRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 68 Action12 <- <{
		    p.pushCurrentRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 69 Action13 <- <{
		    unescapedText := p.unescape(text)
		    if unescapedText == `*` {
		        p.pushChildWildcardIdentifier(unescapedText)
		    } else {
		        p.pushChildSingleIdentifier(unescapedText)
		    }
		}> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 70 Action14 <- <{
		    identifier := p.pop().([]string)
		    if len(identifier) > 1 {
		        p.pushChildMultiIdentifier(identifier)
		    } else {
		        p.pushChildSingleIdentifier(identifier[0])
		    }
		}> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 71 Action15 <- <{
		    identifier2 := p.pop().([]string)
		    identifier1 := p.pop().([]string)
		    p.push(append(identifier1, identifier2...))
		}> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 72 Action16 <- <{
		    p.push([]string{p.pop().(string)})
		}> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 73 Action17 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 74 Action18 <- <{ // '
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 75 Action19 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 76 Action20 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted || step.number == 0 {
		        step.number = 1
		    }

		    if step.number > 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 77 Action21 <- <{
		    p.pushIndexSubscript(text)
		}> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 78 Action22 <- <{
		    p.pushWildcardSubscript()
		}> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 79 Action23 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 80 Action24 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 81 Action25 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 82 Action26 <- <{
		    p.pushScriptQualifier(text)
		}> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 83 Action27 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 84 Action28 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 85 Action29 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 86 Action30 <- <{
		        if !p.hasErr() {
		            query := p.pop().(syntaxQuery)
		            p.push(query)

					if logicalNot, ok := query.(*syntaxLogicalNot); ok {
						query = (*logicalNot).query
					}
		            if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		                _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
		                _, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
		                if leftIsCurrentRoot && rigthIsCurrentRoot {
		                    p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
		                }
					}
		        }
		    }> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 87 Action31 <- <{
		    p.push(len(text) > 0 && text[0:1] == `!`)
		}> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 88 Action32 <- <{
		    _ = p.pop().(bool)
		    jsonpathFilter := p.pop().(syntaxQuery)
		    isLogicalNot := p.pop().(bool)
		    if isLogicalNot {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 89 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 90 Action34 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 91 Action35 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		/* 92 Action36 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 93 Action37 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 94 Action38 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 95 Action39 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 96 Action40 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 97 Action41 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 98 Action42 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if !p.hasErr() && param.isValueGroupParameter() {
		        p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 99 Action43 <- <{
		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootIdentifier:
		        p.pushCompareParameterRoot(node)
		        p.push(true)
		    case *syntaxCurrentRootIdentifier:
		        p.pushCompareParameterCurrentRoot(node)
		        p.push(false)
		    default:
		        p.push(&syntaxQueryParamRoot{})
		        p.push(true)
		    }
		}> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		/* 100 Action44 <- <{
		    p.push(p.toFloat(text))
		}> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 101 Action45 <- <{
		    p.push(true)
		}> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
		/* 102 Action46 <- <{
		    p.push(false)
		}> */
		func() bool {
			{
				add(ruleAction46, position)
			}
			return true
		},
		/* 103 Action47 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction47, position)
			}
			return true
		},
		/* 104 Action48 <- <{ // '
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction48, position)
			}
			return true
		},
		/* 105 Action49 <- <{
		    p.push(nil)
		}> */
		func() bool {
			{
				add(ruleAction49, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
