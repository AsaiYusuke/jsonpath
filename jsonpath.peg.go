package jsonpath

// Code generated by C:\Users\prome\go\bin\peg.exe jsonpath.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpath
	rulejsonpathParameter
	rulecontinuedJsonpath
	rulerootNode
	ruleparameterRootNode
	rulechildNode
	rulefunction
	rulefunctionName
	rulebracketNode
	rulerootIdentifier
	rulecurrentRootIdentifier
	ruledotChildIdentifier
	rulesignsWithoutHyphenUnderscore
	rulebracketChildIdentifier
	rulebracketNodeIdentifier
	rulewildcardIdentifier
	rulesingleQuotedNodeIdentifier
	ruledoubleQuotedNodeIdentifier
	rulehexDigits
	rulehexDigit
	rulequalifier
	ruleunion
	ruleindex
	ruleslice
	ruleanyIndex
	ruleindexNumber
	rulesep
	rulesepSlice
	rulescript
	rulecommand
	rulefilter
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptStart
	rulescriptEnd
	rulefilterStart
	rulefilterEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpath",
	"jsonpathParameter",
	"continuedJsonpath",
	"rootNode",
	"parameterRootNode",
	"childNode",
	"function",
	"functionName",
	"bracketNode",
	"rootIdentifier",
	"currentRootIdentifier",
	"dotChildIdentifier",
	"signsWithoutHyphenUnderscore",
	"bracketChildIdentifier",
	"bracketNodeIdentifier",
	"wildcardIdentifier",
	"singleQuotedNodeIdentifier",
	"doubleQuotedNodeIdentifier",
	"hexDigits",
	"hexDigit",
	"qualifier",
	"union",
	"index",
	"slice",
	"anyIndex",
	"indexNumber",
	"sep",
	"sepSlice",
	"script",
	"command",
	"filter",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptStart",
	"scriptEnd",
	"filterStart",
	"filterEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer string
	buffer []rune
	rules  [107]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootIdentifier(p.pop().(syntaxNode))
			p.setConnectedText(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction3:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction4:

			p.setLastNodeText(text)

		case ruleAction5:

			p.pushFunction(text, p.pop().(string))

		case ruleAction6:

			p.push(text)

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.pushRootIdentifier()

		case ruleAction9:

			p.pushCurrentRootIdentifier()

		case ruleAction10:
			//`
			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction11:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction12:

			p.pushChildWildcardIdentifier()

		case ruleAction13:

			p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))

		case ruleAction14:
			// '
			p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))

		case ruleAction15:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction16:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted || step.number == 0 {
				step.number = 1
			}

			if step.number > 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction17:

			p.pushIndexSubscript(text)

		case ruleAction18:

			p.pushWildcardSubscript()

		case ruleAction19:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction20:

			p.pushIndexSubscript(`1`)

		case ruleAction21:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction22:

			p.pushScriptQualifier(text)

		case ruleAction23:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction24:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction25:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction26:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
				_, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
				_, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
				if leftIsCurrentRoot && rigthIsCurrentRoot {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction27:

			_ = p.pop()
			jsonpathFilter := p.pop().(syntaxQuery)
			if text[0:1] == `!` {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction28:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction29:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction34:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction35:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction36:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction37:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction38:

			p.saveParams()

		case ruleAction39:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootIdentifier:
				p.pushCompareParameterRoot(p.deleteRootIdentifier(node))
				p.push(true)
			case *syntaxCurrentRootIdentifier:
				p.pushCompareParameterCurrentRoot(p.deleteRootIdentifier(node))
				p.push(false)
			}

		case ruleAction40:

			p.push(p.toFloat(text))

		case ruleAction41:

			p.push(true)

		case ruleAction42:

			p.push(false)

		case ruleAction43:

			p.push(p.unescape(text))

		case ruleAction44:
			// '
			p.push(p.unescape(text))

		case ruleAction45:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <((jsonpath END Action0) / (jsonpath? <.*> END Action1))> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[rulejsonpath]() {
						goto l3
					}
					if !_rules[ruleEND]() {
						goto l3
					}
					if !_rules[ruleAction0]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpath]() {
							goto l4
						}
						goto l5
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
				l5:
					{
						position6 := position
					l7:
						{
							position8, tokenIndex8 := position, tokenIndex
							if !matchDot() {
								goto l8
							}
							goto l7
						l8:
							position, tokenIndex = position8, tokenIndex8
						}
						add(rulePegText, position6)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					if !_rules[ruleAction1]() {
						goto l0
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position11, tokenIndex11 := position, tokenIndex
					if !matchDot() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position11, tokenIndex11
				}
				add(ruleEND, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 2 jsonpath <- <(space rootNode continuedJsonpath)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[rulespace]() {
					goto l12
				}
				if !_rules[rulerootNode]() {
					goto l12
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l12
				}
				add(rulejsonpath, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 jsonpathParameter <- <(space parameterRootNode continuedJsonpath)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[rulespace]() {
					goto l14
				}
				if !_rules[ruleparameterRootNode]() {
					goto l14
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l14
				}
				add(rulejsonpathParameter, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 4 continuedJsonpath <- <(childNode* function* space Action2)> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
			l18:
				{
					position19, tokenIndex19 := position, tokenIndex
					if !_rules[rulechildNode]() {
						goto l19
					}
					goto l18
				l19:
					position, tokenIndex = position19, tokenIndex19
				}
			l20:
				{
					position21, tokenIndex21 := position, tokenIndex
					if !_rules[rulefunction]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position21, tokenIndex21
				}
				if !_rules[rulespace]() {
					goto l16
				}
				if !_rules[ruleAction2]() {
					goto l16
				}
				add(rulecontinuedJsonpath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 5 rootNode <- <(rootIdentifier / bracketNode / dotChildIdentifier)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				{
					position24, tokenIndex24 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[rulebracketNode]() {
						goto l26
					}
					goto l24
				l26:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[ruledotChildIdentifier]() {
						goto l22
					}
				}
			l24:
				add(rulerootNode, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 6 parameterRootNode <- <(rootIdentifier / currentRootIdentifier)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l30
					}
					goto l29
				l30:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[rulecurrentRootIdentifier]() {
						goto l27
					}
				}
			l29:
				add(ruleparameterRootNode, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 7 childNode <- <(('.' '.' (bracketNode / dotChildIdentifier) Action3) / (<('.' dotChildIdentifier)> Action4) / bracketNode)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				{
					position33, tokenIndex33 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l34
					}
					position++
					if buffer[position] != rune('.') {
						goto l34
					}
					position++
					{
						position35, tokenIndex35 := position, tokenIndex
						if !_rules[rulebracketNode]() {
							goto l36
						}
						goto l35
					l36:
						position, tokenIndex = position35, tokenIndex35
						if !_rules[ruledotChildIdentifier]() {
							goto l34
						}
					}
				l35:
					if !_rules[ruleAction3]() {
						goto l34
					}
					goto l33
				l34:
					position, tokenIndex = position33, tokenIndex33
					{
						position38 := position
						if buffer[position] != rune('.') {
							goto l37
						}
						position++
						if !_rules[ruledotChildIdentifier]() {
							goto l37
						}
						add(rulePegText, position38)
					}
					if !_rules[ruleAction4]() {
						goto l37
					}
					goto l33
				l37:
					position, tokenIndex = position33, tokenIndex33
					if !_rules[rulebracketNode]() {
						goto l31
					}
				}
			l33:
				add(rulechildNode, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 8 function <- <(<('.' functionName ('(' ')'))> Action5)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				{
					position41 := position
					if buffer[position] != rune('.') {
						goto l39
					}
					position++
					if !_rules[rulefunctionName]() {
						goto l39
					}
					if buffer[position] != rune('(') {
						goto l39
					}
					position++
					if buffer[position] != rune(')') {
						goto l39
					}
					position++
					add(rulePegText, position41)
				}
				if !_rules[ruleAction5]() {
					goto l39
				}
				add(rulefunction, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 9 functionName <- <(<('-' / '_' / [a-z] / [A-Z])+> Action6)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44 := position
					{
						position47, tokenIndex47 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l48
						}
						position++
						goto l47
					l48:
						position, tokenIndex = position47, tokenIndex47
						if buffer[position] != rune('_') {
							goto l49
						}
						position++
						goto l47
					l49:
						position, tokenIndex = position47, tokenIndex47
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l50
						}
						position++
						goto l47
					l50:
						position, tokenIndex = position47, tokenIndex47
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l42
						}
						position++
					}
				l47:
				l45:
					{
						position46, tokenIndex46 := position, tokenIndex
						{
							position51, tokenIndex51 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l52
							}
							position++
							goto l51
						l52:
							position, tokenIndex = position51, tokenIndex51
							if buffer[position] != rune('_') {
								goto l53
							}
							position++
							goto l51
						l53:
							position, tokenIndex = position51, tokenIndex51
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l54
							}
							position++
							goto l51
						l54:
							position, tokenIndex = position51, tokenIndex51
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l46
							}
							position++
						}
					l51:
						goto l45
					l46:
						position, tokenIndex = position46, tokenIndex46
					}
					add(rulePegText, position44)
				}
				if !_rules[ruleAction6]() {
					goto l42
				}
				add(rulefunctionName, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 10 bracketNode <- <(<(squareBracketStart (bracketChildIdentifier / qualifier) squareBracketEnd)> Action7)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				{
					position57 := position
					if !_rules[rulesquareBracketStart]() {
						goto l55
					}
					{
						position58, tokenIndex58 := position, tokenIndex
						if !_rules[rulebracketChildIdentifier]() {
							goto l59
						}
						goto l58
					l59:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[rulequalifier]() {
							goto l55
						}
					}
				l58:
					if !_rules[rulesquareBracketEnd]() {
						goto l55
					}
					add(rulePegText, position57)
				}
				if !_rules[ruleAction7]() {
					goto l55
				}
				add(rulebracketNode, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 11 rootIdentifier <- <('$' Action8)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if buffer[position] != rune('$') {
					goto l60
				}
				position++
				if !_rules[ruleAction8]() {
					goto l60
				}
				add(rulerootIdentifier, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 12 currentRootIdentifier <- <('@' Action9)> */
		func() bool {
			position62, tokenIndex62 := position, tokenIndex
			{
				position63 := position
				if buffer[position] != rune('@') {
					goto l62
				}
				position++
				if !_rules[ruleAction9]() {
					goto l62
				}
				add(rulecurrentRootIdentifier, position63)
			}
			return true
		l62:
			position, tokenIndex = position62, tokenIndex62
			return false
		},
		/* 13 dotChildIdentifier <- <(wildcardIdentifier / (<(('\\' signsWithoutHyphenUnderscore) / (!([\x00-\x1f] / '\u007f') !signsWithoutHyphenUnderscore .))+> !('(' ')') Action10))> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				{
					position66, tokenIndex66 := position, tokenIndex
					if !_rules[rulewildcardIdentifier]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position66, tokenIndex66
					{
						position68 := position
						{
							position71, tokenIndex71 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l72
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l72
							}
							goto l71
						l72:
							position, tokenIndex = position71, tokenIndex71
							{
								position73, tokenIndex73 := position, tokenIndex
								{
									position74, tokenIndex74 := position, tokenIndex
									if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
										goto l75
									}
									position++
									goto l74
								l75:
									position, tokenIndex = position74, tokenIndex74
									if buffer[position] != rune('\u007f') {
										goto l73
									}
									position++
								}
							l74:
								goto l64
							l73:
								position, tokenIndex = position73, tokenIndex73
							}
							{
								position76, tokenIndex76 := position, tokenIndex
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l76
								}
								goto l64
							l76:
								position, tokenIndex = position76, tokenIndex76
							}
							if !matchDot() {
								goto l64
							}
						}
					l71:
					l69:
						{
							position70, tokenIndex70 := position, tokenIndex
							{
								position77, tokenIndex77 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l78
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l78
								}
								goto l77
							l78:
								position, tokenIndex = position77, tokenIndex77
								{
									position79, tokenIndex79 := position, tokenIndex
									{
										position80, tokenIndex80 := position, tokenIndex
										if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
											goto l81
										}
										position++
										goto l80
									l81:
										position, tokenIndex = position80, tokenIndex80
										if buffer[position] != rune('\u007f') {
											goto l79
										}
										position++
									}
								l80:
									goto l70
								l79:
									position, tokenIndex = position79, tokenIndex79
								}
								{
									position82, tokenIndex82 := position, tokenIndex
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l82
									}
									goto l70
								l82:
									position, tokenIndex = position82, tokenIndex82
								}
								if !matchDot() {
									goto l70
								}
							}
						l77:
							goto l69
						l70:
							position, tokenIndex = position70, tokenIndex70
						}
						add(rulePegText, position68)
					}
					{
						position83, tokenIndex83 := position, tokenIndex
						if buffer[position] != rune('(') {
							goto l83
						}
						position++
						if buffer[position] != rune(')') {
							goto l83
						}
						position++
						goto l64
					l83:
						position, tokenIndex = position83, tokenIndex83
					}
					if !_rules[ruleAction10]() {
						goto l64
					}
				}
			l66:
				add(ruledotChildIdentifier, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 14 signsWithoutHyphenUnderscore <- <([ -,] / '.' / '/' / [:-@] / [[-^] / '`' / [{-~])> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				{
					position86, tokenIndex86 := position, tokenIndex
					if c := buffer[position]; c < rune(' ') || c > rune(',') {
						goto l87
					}
					position++
					goto l86
				l87:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune('.') {
						goto l88
					}
					position++
					goto l86
				l88:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune('/') {
						goto l89
					}
					position++
					goto l86
				l89:
					position, tokenIndex = position86, tokenIndex86
					if c := buffer[position]; c < rune(':') || c > rune('@') {
						goto l90
					}
					position++
					goto l86
				l90:
					position, tokenIndex = position86, tokenIndex86
					if c := buffer[position]; c < rune('[') || c > rune('^') {
						goto l91
					}
					position++
					goto l86
				l91:
					position, tokenIndex = position86, tokenIndex86
					if buffer[position] != rune('`') {
						goto l92
					}
					position++
					goto l86
				l92:
					position, tokenIndex = position86, tokenIndex86
					if c := buffer[position]; c < rune('{') || c > rune('~') {
						goto l84
					}
					position++
				}
			l86:
				add(rulesignsWithoutHyphenUnderscore, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 15 bracketChildIdentifier <- <(bracketNodeIdentifier (sep bracketNodeIdentifier Action11)* !sep)> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				if !_rules[rulebracketNodeIdentifier]() {
					goto l93
				}
			l95:
				{
					position96, tokenIndex96 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l96
					}
					if !_rules[rulebracketNodeIdentifier]() {
						goto l96
					}
					if !_rules[ruleAction11]() {
						goto l96
					}
					goto l95
				l96:
					position, tokenIndex = position96, tokenIndex96
				}
				{
					position97, tokenIndex97 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l97
					}
					goto l93
				l97:
					position, tokenIndex = position97, tokenIndex97
				}
				add(rulebracketChildIdentifier, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 16 bracketNodeIdentifier <- <(wildcardIdentifier / singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier)> */
		func() bool {
			position98, tokenIndex98 := position, tokenIndex
			{
				position99 := position
				{
					position100, tokenIndex100 := position, tokenIndex
					if !_rules[rulewildcardIdentifier]() {
						goto l101
					}
					goto l100
				l101:
					position, tokenIndex = position100, tokenIndex100
					if !_rules[rulesingleQuotedNodeIdentifier]() {
						goto l102
					}
					goto l100
				l102:
					position, tokenIndex = position100, tokenIndex100
					if !_rules[ruledoubleQuotedNodeIdentifier]() {
						goto l98
					}
				}
			l100:
				add(rulebracketNodeIdentifier, position99)
			}
			return true
		l98:
			position, tokenIndex = position98, tokenIndex98
			return false
		},
		/* 17 wildcardIdentifier <- <('*' Action12)> */
		func() bool {
			position103, tokenIndex103 := position, tokenIndex
			{
				position104 := position
				if buffer[position] != rune('*') {
					goto l103
				}
				position++
				if !_rules[ruleAction12]() {
					goto l103
				}
				add(rulewildcardIdentifier, position104)
			}
			return true
		l103:
			position, tokenIndex = position103, tokenIndex103
			return false
		},
		/* 18 singleQuotedNodeIdentifier <- <('\'' <(('\\' ('\'' / '/' / '\\' / 'b' / 'f' / 'n' / 'r' / 't' / hexDigits)) / (!('\'' / '\\') .))*> '\'' Action13)> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				if buffer[position] != rune('\'') {
					goto l105
				}
				position++
				{
					position107 := position
				l108:
					{
						position109, tokenIndex109 := position, tokenIndex
						{
							position110, tokenIndex110 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l111
							}
							position++
							{
								position112, tokenIndex112 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l113
								}
								position++
								goto l112
							l113:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('/') {
									goto l114
								}
								position++
								goto l112
							l114:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('\\') {
									goto l115
								}
								position++
								goto l112
							l115:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('b') {
									goto l116
								}
								position++
								goto l112
							l116:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('f') {
									goto l117
								}
								position++
								goto l112
							l117:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('n') {
									goto l118
								}
								position++
								goto l112
							l118:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('r') {
									goto l119
								}
								position++
								goto l112
							l119:
								position, tokenIndex = position112, tokenIndex112
								if buffer[position] != rune('t') {
									goto l120
								}
								position++
								goto l112
							l120:
								position, tokenIndex = position112, tokenIndex112
								if !_rules[rulehexDigits]() {
									goto l111
								}
							}
						l112:
							goto l110
						l111:
							position, tokenIndex = position110, tokenIndex110
							{
								position121, tokenIndex121 := position, tokenIndex
								{
									position122, tokenIndex122 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l123
									}
									position++
									goto l122
								l123:
									position, tokenIndex = position122, tokenIndex122
									if buffer[position] != rune('\\') {
										goto l121
									}
									position++
								}
							l122:
								goto l109
							l121:
								position, tokenIndex = position121, tokenIndex121
							}
							if !matchDot() {
								goto l109
							}
						}
					l110:
						goto l108
					l109:
						position, tokenIndex = position109, tokenIndex109
					}
					add(rulePegText, position107)
				}
				if buffer[position] != rune('\'') {
					goto l105
				}
				position++
				if !_rules[ruleAction13]() {
					goto l105
				}
				add(rulesingleQuotedNodeIdentifier, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 19 doubleQuotedNodeIdentifier <- <('"' <(('\\' ('"' / '/' / '\\' / 'b' / 'f' / 'n' / 'r' / 't' / hexDigits)) / (!('"' / '\\') .))*> '"' Action14)> */
		func() bool {
			position124, tokenIndex124 := position, tokenIndex
			{
				position125 := position
				if buffer[position] != rune('"') {
					goto l124
				}
				position++
				{
					position126 := position
				l127:
					{
						position128, tokenIndex128 := position, tokenIndex
						{
							position129, tokenIndex129 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l130
							}
							position++
							{
								position131, tokenIndex131 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l132
								}
								position++
								goto l131
							l132:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('/') {
									goto l133
								}
								position++
								goto l131
							l133:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('\\') {
									goto l134
								}
								position++
								goto l131
							l134:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('b') {
									goto l135
								}
								position++
								goto l131
							l135:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('f') {
									goto l136
								}
								position++
								goto l131
							l136:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('n') {
									goto l137
								}
								position++
								goto l131
							l137:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('r') {
									goto l138
								}
								position++
								goto l131
							l138:
								position, tokenIndex = position131, tokenIndex131
								if buffer[position] != rune('t') {
									goto l139
								}
								position++
								goto l131
							l139:
								position, tokenIndex = position131, tokenIndex131
								if !_rules[rulehexDigits]() {
									goto l130
								}
							}
						l131:
							goto l129
						l130:
							position, tokenIndex = position129, tokenIndex129
							{
								position140, tokenIndex140 := position, tokenIndex
								{
									position141, tokenIndex141 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l142
									}
									position++
									goto l141
								l142:
									position, tokenIndex = position141, tokenIndex141
									if buffer[position] != rune('\\') {
										goto l140
									}
									position++
								}
							l141:
								goto l128
							l140:
								position, tokenIndex = position140, tokenIndex140
							}
							if !matchDot() {
								goto l128
							}
						}
					l129:
						goto l127
					l128:
						position, tokenIndex = position128, tokenIndex128
					}
					add(rulePegText, position126)
				}
				if buffer[position] != rune('"') {
					goto l124
				}
				position++
				if !_rules[ruleAction14]() {
					goto l124
				}
				add(ruledoubleQuotedNodeIdentifier, position125)
			}
			return true
		l124:
			position, tokenIndex = position124, tokenIndex124
			return false
		},
		/* 20 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if buffer[position] != rune('u') {
					goto l143
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l143
				}
				if !_rules[rulehexDigit]() {
					goto l143
				}
				if !_rules[rulehexDigit]() {
					goto l143
				}
				if !_rules[rulehexDigit]() {
					goto l143
				}
				add(rulehexDigits, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 21 hexDigit <- <([a-f] / [A-F] / [0-9])> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				{
					position147, tokenIndex147 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('f') {
						goto l148
					}
					position++
					goto l147
				l148:
					position, tokenIndex = position147, tokenIndex147
					if c := buffer[position]; c < rune('A') || c > rune('F') {
						goto l149
					}
					position++
					goto l147
				l149:
					position, tokenIndex = position147, tokenIndex147
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l145
					}
					position++
				}
			l147:
				add(rulehexDigit, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 22 qualifier <- <(union / script / filter)> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				{
					position152, tokenIndex152 := position, tokenIndex
					if !_rules[ruleunion]() {
						goto l153
					}
					goto l152
				l153:
					position, tokenIndex = position152, tokenIndex152
					if !_rules[rulescript]() {
						goto l154
					}
					goto l152
				l154:
					position, tokenIndex = position152, tokenIndex152
					if !_rules[rulefilter]() {
						goto l150
					}
				}
			l152:
				add(rulequalifier, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 23 union <- <(index (sep index Action15)* !sep)> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				if !_rules[ruleindex]() {
					goto l155
				}
			l157:
				{
					position158, tokenIndex158 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l158
					}
					if !_rules[ruleindex]() {
						goto l158
					}
					if !_rules[ruleAction15]() {
						goto l158
					}
					goto l157
				l158:
					position, tokenIndex = position158, tokenIndex158
				}
				{
					position159, tokenIndex159 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l159
					}
					goto l155
				l159:
					position, tokenIndex = position159, tokenIndex159
				}
				add(ruleunion, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 24 index <- <(((slice Action16) / (<indexNumber> Action17) / ('*' Action18)) Action19)> */
		func() bool {
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				{
					position162, tokenIndex162 := position, tokenIndex
					if !_rules[ruleslice]() {
						goto l163
					}
					if !_rules[ruleAction16]() {
						goto l163
					}
					goto l162
				l163:
					position, tokenIndex = position162, tokenIndex162
					{
						position165 := position
						if !_rules[ruleindexNumber]() {
							goto l164
						}
						add(rulePegText, position165)
					}
					if !_rules[ruleAction17]() {
						goto l164
					}
					goto l162
				l164:
					position, tokenIndex = position162, tokenIndex162
					if buffer[position] != rune('*') {
						goto l160
					}
					position++
					if !_rules[ruleAction18]() {
						goto l160
					}
				}
			l162:
				if !_rules[ruleAction19]() {
					goto l160
				}
				add(ruleindex, position161)
			}
			return true
		l160:
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 25 slice <- <(anyIndex sepSlice anyIndex ((sepSlice anyIndex) / (space Action20)))> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				if !_rules[ruleanyIndex]() {
					goto l166
				}
				if !_rules[rulesepSlice]() {
					goto l166
				}
				if !_rules[ruleanyIndex]() {
					goto l166
				}
				{
					position168, tokenIndex168 := position, tokenIndex
					if !_rules[rulesepSlice]() {
						goto l169
					}
					if !_rules[ruleanyIndex]() {
						goto l169
					}
					goto l168
				l169:
					position, tokenIndex = position168, tokenIndex168
					if !_rules[rulespace]() {
						goto l166
					}
					if !_rules[ruleAction20]() {
						goto l166
					}
				}
			l168:
				add(ruleslice, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 26 anyIndex <- <(<indexNumber?> Action21)> */
		func() bool {
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				{
					position172 := position
					{
						position173, tokenIndex173 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l173
						}
						goto l174
					l173:
						position, tokenIndex = position173, tokenIndex173
					}
				l174:
					add(rulePegText, position172)
				}
				if !_rules[ruleAction21]() {
					goto l170
				}
				add(ruleanyIndex, position171)
			}
			return true
		l170:
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 27 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				{
					position177, tokenIndex177 := position, tokenIndex
					{
						position179, tokenIndex179 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l180
						}
						position++
						goto l179
					l180:
						position, tokenIndex = position179, tokenIndex179
						if buffer[position] != rune('+') {
							goto l177
						}
						position++
					}
				l179:
					goto l178
				l177:
					position, tokenIndex = position177, tokenIndex177
				}
			l178:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l175
				}
				position++
			l181:
				{
					position182, tokenIndex182 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l182
					}
					position++
					goto l181
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
				add(ruleindexNumber, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 28 sep <- <(space ',' space)> */
		func() bool {
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				if !_rules[rulespace]() {
					goto l183
				}
				if buffer[position] != rune(',') {
					goto l183
				}
				position++
				if !_rules[rulespace]() {
					goto l183
				}
				add(rulesep, position184)
			}
			return true
		l183:
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 29 sepSlice <- <(space ':' space)> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				if !_rules[rulespace]() {
					goto l185
				}
				if buffer[position] != rune(':') {
					goto l185
				}
				position++
				if !_rules[rulespace]() {
					goto l185
				}
				add(rulesepSlice, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 30 script <- <(scriptStart <command> scriptEnd Action22)> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				if !_rules[rulescriptStart]() {
					goto l187
				}
				{
					position189 := position
					if !_rules[rulecommand]() {
						goto l187
					}
					add(rulePegText, position189)
				}
				if !_rules[rulescriptEnd]() {
					goto l187
				}
				if !_rules[ruleAction22]() {
					goto l187
				}
				add(rulescript, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 31 command <- <(!')' .)+> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					if buffer[position] != rune(')') {
						goto l194
					}
					position++
					goto l190
				l194:
					position, tokenIndex = position194, tokenIndex194
				}
				if !matchDot() {
					goto l190
				}
			l192:
				{
					position193, tokenIndex193 := position, tokenIndex
					{
						position195, tokenIndex195 := position, tokenIndex
						if buffer[position] != rune(')') {
							goto l195
						}
						position++
						goto l193
					l195:
						position, tokenIndex = position195, tokenIndex195
					}
					if !matchDot() {
						goto l193
					}
					goto l192
				l193:
					position, tokenIndex = position193, tokenIndex193
				}
				add(rulecommand, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 32 filter <- <(filterStart query filterEnd Action23)> */
		func() bool {
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				if !_rules[rulefilterStart]() {
					goto l196
				}
				if !_rules[rulequery]() {
					goto l196
				}
				if !_rules[rulefilterEnd]() {
					goto l196
				}
				if !_rules[ruleAction23]() {
					goto l196
				}
				add(rulefilter, position197)
			}
			return true
		l196:
			position, tokenIndex = position196, tokenIndex196
			return false
		},
		/* 33 query <- <(andQuery (logicOr andQuery Action24)*)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if !_rules[ruleandQuery]() {
					goto l198
				}
			l200:
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[rulelogicOr]() {
						goto l201
					}
					if !_rules[ruleandQuery]() {
						goto l201
					}
					if !_rules[ruleAction24]() {
						goto l201
					}
					goto l200
				l201:
					position, tokenIndex = position201, tokenIndex201
				}
				add(rulequery, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 34 andQuery <- <(basicQuery (logicAnd basicQuery Action25)*)> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				if !_rules[rulebasicQuery]() {
					goto l202
				}
			l204:
				{
					position205, tokenIndex205 := position, tokenIndex
					if !_rules[rulelogicAnd]() {
						goto l205
					}
					if !_rules[rulebasicQuery]() {
						goto l205
					}
					if !_rules[ruleAction25]() {
						goto l205
					}
					goto l204
				l205:
					position, tokenIndex = position205, tokenIndex205
				}
				add(ruleandQuery, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 35 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action26) / (<(logicNot? jsonpathFilter)> Action27))> */
		func() bool {
			position206, tokenIndex206 := position, tokenIndex
			{
				position207 := position
				{
					position208, tokenIndex208 := position, tokenIndex
					if !_rules[rulesubQueryStart]() {
						goto l209
					}
					if !_rules[rulequery]() {
						goto l209
					}
					if !_rules[rulesubQueryEnd]() {
						goto l209
					}
					goto l208
				l209:
					position, tokenIndex = position208, tokenIndex208
					{
						position211 := position
						if !_rules[rulecomparator]() {
							goto l210
						}
						add(rulePegText, position211)
					}
					if !_rules[ruleAction26]() {
						goto l210
					}
					goto l208
				l210:
					position, tokenIndex = position208, tokenIndex208
					{
						position212 := position
						{
							position213, tokenIndex213 := position, tokenIndex
							if !_rules[rulelogicNot]() {
								goto l213
							}
							goto l214
						l213:
							position, tokenIndex = position213, tokenIndex213
						}
					l214:
						if !_rules[rulejsonpathFilter]() {
							goto l206
						}
						add(rulePegText, position212)
					}
					if !_rules[ruleAction27]() {
						goto l206
					}
				}
			l208:
				add(rulebasicQuery, position207)
			}
			return true
		l206:
			position, tokenIndex = position206, tokenIndex206
			return false
		},
		/* 36 logicOr <- <(space ('|' '|') space)> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if !_rules[rulespace]() {
					goto l215
				}
				if buffer[position] != rune('|') {
					goto l215
				}
				position++
				if buffer[position] != rune('|') {
					goto l215
				}
				position++
				if !_rules[rulespace]() {
					goto l215
				}
				add(rulelogicOr, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 37 logicAnd <- <(space ('&' '&') space)> */
		func() bool {
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				if !_rules[rulespace]() {
					goto l217
				}
				if buffer[position] != rune('&') {
					goto l217
				}
				position++
				if buffer[position] != rune('&') {
					goto l217
				}
				position++
				if !_rules[rulespace]() {
					goto l217
				}
				add(rulelogicAnd, position218)
			}
			return true
		l217:
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 38 logicNot <- <('!' space)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if buffer[position] != rune('!') {
					goto l219
				}
				position++
				if !_rules[rulespace]() {
					goto l219
				}
				add(rulelogicNot, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 39 comparator <- <((qParam space (('=' '=' space qParam Action28) / ('!' '=' space qParam Action29))) / (qNumericParam space (('<' '=' space qNumericParam Action30) / ('<' space qNumericParam Action31) / ('>' '=' space qNumericParam Action32) / ('>' space qNumericParam Action33))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action34))> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				{
					position223, tokenIndex223 := position, tokenIndex
					if !_rules[ruleqParam]() {
						goto l224
					}
					if !_rules[rulespace]() {
						goto l224
					}
					{
						position225, tokenIndex225 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l226
						}
						position++
						if buffer[position] != rune('=') {
							goto l226
						}
						position++
						if !_rules[rulespace]() {
							goto l226
						}
						if !_rules[ruleqParam]() {
							goto l226
						}
						if !_rules[ruleAction28]() {
							goto l226
						}
						goto l225
					l226:
						position, tokenIndex = position225, tokenIndex225
						if buffer[position] != rune('!') {
							goto l224
						}
						position++
						if buffer[position] != rune('=') {
							goto l224
						}
						position++
						if !_rules[rulespace]() {
							goto l224
						}
						if !_rules[ruleqParam]() {
							goto l224
						}
						if !_rules[ruleAction29]() {
							goto l224
						}
					}
				l225:
					goto l223
				l224:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[ruleqNumericParam]() {
						goto l227
					}
					if !_rules[rulespace]() {
						goto l227
					}
					{
						position228, tokenIndex228 := position, tokenIndex
						if buffer[position] != rune('<') {
							goto l229
						}
						position++
						if buffer[position] != rune('=') {
							goto l229
						}
						position++
						if !_rules[rulespace]() {
							goto l229
						}
						if !_rules[ruleqNumericParam]() {
							goto l229
						}
						if !_rules[ruleAction30]() {
							goto l229
						}
						goto l228
					l229:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('<') {
							goto l230
						}
						position++
						if !_rules[rulespace]() {
							goto l230
						}
						if !_rules[ruleqNumericParam]() {
							goto l230
						}
						if !_rules[ruleAction31]() {
							goto l230
						}
						goto l228
					l230:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('>') {
							goto l231
						}
						position++
						if buffer[position] != rune('=') {
							goto l231
						}
						position++
						if !_rules[rulespace]() {
							goto l231
						}
						if !_rules[ruleqNumericParam]() {
							goto l231
						}
						if !_rules[ruleAction32]() {
							goto l231
						}
						goto l228
					l231:
						position, tokenIndex = position228, tokenIndex228
						if buffer[position] != rune('>') {
							goto l227
						}
						position++
						if !_rules[rulespace]() {
							goto l227
						}
						if !_rules[ruleqNumericParam]() {
							goto l227
						}
						if !_rules[ruleAction33]() {
							goto l227
						}
					}
				l228:
					goto l223
				l227:
					position, tokenIndex = position223, tokenIndex223
					if !_rules[rulesingleJsonpathFilter]() {
						goto l221
					}
					if !_rules[rulespace]() {
						goto l221
					}
					if buffer[position] != rune('=') {
						goto l221
					}
					position++
					if buffer[position] != rune('~') {
						goto l221
					}
					position++
					if !_rules[rulespace]() {
						goto l221
					}
					if buffer[position] != rune('/') {
						goto l221
					}
					position++
					{
						position232 := position
						if !_rules[ruleregex]() {
							goto l221
						}
						add(rulePegText, position232)
					}
					if buffer[position] != rune('/') {
						goto l221
					}
					position++
					if !_rules[ruleAction34]() {
						goto l221
					}
				}
			l223:
				add(rulecomparator, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 40 qParam <- <((qLiteral Action35) / singleJsonpathFilter)> */
		func() bool {
			position233, tokenIndex233 := position, tokenIndex
			{
				position234 := position
				{
					position235, tokenIndex235 := position, tokenIndex
					if !_rules[ruleqLiteral]() {
						goto l236
					}
					if !_rules[ruleAction35]() {
						goto l236
					}
					goto l235
				l236:
					position, tokenIndex = position235, tokenIndex235
					if !_rules[rulesingleJsonpathFilter]() {
						goto l233
					}
				}
			l235:
				add(ruleqParam, position234)
			}
			return true
		l233:
			position, tokenIndex = position233, tokenIndex233
			return false
		},
		/* 41 qNumericParam <- <((lNumber Action36) / singleJsonpathFilter)> */
		func() bool {
			position237, tokenIndex237 := position, tokenIndex
			{
				position238 := position
				{
					position239, tokenIndex239 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l240
					}
					if !_rules[ruleAction36]() {
						goto l240
					}
					goto l239
				l240:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[rulesingleJsonpathFilter]() {
						goto l237
					}
				}
			l239:
				add(ruleqNumericParam, position238)
			}
			return true
		l237:
			position, tokenIndex = position237, tokenIndex237
			return false
		},
		/* 42 qLiteral <- <(lNumber / lBool / lString / lNull)> */
		func() bool {
			position241, tokenIndex241 := position, tokenIndex
			{
				position242 := position
				{
					position243, tokenIndex243 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l244
					}
					goto l243
				l244:
					position, tokenIndex = position243, tokenIndex243
					if !_rules[rulelBool]() {
						goto l245
					}
					goto l243
				l245:
					position, tokenIndex = position243, tokenIndex243
					if !_rules[rulelString]() {
						goto l246
					}
					goto l243
				l246:
					position, tokenIndex = position243, tokenIndex243
					if !_rules[rulelNull]() {
						goto l241
					}
				}
			l243:
				add(ruleqLiteral, position242)
			}
			return true
		l241:
			position, tokenIndex = position241, tokenIndex241
			return false
		},
		/* 43 singleJsonpathFilter <- <(<jsonpathFilter> Action37)> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				{
					position249 := position
					if !_rules[rulejsonpathFilter]() {
						goto l247
					}
					add(rulePegText, position249)
				}
				if !_rules[ruleAction37]() {
					goto l247
				}
				add(rulesingleJsonpathFilter, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 44 jsonpathFilter <- <(Action38 jsonpathParameter Action39)> */
		func() bool {
			position250, tokenIndex250 := position, tokenIndex
			{
				position251 := position
				if !_rules[ruleAction38]() {
					goto l250
				}
				if !_rules[rulejsonpathParameter]() {
					goto l250
				}
				if !_rules[ruleAction39]() {
					goto l250
				}
				add(rulejsonpathFilter, position251)
			}
			return true
		l250:
			position, tokenIndex = position250, tokenIndex250
			return false
		},
		/* 45 lNumber <- <(<(('-' / '+')? [0-9] ('-' / '+' / '.' / [0-9] / [a-z] / [A-Z])*)> Action40)> */
		func() bool {
			position252, tokenIndex252 := position, tokenIndex
			{
				position253 := position
				{
					position254 := position
					{
						position255, tokenIndex255 := position, tokenIndex
						{
							position257, tokenIndex257 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l258
							}
							position++
							goto l257
						l258:
							position, tokenIndex = position257, tokenIndex257
							if buffer[position] != rune('+') {
								goto l255
							}
							position++
						}
					l257:
						goto l256
					l255:
						position, tokenIndex = position255, tokenIndex255
					}
				l256:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l252
					}
					position++
				l259:
					{
						position260, tokenIndex260 := position, tokenIndex
						{
							position261, tokenIndex261 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l262
							}
							position++
							goto l261
						l262:
							position, tokenIndex = position261, tokenIndex261
							if buffer[position] != rune('+') {
								goto l263
							}
							position++
							goto l261
						l263:
							position, tokenIndex = position261, tokenIndex261
							if buffer[position] != rune('.') {
								goto l264
							}
							position++
							goto l261
						l264:
							position, tokenIndex = position261, tokenIndex261
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l265
							}
							position++
							goto l261
						l265:
							position, tokenIndex = position261, tokenIndex261
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l266
							}
							position++
							goto l261
						l266:
							position, tokenIndex = position261, tokenIndex261
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l260
							}
							position++
						}
					l261:
						goto l259
					l260:
						position, tokenIndex = position260, tokenIndex260
					}
					add(rulePegText, position254)
				}
				if !_rules[ruleAction40]() {
					goto l252
				}
				add(rulelNumber, position253)
			}
			return true
		l252:
			position, tokenIndex = position252, tokenIndex252
			return false
		},
		/* 46 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action41) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action42))> */
		func() bool {
			position267, tokenIndex267 := position, tokenIndex
			{
				position268 := position
				{
					position269, tokenIndex269 := position, tokenIndex
					{
						position271, tokenIndex271 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l272
						}
						position++
						if buffer[position] != rune('r') {
							goto l272
						}
						position++
						if buffer[position] != rune('u') {
							goto l272
						}
						position++
						if buffer[position] != rune('e') {
							goto l272
						}
						position++
						goto l271
					l272:
						position, tokenIndex = position271, tokenIndex271
						if buffer[position] != rune('T') {
							goto l273
						}
						position++
						if buffer[position] != rune('r') {
							goto l273
						}
						position++
						if buffer[position] != rune('u') {
							goto l273
						}
						position++
						if buffer[position] != rune('e') {
							goto l273
						}
						position++
						goto l271
					l273:
						position, tokenIndex = position271, tokenIndex271
						if buffer[position] != rune('T') {
							goto l270
						}
						position++
						if buffer[position] != rune('R') {
							goto l270
						}
						position++
						if buffer[position] != rune('U') {
							goto l270
						}
						position++
						if buffer[position] != rune('E') {
							goto l270
						}
						position++
					}
				l271:
					if !_rules[ruleAction41]() {
						goto l270
					}
					goto l269
				l270:
					position, tokenIndex = position269, tokenIndex269
					{
						position274, tokenIndex274 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l275
						}
						position++
						if buffer[position] != rune('a') {
							goto l275
						}
						position++
						if buffer[position] != rune('l') {
							goto l275
						}
						position++
						if buffer[position] != rune('s') {
							goto l275
						}
						position++
						if buffer[position] != rune('e') {
							goto l275
						}
						position++
						goto l274
					l275:
						position, tokenIndex = position274, tokenIndex274
						if buffer[position] != rune('F') {
							goto l276
						}
						position++
						if buffer[position] != rune('a') {
							goto l276
						}
						position++
						if buffer[position] != rune('l') {
							goto l276
						}
						position++
						if buffer[position] != rune('s') {
							goto l276
						}
						position++
						if buffer[position] != rune('e') {
							goto l276
						}
						position++
						goto l274
					l276:
						position, tokenIndex = position274, tokenIndex274
						if buffer[position] != rune('F') {
							goto l267
						}
						position++
						if buffer[position] != rune('A') {
							goto l267
						}
						position++
						if buffer[position] != rune('L') {
							goto l267
						}
						position++
						if buffer[position] != rune('S') {
							goto l267
						}
						position++
						if buffer[position] != rune('E') {
							goto l267
						}
						position++
					}
				l274:
					if !_rules[ruleAction42]() {
						goto l267
					}
				}
			l269:
				add(rulelBool, position268)
			}
			return true
		l267:
			position, tokenIndex = position267, tokenIndex267
			return false
		},
		/* 47 lString <- <(('\'' <(('\\' '\\') / ('\\' '\'') / (!'\'' .))*> '\'' Action43) / ('"' <(('\\' '\\') / ('\\' '"') / (!'"' .))*> '"' Action44))> */
		func() bool {
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				{
					position279, tokenIndex279 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l280
					}
					position++
					{
						position281 := position
					l282:
						{
							position283, tokenIndex283 := position, tokenIndex
							{
								position284, tokenIndex284 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l285
								}
								position++
								if buffer[position] != rune('\\') {
									goto l285
								}
								position++
								goto l284
							l285:
								position, tokenIndex = position284, tokenIndex284
								if buffer[position] != rune('\\') {
									goto l286
								}
								position++
								if buffer[position] != rune('\'') {
									goto l286
								}
								position++
								goto l284
							l286:
								position, tokenIndex = position284, tokenIndex284
								{
									position287, tokenIndex287 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l287
									}
									position++
									goto l283
								l287:
									position, tokenIndex = position287, tokenIndex287
								}
								if !matchDot() {
									goto l283
								}
							}
						l284:
							goto l282
						l283:
							position, tokenIndex = position283, tokenIndex283
						}
						add(rulePegText, position281)
					}
					if buffer[position] != rune('\'') {
						goto l280
					}
					position++
					if !_rules[ruleAction43]() {
						goto l280
					}
					goto l279
				l280:
					position, tokenIndex = position279, tokenIndex279
					if buffer[position] != rune('"') {
						goto l277
					}
					position++
					{
						position288 := position
					l289:
						{
							position290, tokenIndex290 := position, tokenIndex
							{
								position291, tokenIndex291 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l292
								}
								position++
								if buffer[position] != rune('\\') {
									goto l292
								}
								position++
								goto l291
							l292:
								position, tokenIndex = position291, tokenIndex291
								if buffer[position] != rune('\\') {
									goto l293
								}
								position++
								if buffer[position] != rune('"') {
									goto l293
								}
								position++
								goto l291
							l293:
								position, tokenIndex = position291, tokenIndex291
								{
									position294, tokenIndex294 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l294
									}
									position++
									goto l290
								l294:
									position, tokenIndex = position294, tokenIndex294
								}
								if !matchDot() {
									goto l290
								}
							}
						l291:
							goto l289
						l290:
							position, tokenIndex = position290, tokenIndex290
						}
						add(rulePegText, position288)
					}
					if buffer[position] != rune('"') {
						goto l277
					}
					position++
					if !_rules[ruleAction44]() {
						goto l277
					}
				}
			l279:
				add(rulelString, position278)
			}
			return true
		l277:
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 48 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action45)> */
		func() bool {
			position295, tokenIndex295 := position, tokenIndex
			{
				position296 := position
				{
					position297, tokenIndex297 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l298
					}
					position++
					if buffer[position] != rune('u') {
						goto l298
					}
					position++
					if buffer[position] != rune('l') {
						goto l298
					}
					position++
					if buffer[position] != rune('l') {
						goto l298
					}
					position++
					goto l297
				l298:
					position, tokenIndex = position297, tokenIndex297
					if buffer[position] != rune('N') {
						goto l299
					}
					position++
					if buffer[position] != rune('u') {
						goto l299
					}
					position++
					if buffer[position] != rune('l') {
						goto l299
					}
					position++
					if buffer[position] != rune('l') {
						goto l299
					}
					position++
					goto l297
				l299:
					position, tokenIndex = position297, tokenIndex297
					if buffer[position] != rune('N') {
						goto l295
					}
					position++
					if buffer[position] != rune('U') {
						goto l295
					}
					position++
					if buffer[position] != rune('L') {
						goto l295
					}
					position++
					if buffer[position] != rune('L') {
						goto l295
					}
					position++
				}
			l297:
				if !_rules[ruleAction45]() {
					goto l295
				}
				add(rulelNull, position296)
			}
			return true
		l295:
			position, tokenIndex = position295, tokenIndex295
			return false
		},
		/* 49 regex <- <(('\\' '\\') / ('\\' '/') / (!'/' .))*> */
		func() bool {
			{
				position301 := position
			l302:
				{
					position303, tokenIndex303 := position, tokenIndex
					{
						position304, tokenIndex304 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l305
						}
						position++
						if buffer[position] != rune('\\') {
							goto l305
						}
						position++
						goto l304
					l305:
						position, tokenIndex = position304, tokenIndex304
						if buffer[position] != rune('\\') {
							goto l306
						}
						position++
						if buffer[position] != rune('/') {
							goto l306
						}
						position++
						goto l304
					l306:
						position, tokenIndex = position304, tokenIndex304
						{
							position307, tokenIndex307 := position, tokenIndex
							if buffer[position] != rune('/') {
								goto l307
							}
							position++
							goto l303
						l307:
							position, tokenIndex = position307, tokenIndex307
						}
						if !matchDot() {
							goto l303
						}
					}
				l304:
					goto l302
				l303:
					position, tokenIndex = position303, tokenIndex303
				}
				add(ruleregex, position301)
			}
			return true
		},
		/* 50 squareBracketStart <- <('[' space)> */
		func() bool {
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				if buffer[position] != rune('[') {
					goto l308
				}
				position++
				if !_rules[rulespace]() {
					goto l308
				}
				add(rulesquareBracketStart, position309)
			}
			return true
		l308:
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 51 squareBracketEnd <- <(space ']')> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if !_rules[rulespace]() {
					goto l310
				}
				if buffer[position] != rune(']') {
					goto l310
				}
				position++
				add(rulesquareBracketEnd, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 52 scriptStart <- <('(' space)> */
		func() bool {
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				if buffer[position] != rune('(') {
					goto l312
				}
				position++
				if !_rules[rulespace]() {
					goto l312
				}
				add(rulescriptStart, position313)
			}
			return true
		l312:
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 53 scriptEnd <- <(space ')')> */
		func() bool {
			position314, tokenIndex314 := position, tokenIndex
			{
				position315 := position
				if !_rules[rulespace]() {
					goto l314
				}
				if buffer[position] != rune(')') {
					goto l314
				}
				position++
				add(rulescriptEnd, position315)
			}
			return true
		l314:
			position, tokenIndex = position314, tokenIndex314
			return false
		},
		/* 54 filterStart <- <('?' '(' space)> */
		func() bool {
			position316, tokenIndex316 := position, tokenIndex
			{
				position317 := position
				if buffer[position] != rune('?') {
					goto l316
				}
				position++
				if buffer[position] != rune('(') {
					goto l316
				}
				position++
				if !_rules[rulespace]() {
					goto l316
				}
				add(rulefilterStart, position317)
			}
			return true
		l316:
			position, tokenIndex = position316, tokenIndex316
			return false
		},
		/* 55 filterEnd <- <(space ')')> */
		func() bool {
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if !_rules[rulespace]() {
					goto l318
				}
				if buffer[position] != rune(')') {
					goto l318
				}
				position++
				add(rulefilterEnd, position319)
			}
			return true
		l318:
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 56 subQueryStart <- <('(' space)> */
		func() bool {
			position320, tokenIndex320 := position, tokenIndex
			{
				position321 := position
				if buffer[position] != rune('(') {
					goto l320
				}
				position++
				if !_rules[rulespace]() {
					goto l320
				}
				add(rulesubQueryStart, position321)
			}
			return true
		l320:
			position, tokenIndex = position320, tokenIndex320
			return false
		},
		/* 57 subQueryEnd <- <(space ')')> */
		func() bool {
			position322, tokenIndex322 := position, tokenIndex
			{
				position323 := position
				if !_rules[rulespace]() {
					goto l322
				}
				if buffer[position] != rune(')') {
					goto l322
				}
				position++
				add(rulesubQueryEnd, position323)
			}
			return true
		l322:
			position, tokenIndex = position322, tokenIndex322
			return false
		},
		/* 58 space <- <' '*> */
		func() bool {
			{
				position325 := position
			l326:
				{
					position327, tokenIndex327 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l327
					}
					position++
					goto l326
				l327:
					position, tokenIndex = position327, tokenIndex327
				}
				add(rulespace, position325)
			}
			return true
		},
		/* 60 Action0 <- <{
		    p.root = p.deleteRootIdentifier(p.pop().(syntaxNode))
		    p.setConnectedText(p.root)
		}> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		nil,
		/* 62 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 63 Action2 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 64 Action3 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 65 Action4 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 66 Action5 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 67 Action6 <- <{
		    p.push(text)
		}> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 68 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 69 Action8 <- <{
		    p.pushRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 70 Action9 <- <{
		    p.pushCurrentRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 71 Action10 <- <{ //`
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 72 Action11 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 73 Action12 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 74 Action13 <- <{
		    p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))
		}> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 75 Action14 <- <{ // '
		    p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))
		}> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 76 Action15 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 77 Action16 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted || step.number == 0 {
		        step.number = 1
		    }

		    if step.number > 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 78 Action17 <- <{
		    p.pushIndexSubscript(text)
		}> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 79 Action18 <- <{
		    p.pushWildcardSubscript()
		}> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 80 Action19 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 81 Action20 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 82 Action21 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 83 Action22 <- <{
		    p.pushScriptQualifier(text)
		}> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 84 Action23 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 85 Action24 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 86 Action25 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 87 Action26 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		        _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
		        _, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
		        if leftIsCurrentRoot && rigthIsCurrentRoot {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 88 Action27 <- <{
		    _ = p.pop()
		    jsonpathFilter := p.pop().(syntaxQuery)
		    if text[0:1] == `!` {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 89 Action28 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 90 Action29 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 91 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 92 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 93 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 94 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 95 Action34 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 96 Action35 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		/* 97 Action36 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 98 Action37 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 99 Action38 <- <{
		    p.saveParams()
		}> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 100 Action39 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootIdentifier(node))
		        p.push(true)
		    case *syntaxCurrentRootIdentifier:
		        p.pushCompareParameterCurrentRoot(p.deleteRootIdentifier(node))
		        p.push(false)
		    }
		}> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 101 Action40 <- <{
		    p.push(p.toFloat(text))
		}> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 102 Action41 <- <{
		    p.push(true)
		}> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 103 Action42 <- <{
		    p.push(false)
		}> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 104 Action43 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		/* 105 Action44 <- <{ // '
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 106 Action45 <- <{
		    p.push(nil)
		}> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
