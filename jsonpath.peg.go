package jsonpath

// Code generated by C:\Users\prome\go\bin\peg.exe jsonpath.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpath
	rulejsonpathParameter
	rulecontinuedJsonpath
	rulerootNode
	ruleparameterRootNode
	rulechildNode
	rulefunction
	rulefunctionName
	rulebracketNode
	rulerootIdentifier
	rulecurrentRootIdentifier
	rulewildcard
	ruledotChildIdentifier
	rulebracketChildIdentifier
	rulebracketNodeIdentifiers
	rulebracketNodeIdentifier
	rulesingleQuotedNodeIdentifier
	ruledoubleQuotedNodeIdentifier
	rulesepBracketIdentifier
	rulequalifier
	ruleunion
	ruleindex
	ruleslice
	ruleanyIndex
	ruleindexNumber
	rulesepUnion
	rulesepSlice
	rulescript
	rulecommand
	rulefilter
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptStart
	rulescriptEnd
	rulefilterStart
	rulefilterEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpath",
	"jsonpathParameter",
	"continuedJsonpath",
	"rootNode",
	"parameterRootNode",
	"childNode",
	"function",
	"functionName",
	"bracketNode",
	"rootIdentifier",
	"currentRootIdentifier",
	"wildcard",
	"dotChildIdentifier",
	"bracketChildIdentifier",
	"bracketNodeIdentifiers",
	"bracketNodeIdentifier",
	"singleQuotedNodeIdentifier",
	"doubleQuotedNodeIdentifier",
	"sepBracketIdentifier",
	"qualifier",
	"union",
	"index",
	"slice",
	"anyIndex",
	"indexNumber",
	"sepUnion",
	"sepSlice",
	"script",
	"command",
	"filter",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptStart",
	"scriptEnd",
	"filterStart",
	"filterEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer string
	buffer []rune
	rules  [107]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.pop().(syntaxNode)

		case ruleAction1:

			p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)

		case ruleAction2:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction3:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction4:

			p.setLastNodeText(text)

		case ruleAction5:

			p.pushFunction(text, p.pop().(string))

		case ruleAction6:

			p.push(text)

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.pushRootIdentifier()

		case ruleAction9:

			p.pushCurrentRootIdentifier()

		case ruleAction10:

			p.pushChildWildcardIdentifier()

		case ruleAction11:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction12:

			identifier := p.pop().([]string)
			if len(identifier) > 1 {
				p.pushChildMultiIdentifier(identifier)
			} else {
				p.pushChildSingleIdentifier(identifier[0])
			}

		case ruleAction13:

			identifier2 := p.pop().([]string)
			identifier1 := p.pop().([]string)
			p.push(append(identifier1, identifier2...))

		case ruleAction14:

			p.push([]string{p.pop().(string)})

		case ruleAction15:

			p.push(p.unescape(text))

		case ruleAction16:
			// '
			p.push(p.unescape(text))

		case ruleAction17:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction18:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted || step.number == 0 {
				step.number = 1
			}

			if step.number > 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction19:

			p.pushIndexSubscript(text)

		case ruleAction20:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction21:

			p.pushIndexSubscript(`1`)

		case ruleAction22:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction23:

			p.pushScriptQualifier(text)

		case ruleAction24:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction25:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction26:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction27:

			if !p.hasErr() {
				query := p.pop().(syntaxQuery)
				p.push(query)

				if logicalNot, ok := query.(*syntaxLogicalNot); ok {
					query = (*logicalNot).query
				}
				if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
					_, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
					_, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
					if leftIsCurrentRoot && rigthIsCurrentRoot {
						p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
					}
				}
			}

		case ruleAction28:

			_ = p.pop().(bool)
			jsonpathFilter := p.pop().(syntaxQuery)
			if text[0:1] == `!` {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction29:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction34:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction35:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction36:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction37:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction38:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if !p.hasErr() && param.isValueGroupParameter() {
				p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction39:

			p.saveParams()

		case ruleAction40:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootIdentifier:
				p.pushCompareParameterRoot(node)
				p.push(true)
			case *syntaxCurrentRootIdentifier:
				p.pushCompareParameterCurrentRoot(node)
				p.push(false)
			default:
				p.push(&syntaxQueryParamRoot{})
				p.push(true)
			}

		case ruleAction41:

			p.push(p.toFloat(text))

		case ruleAction42:

			p.push(true)

		case ruleAction43:

			p.push(false)

		case ruleAction44:

			p.push(p.unescape(text))

		case ruleAction45:
			// '
			p.push(p.unescape(text))

		case ruleAction46:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <((jsonpath END Action0) / (jsonpath? <.*> END Action1))> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[rulejsonpath]() {
						goto l3
					}
					if !_rules[ruleEND]() {
						goto l3
					}
					if !_rules[ruleAction0]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpath]() {
							goto l4
						}
						goto l5
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
				l5:
					{
						position6 := position
					l7:
						{
							position8, tokenIndex8 := position, tokenIndex
							if !matchDot() {
								goto l8
							}
							goto l7
						l8:
							position, tokenIndex = position8, tokenIndex8
						}
						add(rulePegText, position6)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					if !_rules[ruleAction1]() {
						goto l0
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position11, tokenIndex11 := position, tokenIndex
					if !matchDot() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position11, tokenIndex11
				}
				add(ruleEND, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 2 jsonpath <- <(space rootNode continuedJsonpath)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[rulespace]() {
					goto l12
				}
				if !_rules[rulerootNode]() {
					goto l12
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l12
				}
				add(rulejsonpath, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 jsonpathParameter <- <(space parameterRootNode continuedJsonpath)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[rulespace]() {
					goto l14
				}
				if !_rules[ruleparameterRootNode]() {
					goto l14
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l14
				}
				add(rulejsonpathParameter, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 4 continuedJsonpath <- <(childNode* function* space Action2)> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
			l18:
				{
					position19, tokenIndex19 := position, tokenIndex
					if !_rules[rulechildNode]() {
						goto l19
					}
					goto l18
				l19:
					position, tokenIndex = position19, tokenIndex19
				}
			l20:
				{
					position21, tokenIndex21 := position, tokenIndex
					if !_rules[rulefunction]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position21, tokenIndex21
				}
				if !_rules[rulespace]() {
					goto l16
				}
				if !_rules[ruleAction2]() {
					goto l16
				}
				add(rulecontinuedJsonpath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 5 rootNode <- <(rootIdentifier / bracketNode / dotChildIdentifier)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				{
					position24, tokenIndex24 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[rulebracketNode]() {
						goto l26
					}
					goto l24
				l26:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[ruledotChildIdentifier]() {
						goto l22
					}
				}
			l24:
				add(rulerootNode, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 6 parameterRootNode <- <(rootIdentifier / currentRootIdentifier)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l30
					}
					goto l29
				l30:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[rulecurrentRootIdentifier]() {
						goto l27
					}
				}
			l29:
				add(ruleparameterRootNode, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 7 childNode <- <(('.' '.' (wildcard / bracketNode / dotChildIdentifier) Action3) / (<('.' (wildcard / dotChildIdentifier))> Action4) / bracketNode)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				{
					position33, tokenIndex33 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l34
					}
					position++
					if buffer[position] != rune('.') {
						goto l34
					}
					position++
					{
						position35, tokenIndex35 := position, tokenIndex
						if !_rules[rulewildcard]() {
							goto l36
						}
						goto l35
					l36:
						position, tokenIndex = position35, tokenIndex35
						if !_rules[rulebracketNode]() {
							goto l37
						}
						goto l35
					l37:
						position, tokenIndex = position35, tokenIndex35
						if !_rules[ruledotChildIdentifier]() {
							goto l34
						}
					}
				l35:
					if !_rules[ruleAction3]() {
						goto l34
					}
					goto l33
				l34:
					position, tokenIndex = position33, tokenIndex33
					{
						position39 := position
						if buffer[position] != rune('.') {
							goto l38
						}
						position++
						{
							position40, tokenIndex40 := position, tokenIndex
							if !_rules[rulewildcard]() {
								goto l41
							}
							goto l40
						l41:
							position, tokenIndex = position40, tokenIndex40
							if !_rules[ruledotChildIdentifier]() {
								goto l38
							}
						}
					l40:
						add(rulePegText, position39)
					}
					if !_rules[ruleAction4]() {
						goto l38
					}
					goto l33
				l38:
					position, tokenIndex = position33, tokenIndex33
					if !_rules[rulebracketNode]() {
						goto l31
					}
				}
			l33:
				add(rulechildNode, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 8 function <- <(<('.' functionName ('(' ')'))> Action5)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44 := position
					if buffer[position] != rune('.') {
						goto l42
					}
					position++
					if !_rules[rulefunctionName]() {
						goto l42
					}
					if buffer[position] != rune('(') {
						goto l42
					}
					position++
					if buffer[position] != rune(')') {
						goto l42
					}
					position++
					add(rulePegText, position44)
				}
				if !_rules[ruleAction5]() {
					goto l42
				}
				add(rulefunction, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 functionName <- <(<('-' / '_' / [a-z] / [A-Z])+> Action6)> */
		func() bool {
			position45, tokenIndex45 := position, tokenIndex
			{
				position46 := position
				{
					position47 := position
					{
						position50, tokenIndex50 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l51
						}
						position++
						goto l50
					l51:
						position, tokenIndex = position50, tokenIndex50
						if buffer[position] != rune('_') {
							goto l52
						}
						position++
						goto l50
					l52:
						position, tokenIndex = position50, tokenIndex50
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l53
						}
						position++
						goto l50
					l53:
						position, tokenIndex = position50, tokenIndex50
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l45
						}
						position++
					}
				l50:
				l48:
					{
						position49, tokenIndex49 := position, tokenIndex
						{
							position54, tokenIndex54 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l55
							}
							position++
							goto l54
						l55:
							position, tokenIndex = position54, tokenIndex54
							if buffer[position] != rune('_') {
								goto l56
							}
							position++
							goto l54
						l56:
							position, tokenIndex = position54, tokenIndex54
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l57
							}
							position++
							goto l54
						l57:
							position, tokenIndex = position54, tokenIndex54
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l49
							}
							position++
						}
					l54:
						goto l48
					l49:
						position, tokenIndex = position49, tokenIndex49
					}
					add(rulePegText, position47)
				}
				if !_rules[ruleAction6]() {
					goto l45
				}
				add(rulefunctionName, position46)
			}
			return true
		l45:
			position, tokenIndex = position45, tokenIndex45
			return false
		},
		/* 10 bracketNode <- <(<(squareBracketStart (wildcard / bracketChildIdentifier / qualifier) squareBracketEnd)> Action7)> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				{
					position60 := position
					if !_rules[rulesquareBracketStart]() {
						goto l58
					}
					{
						position61, tokenIndex61 := position, tokenIndex
						if !_rules[rulewildcard]() {
							goto l62
						}
						goto l61
					l62:
						position, tokenIndex = position61, tokenIndex61
						if !_rules[rulebracketChildIdentifier]() {
							goto l63
						}
						goto l61
					l63:
						position, tokenIndex = position61, tokenIndex61
						if !_rules[rulequalifier]() {
							goto l58
						}
					}
				l61:
					if !_rules[rulesquareBracketEnd]() {
						goto l58
					}
					add(rulePegText, position60)
				}
				if !_rules[ruleAction7]() {
					goto l58
				}
				add(rulebracketNode, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 11 rootIdentifier <- <('$' Action8)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if buffer[position] != rune('$') {
					goto l64
				}
				position++
				if !_rules[ruleAction8]() {
					goto l64
				}
				add(rulerootIdentifier, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 12 currentRootIdentifier <- <('@' Action9)> */
		func() bool {
			position66, tokenIndex66 := position, tokenIndex
			{
				position67 := position
				if buffer[position] != rune('@') {
					goto l66
				}
				position++
				if !_rules[ruleAction9]() {
					goto l66
				}
				add(rulecurrentRootIdentifier, position67)
			}
			return true
		l66:
			position, tokenIndex = position66, tokenIndex66
			return false
		},
		/* 13 wildcard <- <('*' Action10)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if buffer[position] != rune('*') {
					goto l68
				}
				position++
				if !_rules[ruleAction10]() {
					goto l68
				}
				add(rulewildcard, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 14 dotChildIdentifier <- <(<(('\\' '\\') / ('\\' ('.' / '[' / '(' / ')' / '=' / '!' / '>' / '<' / '\t' / '\r' / '\n' / ' ')) / (!('\\' / '.' / '[' / '(' / ')' / '=' / '!' / '>' / '<' / '\t' / '\r' / '\n' / ' ') .))+> !('(' ')') Action11)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				{
					position72 := position
					{
						position75, tokenIndex75 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l76
						}
						position++
						if buffer[position] != rune('\\') {
							goto l76
						}
						position++
						goto l75
					l76:
						position, tokenIndex = position75, tokenIndex75
						if buffer[position] != rune('\\') {
							goto l77
						}
						position++
						{
							position78, tokenIndex78 := position, tokenIndex
							if buffer[position] != rune('.') {
								goto l79
							}
							position++
							goto l78
						l79:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('[') {
								goto l80
							}
							position++
							goto l78
						l80:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('(') {
								goto l81
							}
							position++
							goto l78
						l81:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune(')') {
								goto l82
							}
							position++
							goto l78
						l82:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('=') {
								goto l83
							}
							position++
							goto l78
						l83:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('!') {
								goto l84
							}
							position++
							goto l78
						l84:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('>') {
								goto l85
							}
							position++
							goto l78
						l85:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('<') {
								goto l86
							}
							position++
							goto l78
						l86:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('\t') {
								goto l87
							}
							position++
							goto l78
						l87:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('\r') {
								goto l88
							}
							position++
							goto l78
						l88:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune('\n') {
								goto l89
							}
							position++
							goto l78
						l89:
							position, tokenIndex = position78, tokenIndex78
							if buffer[position] != rune(' ') {
								goto l77
							}
							position++
						}
					l78:
						goto l75
					l77:
						position, tokenIndex = position75, tokenIndex75
						{
							position90, tokenIndex90 := position, tokenIndex
							{
								position91, tokenIndex91 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l92
								}
								position++
								goto l91
							l92:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('.') {
									goto l93
								}
								position++
								goto l91
							l93:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('[') {
									goto l94
								}
								position++
								goto l91
							l94:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('(') {
									goto l95
								}
								position++
								goto l91
							l95:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune(')') {
									goto l96
								}
								position++
								goto l91
							l96:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('=') {
									goto l97
								}
								position++
								goto l91
							l97:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('!') {
									goto l98
								}
								position++
								goto l91
							l98:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('>') {
									goto l99
								}
								position++
								goto l91
							l99:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('<') {
									goto l100
								}
								position++
								goto l91
							l100:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('\t') {
									goto l101
								}
								position++
								goto l91
							l101:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('\r') {
									goto l102
								}
								position++
								goto l91
							l102:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune('\n') {
									goto l103
								}
								position++
								goto l91
							l103:
								position, tokenIndex = position91, tokenIndex91
								if buffer[position] != rune(' ') {
									goto l90
								}
								position++
							}
						l91:
							goto l70
						l90:
							position, tokenIndex = position90, tokenIndex90
						}
						if !matchDot() {
							goto l70
						}
					}
				l75:
				l73:
					{
						position74, tokenIndex74 := position, tokenIndex
						{
							position104, tokenIndex104 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l105
							}
							position++
							if buffer[position] != rune('\\') {
								goto l105
							}
							position++
							goto l104
						l105:
							position, tokenIndex = position104, tokenIndex104
							if buffer[position] != rune('\\') {
								goto l106
							}
							position++
							{
								position107, tokenIndex107 := position, tokenIndex
								if buffer[position] != rune('.') {
									goto l108
								}
								position++
								goto l107
							l108:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('[') {
									goto l109
								}
								position++
								goto l107
							l109:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('(') {
									goto l110
								}
								position++
								goto l107
							l110:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune(')') {
									goto l111
								}
								position++
								goto l107
							l111:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('=') {
									goto l112
								}
								position++
								goto l107
							l112:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('!') {
									goto l113
								}
								position++
								goto l107
							l113:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('>') {
									goto l114
								}
								position++
								goto l107
							l114:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('<') {
									goto l115
								}
								position++
								goto l107
							l115:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('\t') {
									goto l116
								}
								position++
								goto l107
							l116:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('\r') {
									goto l117
								}
								position++
								goto l107
							l117:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune('\n') {
									goto l118
								}
								position++
								goto l107
							l118:
								position, tokenIndex = position107, tokenIndex107
								if buffer[position] != rune(' ') {
									goto l106
								}
								position++
							}
						l107:
							goto l104
						l106:
							position, tokenIndex = position104, tokenIndex104
							{
								position119, tokenIndex119 := position, tokenIndex
								{
									position120, tokenIndex120 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l121
									}
									position++
									goto l120
								l121:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('.') {
										goto l122
									}
									position++
									goto l120
								l122:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('[') {
										goto l123
									}
									position++
									goto l120
								l123:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('(') {
										goto l124
									}
									position++
									goto l120
								l124:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune(')') {
										goto l125
									}
									position++
									goto l120
								l125:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('=') {
										goto l126
									}
									position++
									goto l120
								l126:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('!') {
										goto l127
									}
									position++
									goto l120
								l127:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('>') {
										goto l128
									}
									position++
									goto l120
								l128:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('<') {
										goto l129
									}
									position++
									goto l120
								l129:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('\t') {
										goto l130
									}
									position++
									goto l120
								l130:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('\r') {
										goto l131
									}
									position++
									goto l120
								l131:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune('\n') {
										goto l132
									}
									position++
									goto l120
								l132:
									position, tokenIndex = position120, tokenIndex120
									if buffer[position] != rune(' ') {
										goto l119
									}
									position++
								}
							l120:
								goto l74
							l119:
								position, tokenIndex = position119, tokenIndex119
							}
							if !matchDot() {
								goto l74
							}
						}
					l104:
						goto l73
					l74:
						position, tokenIndex = position74, tokenIndex74
					}
					add(rulePegText, position72)
				}
				{
					position133, tokenIndex133 := position, tokenIndex
					if buffer[position] != rune('(') {
						goto l133
					}
					position++
					if buffer[position] != rune(')') {
						goto l133
					}
					position++
					goto l70
				l133:
					position, tokenIndex = position133, tokenIndex133
				}
				if !_rules[ruleAction11]() {
					goto l70
				}
				add(ruledotChildIdentifier, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 15 bracketChildIdentifier <- <(bracketNodeIdentifiers Action12)> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if !_rules[rulebracketNodeIdentifiers]() {
					goto l134
				}
				if !_rules[ruleAction12]() {
					goto l134
				}
				add(rulebracketChildIdentifier, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 16 bracketNodeIdentifiers <- <(bracketNodeIdentifier (sepBracketIdentifier bracketNodeIdentifier Action13)*)> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if !_rules[rulebracketNodeIdentifier]() {
					goto l136
				}
			l138:
				{
					position139, tokenIndex139 := position, tokenIndex
					if !_rules[rulesepBracketIdentifier]() {
						goto l139
					}
					if !_rules[rulebracketNodeIdentifier]() {
						goto l139
					}
					if !_rules[ruleAction13]() {
						goto l139
					}
					goto l138
				l139:
					position, tokenIndex = position139, tokenIndex139
				}
				add(rulebracketNodeIdentifiers, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 17 bracketNodeIdentifier <- <((singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier) Action14)> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				{
					position142, tokenIndex142 := position, tokenIndex
					if !_rules[rulesingleQuotedNodeIdentifier]() {
						goto l143
					}
					goto l142
				l143:
					position, tokenIndex = position142, tokenIndex142
					if !_rules[ruledoubleQuotedNodeIdentifier]() {
						goto l140
					}
				}
			l142:
				if !_rules[ruleAction14]() {
					goto l140
				}
				add(rulebracketNodeIdentifier, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 18 singleQuotedNodeIdentifier <- <('\'' <(('\\' '\\') / ('\\' '\'') / (!('\\' / '\'') .))*> '\'' Action15)> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if buffer[position] != rune('\'') {
					goto l144
				}
				position++
				{
					position146 := position
				l147:
					{
						position148, tokenIndex148 := position, tokenIndex
						{
							position149, tokenIndex149 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l150
							}
							position++
							if buffer[position] != rune('\\') {
								goto l150
							}
							position++
							goto l149
						l150:
							position, tokenIndex = position149, tokenIndex149
							if buffer[position] != rune('\\') {
								goto l151
							}
							position++
							if buffer[position] != rune('\'') {
								goto l151
							}
							position++
							goto l149
						l151:
							position, tokenIndex = position149, tokenIndex149
							{
								position152, tokenIndex152 := position, tokenIndex
								{
									position153, tokenIndex153 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l154
									}
									position++
									goto l153
								l154:
									position, tokenIndex = position153, tokenIndex153
									if buffer[position] != rune('\'') {
										goto l152
									}
									position++
								}
							l153:
								goto l148
							l152:
								position, tokenIndex = position152, tokenIndex152
							}
							if !matchDot() {
								goto l148
							}
						}
					l149:
						goto l147
					l148:
						position, tokenIndex = position148, tokenIndex148
					}
					add(rulePegText, position146)
				}
				if buffer[position] != rune('\'') {
					goto l144
				}
				position++
				if !_rules[ruleAction15]() {
					goto l144
				}
				add(rulesingleQuotedNodeIdentifier, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 19 doubleQuotedNodeIdentifier <- <('"' <(('\\' '\\') / ('\\' '"') / (!('\\' / '"') .))*> '"' Action16)> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				if buffer[position] != rune('"') {
					goto l155
				}
				position++
				{
					position157 := position
				l158:
					{
						position159, tokenIndex159 := position, tokenIndex
						{
							position160, tokenIndex160 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l161
							}
							position++
							if buffer[position] != rune('\\') {
								goto l161
							}
							position++
							goto l160
						l161:
							position, tokenIndex = position160, tokenIndex160
							if buffer[position] != rune('\\') {
								goto l162
							}
							position++
							if buffer[position] != rune('"') {
								goto l162
							}
							position++
							goto l160
						l162:
							position, tokenIndex = position160, tokenIndex160
							{
								position163, tokenIndex163 := position, tokenIndex
								{
									position164, tokenIndex164 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l165
									}
									position++
									goto l164
								l165:
									position, tokenIndex = position164, tokenIndex164
									if buffer[position] != rune('"') {
										goto l163
									}
									position++
								}
							l164:
								goto l159
							l163:
								position, tokenIndex = position163, tokenIndex163
							}
							if !matchDot() {
								goto l159
							}
						}
					l160:
						goto l158
					l159:
						position, tokenIndex = position159, tokenIndex159
					}
					add(rulePegText, position157)
				}
				if buffer[position] != rune('"') {
					goto l155
				}
				position++
				if !_rules[ruleAction16]() {
					goto l155
				}
				add(ruledoubleQuotedNodeIdentifier, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 20 sepBracketIdentifier <- <(space ',' space)> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				if !_rules[rulespace]() {
					goto l166
				}
				if buffer[position] != rune(',') {
					goto l166
				}
				position++
				if !_rules[rulespace]() {
					goto l166
				}
				add(rulesepBracketIdentifier, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 21 qualifier <- <(union / script / filter)> */
		func() bool {
			position168, tokenIndex168 := position, tokenIndex
			{
				position169 := position
				{
					position170, tokenIndex170 := position, tokenIndex
					if !_rules[ruleunion]() {
						goto l171
					}
					goto l170
				l171:
					position, tokenIndex = position170, tokenIndex170
					if !_rules[rulescript]() {
						goto l172
					}
					goto l170
				l172:
					position, tokenIndex = position170, tokenIndex170
					if !_rules[rulefilter]() {
						goto l168
					}
				}
			l170:
				add(rulequalifier, position169)
			}
			return true
		l168:
			position, tokenIndex = position168, tokenIndex168
			return false
		},
		/* 22 union <- <(index (sepUnion index Action17)*)> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if !_rules[ruleindex]() {
					goto l173
				}
			l175:
				{
					position176, tokenIndex176 := position, tokenIndex
					if !_rules[rulesepUnion]() {
						goto l176
					}
					if !_rules[ruleindex]() {
						goto l176
					}
					if !_rules[ruleAction17]() {
						goto l176
					}
					goto l175
				l176:
					position, tokenIndex = position176, tokenIndex176
				}
				add(ruleunion, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 23 index <- <(((slice Action18) / (<indexNumber> Action19)) Action20)> */
		func() bool {
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				{
					position179, tokenIndex179 := position, tokenIndex
					if !_rules[ruleslice]() {
						goto l180
					}
					if !_rules[ruleAction18]() {
						goto l180
					}
					goto l179
				l180:
					position, tokenIndex = position179, tokenIndex179
					{
						position181 := position
						if !_rules[ruleindexNumber]() {
							goto l177
						}
						add(rulePegText, position181)
					}
					if !_rules[ruleAction19]() {
						goto l177
					}
				}
			l179:
				if !_rules[ruleAction20]() {
					goto l177
				}
				add(ruleindex, position178)
			}
			return true
		l177:
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 24 slice <- <(anyIndex sepSlice anyIndex ((sepSlice anyIndex) / (space Action21)))> */
		func() bool {
			position182, tokenIndex182 := position, tokenIndex
			{
				position183 := position
				if !_rules[ruleanyIndex]() {
					goto l182
				}
				if !_rules[rulesepSlice]() {
					goto l182
				}
				if !_rules[ruleanyIndex]() {
					goto l182
				}
				{
					position184, tokenIndex184 := position, tokenIndex
					if !_rules[rulesepSlice]() {
						goto l185
					}
					if !_rules[ruleanyIndex]() {
						goto l185
					}
					goto l184
				l185:
					position, tokenIndex = position184, tokenIndex184
					if !_rules[rulespace]() {
						goto l182
					}
					if !_rules[ruleAction21]() {
						goto l182
					}
				}
			l184:
				add(ruleslice, position183)
			}
			return true
		l182:
			position, tokenIndex = position182, tokenIndex182
			return false
		},
		/* 25 anyIndex <- <(<indexNumber?> Action22)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				{
					position188 := position
					{
						position189, tokenIndex189 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l189
						}
						goto l190
					l189:
						position, tokenIndex = position189, tokenIndex189
					}
				l190:
					add(rulePegText, position188)
				}
				if !_rules[ruleAction22]() {
					goto l186
				}
				add(ruleanyIndex, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 26 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			position191, tokenIndex191 := position, tokenIndex
			{
				position192 := position
				{
					position193, tokenIndex193 := position, tokenIndex
					{
						position195, tokenIndex195 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l196
						}
						position++
						goto l195
					l196:
						position, tokenIndex = position195, tokenIndex195
						if buffer[position] != rune('+') {
							goto l193
						}
						position++
					}
				l195:
					goto l194
				l193:
					position, tokenIndex = position193, tokenIndex193
				}
			l194:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l191
				}
				position++
			l197:
				{
					position198, tokenIndex198 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l198
					}
					position++
					goto l197
				l198:
					position, tokenIndex = position198, tokenIndex198
				}
				add(ruleindexNumber, position192)
			}
			return true
		l191:
			position, tokenIndex = position191, tokenIndex191
			return false
		},
		/* 27 sepUnion <- <(space ',' space)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				if !_rules[rulespace]() {
					goto l199
				}
				if buffer[position] != rune(',') {
					goto l199
				}
				position++
				if !_rules[rulespace]() {
					goto l199
				}
				add(rulesepUnion, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 28 sepSlice <- <(space ':' space)> */
		func() bool {
			position201, tokenIndex201 := position, tokenIndex
			{
				position202 := position
				if !_rules[rulespace]() {
					goto l201
				}
				if buffer[position] != rune(':') {
					goto l201
				}
				position++
				if !_rules[rulespace]() {
					goto l201
				}
				add(rulesepSlice, position202)
			}
			return true
		l201:
			position, tokenIndex = position201, tokenIndex201
			return false
		},
		/* 29 script <- <(scriptStart <command> scriptEnd Action23)> */
		func() bool {
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				if !_rules[rulescriptStart]() {
					goto l203
				}
				{
					position205 := position
					if !_rules[rulecommand]() {
						goto l203
					}
					add(rulePegText, position205)
				}
				if !_rules[rulescriptEnd]() {
					goto l203
				}
				if !_rules[ruleAction23]() {
					goto l203
				}
				add(rulescript, position204)
			}
			return true
		l203:
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 30 command <- <(!')' .)+> */
		func() bool {
			position206, tokenIndex206 := position, tokenIndex
			{
				position207 := position
				{
					position210, tokenIndex210 := position, tokenIndex
					if buffer[position] != rune(')') {
						goto l210
					}
					position++
					goto l206
				l210:
					position, tokenIndex = position210, tokenIndex210
				}
				if !matchDot() {
					goto l206
				}
			l208:
				{
					position209, tokenIndex209 := position, tokenIndex
					{
						position211, tokenIndex211 := position, tokenIndex
						if buffer[position] != rune(')') {
							goto l211
						}
						position++
						goto l209
					l211:
						position, tokenIndex = position211, tokenIndex211
					}
					if !matchDot() {
						goto l209
					}
					goto l208
				l209:
					position, tokenIndex = position209, tokenIndex209
				}
				add(rulecommand, position207)
			}
			return true
		l206:
			position, tokenIndex = position206, tokenIndex206
			return false
		},
		/* 31 filter <- <(filterStart query filterEnd Action24)> */
		func() bool {
			position212, tokenIndex212 := position, tokenIndex
			{
				position213 := position
				if !_rules[rulefilterStart]() {
					goto l212
				}
				if !_rules[rulequery]() {
					goto l212
				}
				if !_rules[rulefilterEnd]() {
					goto l212
				}
				if !_rules[ruleAction24]() {
					goto l212
				}
				add(rulefilter, position213)
			}
			return true
		l212:
			position, tokenIndex = position212, tokenIndex212
			return false
		},
		/* 32 query <- <(andQuery (logicOr andQuery Action25)*)> */
		func() bool {
			position214, tokenIndex214 := position, tokenIndex
			{
				position215 := position
				if !_rules[ruleandQuery]() {
					goto l214
				}
			l216:
				{
					position217, tokenIndex217 := position, tokenIndex
					if !_rules[rulelogicOr]() {
						goto l217
					}
					if !_rules[ruleandQuery]() {
						goto l217
					}
					if !_rules[ruleAction25]() {
						goto l217
					}
					goto l216
				l217:
					position, tokenIndex = position217, tokenIndex217
				}
				add(rulequery, position215)
			}
			return true
		l214:
			position, tokenIndex = position214, tokenIndex214
			return false
		},
		/* 33 andQuery <- <(basicQuery (logicAnd basicQuery Action26)*)> */
		func() bool {
			position218, tokenIndex218 := position, tokenIndex
			{
				position219 := position
				if !_rules[rulebasicQuery]() {
					goto l218
				}
			l220:
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[rulelogicAnd]() {
						goto l221
					}
					if !_rules[rulebasicQuery]() {
						goto l221
					}
					if !_rules[ruleAction26]() {
						goto l221
					}
					goto l220
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
				add(ruleandQuery, position219)
			}
			return true
		l218:
			position, tokenIndex = position218, tokenIndex218
			return false
		},
		/* 34 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action27) / (<(logicNot? jsonpathFilter)> Action28))> */
		func() bool {
			position222, tokenIndex222 := position, tokenIndex
			{
				position223 := position
				{
					position224, tokenIndex224 := position, tokenIndex
					if !_rules[rulesubQueryStart]() {
						goto l225
					}
					if !_rules[rulequery]() {
						goto l225
					}
					if !_rules[rulesubQueryEnd]() {
						goto l225
					}
					goto l224
				l225:
					position, tokenIndex = position224, tokenIndex224
					{
						position227 := position
						if !_rules[rulecomparator]() {
							goto l226
						}
						add(rulePegText, position227)
					}
					if !_rules[ruleAction27]() {
						goto l226
					}
					goto l224
				l226:
					position, tokenIndex = position224, tokenIndex224
					{
						position228 := position
						{
							position229, tokenIndex229 := position, tokenIndex
							if !_rules[rulelogicNot]() {
								goto l229
							}
							goto l230
						l229:
							position, tokenIndex = position229, tokenIndex229
						}
					l230:
						if !_rules[rulejsonpathFilter]() {
							goto l222
						}
						add(rulePegText, position228)
					}
					if !_rules[ruleAction28]() {
						goto l222
					}
				}
			l224:
				add(rulebasicQuery, position223)
			}
			return true
		l222:
			position, tokenIndex = position222, tokenIndex222
			return false
		},
		/* 35 logicOr <- <(space ('|' '|') space)> */
		func() bool {
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
				if !_rules[rulespace]() {
					goto l231
				}
				if buffer[position] != rune('|') {
					goto l231
				}
				position++
				if buffer[position] != rune('|') {
					goto l231
				}
				position++
				if !_rules[rulespace]() {
					goto l231
				}
				add(rulelogicOr, position232)
			}
			return true
		l231:
			position, tokenIndex = position231, tokenIndex231
			return false
		},
		/* 36 logicAnd <- <(space ('&' '&') space)> */
		func() bool {
			position233, tokenIndex233 := position, tokenIndex
			{
				position234 := position
				if !_rules[rulespace]() {
					goto l233
				}
				if buffer[position] != rune('&') {
					goto l233
				}
				position++
				if buffer[position] != rune('&') {
					goto l233
				}
				position++
				if !_rules[rulespace]() {
					goto l233
				}
				add(rulelogicAnd, position234)
			}
			return true
		l233:
			position, tokenIndex = position233, tokenIndex233
			return false
		},
		/* 37 logicNot <- <('!' space)> */
		func() bool {
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				if buffer[position] != rune('!') {
					goto l235
				}
				position++
				if !_rules[rulespace]() {
					goto l235
				}
				add(rulelogicNot, position236)
			}
			return true
		l235:
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 38 comparator <- <((qParam space (('=' '=' space qParam Action29) / ('!' '=' space qParam Action30))) / (qNumericParam space (('<' '=' space qNumericParam Action31) / ('<' space qNumericParam Action32) / ('>' '=' space qNumericParam Action33) / ('>' space qNumericParam Action34))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action35))> */
		func() bool {
			position237, tokenIndex237 := position, tokenIndex
			{
				position238 := position
				{
					position239, tokenIndex239 := position, tokenIndex
					if !_rules[ruleqParam]() {
						goto l240
					}
					if !_rules[rulespace]() {
						goto l240
					}
					{
						position241, tokenIndex241 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l242
						}
						position++
						if buffer[position] != rune('=') {
							goto l242
						}
						position++
						if !_rules[rulespace]() {
							goto l242
						}
						if !_rules[ruleqParam]() {
							goto l242
						}
						if !_rules[ruleAction29]() {
							goto l242
						}
						goto l241
					l242:
						position, tokenIndex = position241, tokenIndex241
						if buffer[position] != rune('!') {
							goto l240
						}
						position++
						if buffer[position] != rune('=') {
							goto l240
						}
						position++
						if !_rules[rulespace]() {
							goto l240
						}
						if !_rules[ruleqParam]() {
							goto l240
						}
						if !_rules[ruleAction30]() {
							goto l240
						}
					}
				l241:
					goto l239
				l240:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[ruleqNumericParam]() {
						goto l243
					}
					if !_rules[rulespace]() {
						goto l243
					}
					{
						position244, tokenIndex244 := position, tokenIndex
						if buffer[position] != rune('<') {
							goto l245
						}
						position++
						if buffer[position] != rune('=') {
							goto l245
						}
						position++
						if !_rules[rulespace]() {
							goto l245
						}
						if !_rules[ruleqNumericParam]() {
							goto l245
						}
						if !_rules[ruleAction31]() {
							goto l245
						}
						goto l244
					l245:
						position, tokenIndex = position244, tokenIndex244
						if buffer[position] != rune('<') {
							goto l246
						}
						position++
						if !_rules[rulespace]() {
							goto l246
						}
						if !_rules[ruleqNumericParam]() {
							goto l246
						}
						if !_rules[ruleAction32]() {
							goto l246
						}
						goto l244
					l246:
						position, tokenIndex = position244, tokenIndex244
						if buffer[position] != rune('>') {
							goto l247
						}
						position++
						if buffer[position] != rune('=') {
							goto l247
						}
						position++
						if !_rules[rulespace]() {
							goto l247
						}
						if !_rules[ruleqNumericParam]() {
							goto l247
						}
						if !_rules[ruleAction33]() {
							goto l247
						}
						goto l244
					l247:
						position, tokenIndex = position244, tokenIndex244
						if buffer[position] != rune('>') {
							goto l243
						}
						position++
						if !_rules[rulespace]() {
							goto l243
						}
						if !_rules[ruleqNumericParam]() {
							goto l243
						}
						if !_rules[ruleAction34]() {
							goto l243
						}
					}
				l244:
					goto l239
				l243:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[rulesingleJsonpathFilter]() {
						goto l237
					}
					if !_rules[rulespace]() {
						goto l237
					}
					if buffer[position] != rune('=') {
						goto l237
					}
					position++
					if buffer[position] != rune('~') {
						goto l237
					}
					position++
					if !_rules[rulespace]() {
						goto l237
					}
					if buffer[position] != rune('/') {
						goto l237
					}
					position++
					{
						position248 := position
						if !_rules[ruleregex]() {
							goto l237
						}
						add(rulePegText, position248)
					}
					if buffer[position] != rune('/') {
						goto l237
					}
					position++
					if !_rules[ruleAction35]() {
						goto l237
					}
				}
			l239:
				add(rulecomparator, position238)
			}
			return true
		l237:
			position, tokenIndex = position237, tokenIndex237
			return false
		},
		/* 39 qParam <- <((qLiteral Action36) / singleJsonpathFilter)> */
		func() bool {
			position249, tokenIndex249 := position, tokenIndex
			{
				position250 := position
				{
					position251, tokenIndex251 := position, tokenIndex
					if !_rules[ruleqLiteral]() {
						goto l252
					}
					if !_rules[ruleAction36]() {
						goto l252
					}
					goto l251
				l252:
					position, tokenIndex = position251, tokenIndex251
					if !_rules[rulesingleJsonpathFilter]() {
						goto l249
					}
				}
			l251:
				add(ruleqParam, position250)
			}
			return true
		l249:
			position, tokenIndex = position249, tokenIndex249
			return false
		},
		/* 40 qNumericParam <- <((lNumber Action37) / singleJsonpathFilter)> */
		func() bool {
			position253, tokenIndex253 := position, tokenIndex
			{
				position254 := position
				{
					position255, tokenIndex255 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l256
					}
					if !_rules[ruleAction37]() {
						goto l256
					}
					goto l255
				l256:
					position, tokenIndex = position255, tokenIndex255
					if !_rules[rulesingleJsonpathFilter]() {
						goto l253
					}
				}
			l255:
				add(ruleqNumericParam, position254)
			}
			return true
		l253:
			position, tokenIndex = position253, tokenIndex253
			return false
		},
		/* 41 qLiteral <- <(lNumber / lBool / lString / lNull)> */
		func() bool {
			position257, tokenIndex257 := position, tokenIndex
			{
				position258 := position
				{
					position259, tokenIndex259 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l260
					}
					goto l259
				l260:
					position, tokenIndex = position259, tokenIndex259
					if !_rules[rulelBool]() {
						goto l261
					}
					goto l259
				l261:
					position, tokenIndex = position259, tokenIndex259
					if !_rules[rulelString]() {
						goto l262
					}
					goto l259
				l262:
					position, tokenIndex = position259, tokenIndex259
					if !_rules[rulelNull]() {
						goto l257
					}
				}
			l259:
				add(ruleqLiteral, position258)
			}
			return true
		l257:
			position, tokenIndex = position257, tokenIndex257
			return false
		},
		/* 42 singleJsonpathFilter <- <(jsonpathFilter Action38)> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				if !_rules[rulejsonpathFilter]() {
					goto l263
				}
				if !_rules[ruleAction38]() {
					goto l263
				}
				add(rulesingleJsonpathFilter, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 43 jsonpathFilter <- <(Action39 <jsonpathParameter> Action40)> */
		func() bool {
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				if !_rules[ruleAction39]() {
					goto l265
				}
				{
					position267 := position
					if !_rules[rulejsonpathParameter]() {
						goto l265
					}
					add(rulePegText, position267)
				}
				if !_rules[ruleAction40]() {
					goto l265
				}
				add(rulejsonpathFilter, position266)
			}
			return true
		l265:
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 44 lNumber <- <(<(('-' / '+')? [0-9] ('-' / '+' / '.' / [0-9] / [a-z] / [A-Z])*)> Action41)> */
		func() bool {
			position268, tokenIndex268 := position, tokenIndex
			{
				position269 := position
				{
					position270 := position
					{
						position271, tokenIndex271 := position, tokenIndex
						{
							position273, tokenIndex273 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l274
							}
							position++
							goto l273
						l274:
							position, tokenIndex = position273, tokenIndex273
							if buffer[position] != rune('+') {
								goto l271
							}
							position++
						}
					l273:
						goto l272
					l271:
						position, tokenIndex = position271, tokenIndex271
					}
				l272:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l268
					}
					position++
				l275:
					{
						position276, tokenIndex276 := position, tokenIndex
						{
							position277, tokenIndex277 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l278
							}
							position++
							goto l277
						l278:
							position, tokenIndex = position277, tokenIndex277
							if buffer[position] != rune('+') {
								goto l279
							}
							position++
							goto l277
						l279:
							position, tokenIndex = position277, tokenIndex277
							if buffer[position] != rune('.') {
								goto l280
							}
							position++
							goto l277
						l280:
							position, tokenIndex = position277, tokenIndex277
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l281
							}
							position++
							goto l277
						l281:
							position, tokenIndex = position277, tokenIndex277
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l282
							}
							position++
							goto l277
						l282:
							position, tokenIndex = position277, tokenIndex277
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l276
							}
							position++
						}
					l277:
						goto l275
					l276:
						position, tokenIndex = position276, tokenIndex276
					}
					add(rulePegText, position270)
				}
				if !_rules[ruleAction41]() {
					goto l268
				}
				add(rulelNumber, position269)
			}
			return true
		l268:
			position, tokenIndex = position268, tokenIndex268
			return false
		},
		/* 45 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action42) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action43))> */
		func() bool {
			position283, tokenIndex283 := position, tokenIndex
			{
				position284 := position
				{
					position285, tokenIndex285 := position, tokenIndex
					{
						position287, tokenIndex287 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l288
						}
						position++
						if buffer[position] != rune('r') {
							goto l288
						}
						position++
						if buffer[position] != rune('u') {
							goto l288
						}
						position++
						if buffer[position] != rune('e') {
							goto l288
						}
						position++
						goto l287
					l288:
						position, tokenIndex = position287, tokenIndex287
						if buffer[position] != rune('T') {
							goto l289
						}
						position++
						if buffer[position] != rune('r') {
							goto l289
						}
						position++
						if buffer[position] != rune('u') {
							goto l289
						}
						position++
						if buffer[position] != rune('e') {
							goto l289
						}
						position++
						goto l287
					l289:
						position, tokenIndex = position287, tokenIndex287
						if buffer[position] != rune('T') {
							goto l286
						}
						position++
						if buffer[position] != rune('R') {
							goto l286
						}
						position++
						if buffer[position] != rune('U') {
							goto l286
						}
						position++
						if buffer[position] != rune('E') {
							goto l286
						}
						position++
					}
				l287:
					if !_rules[ruleAction42]() {
						goto l286
					}
					goto l285
				l286:
					position, tokenIndex = position285, tokenIndex285
					{
						position290, tokenIndex290 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l291
						}
						position++
						if buffer[position] != rune('a') {
							goto l291
						}
						position++
						if buffer[position] != rune('l') {
							goto l291
						}
						position++
						if buffer[position] != rune('s') {
							goto l291
						}
						position++
						if buffer[position] != rune('e') {
							goto l291
						}
						position++
						goto l290
					l291:
						position, tokenIndex = position290, tokenIndex290
						if buffer[position] != rune('F') {
							goto l292
						}
						position++
						if buffer[position] != rune('a') {
							goto l292
						}
						position++
						if buffer[position] != rune('l') {
							goto l292
						}
						position++
						if buffer[position] != rune('s') {
							goto l292
						}
						position++
						if buffer[position] != rune('e') {
							goto l292
						}
						position++
						goto l290
					l292:
						position, tokenIndex = position290, tokenIndex290
						if buffer[position] != rune('F') {
							goto l283
						}
						position++
						if buffer[position] != rune('A') {
							goto l283
						}
						position++
						if buffer[position] != rune('L') {
							goto l283
						}
						position++
						if buffer[position] != rune('S') {
							goto l283
						}
						position++
						if buffer[position] != rune('E') {
							goto l283
						}
						position++
					}
				l290:
					if !_rules[ruleAction43]() {
						goto l283
					}
				}
			l285:
				add(rulelBool, position284)
			}
			return true
		l283:
			position, tokenIndex = position283, tokenIndex283
			return false
		},
		/* 46 lString <- <(('\'' <(('\\' '\\') / ('\\' '\'') / (!'\'' .))*> '\'' Action44) / ('"' <(('\\' '\\') / ('\\' '"') / (!'"' .))*> '"' Action45))> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				{
					position295, tokenIndex295 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l296
					}
					position++
					{
						position297 := position
					l298:
						{
							position299, tokenIndex299 := position, tokenIndex
							{
								position300, tokenIndex300 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l301
								}
								position++
								if buffer[position] != rune('\\') {
									goto l301
								}
								position++
								goto l300
							l301:
								position, tokenIndex = position300, tokenIndex300
								if buffer[position] != rune('\\') {
									goto l302
								}
								position++
								if buffer[position] != rune('\'') {
									goto l302
								}
								position++
								goto l300
							l302:
								position, tokenIndex = position300, tokenIndex300
								{
									position303, tokenIndex303 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l303
									}
									position++
									goto l299
								l303:
									position, tokenIndex = position303, tokenIndex303
								}
								if !matchDot() {
									goto l299
								}
							}
						l300:
							goto l298
						l299:
							position, tokenIndex = position299, tokenIndex299
						}
						add(rulePegText, position297)
					}
					if buffer[position] != rune('\'') {
						goto l296
					}
					position++
					if !_rules[ruleAction44]() {
						goto l296
					}
					goto l295
				l296:
					position, tokenIndex = position295, tokenIndex295
					if buffer[position] != rune('"') {
						goto l293
					}
					position++
					{
						position304 := position
					l305:
						{
							position306, tokenIndex306 := position, tokenIndex
							{
								position307, tokenIndex307 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l308
								}
								position++
								if buffer[position] != rune('\\') {
									goto l308
								}
								position++
								goto l307
							l308:
								position, tokenIndex = position307, tokenIndex307
								if buffer[position] != rune('\\') {
									goto l309
								}
								position++
								if buffer[position] != rune('"') {
									goto l309
								}
								position++
								goto l307
							l309:
								position, tokenIndex = position307, tokenIndex307
								{
									position310, tokenIndex310 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l310
									}
									position++
									goto l306
								l310:
									position, tokenIndex = position310, tokenIndex310
								}
								if !matchDot() {
									goto l306
								}
							}
						l307:
							goto l305
						l306:
							position, tokenIndex = position306, tokenIndex306
						}
						add(rulePegText, position304)
					}
					if buffer[position] != rune('"') {
						goto l293
					}
					position++
					if !_rules[ruleAction45]() {
						goto l293
					}
				}
			l295:
				add(rulelString, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 47 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action46)> */
		func() bool {
			position311, tokenIndex311 := position, tokenIndex
			{
				position312 := position
				{
					position313, tokenIndex313 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l314
					}
					position++
					if buffer[position] != rune('u') {
						goto l314
					}
					position++
					if buffer[position] != rune('l') {
						goto l314
					}
					position++
					if buffer[position] != rune('l') {
						goto l314
					}
					position++
					goto l313
				l314:
					position, tokenIndex = position313, tokenIndex313
					if buffer[position] != rune('N') {
						goto l315
					}
					position++
					if buffer[position] != rune('u') {
						goto l315
					}
					position++
					if buffer[position] != rune('l') {
						goto l315
					}
					position++
					if buffer[position] != rune('l') {
						goto l315
					}
					position++
					goto l313
				l315:
					position, tokenIndex = position313, tokenIndex313
					if buffer[position] != rune('N') {
						goto l311
					}
					position++
					if buffer[position] != rune('U') {
						goto l311
					}
					position++
					if buffer[position] != rune('L') {
						goto l311
					}
					position++
					if buffer[position] != rune('L') {
						goto l311
					}
					position++
				}
			l313:
				if !_rules[ruleAction46]() {
					goto l311
				}
				add(rulelNull, position312)
			}
			return true
		l311:
			position, tokenIndex = position311, tokenIndex311
			return false
		},
		/* 48 regex <- <(('\\' '\\') / ('\\' '/') / (!'/' .))*> */
		func() bool {
			{
				position317 := position
			l318:
				{
					position319, tokenIndex319 := position, tokenIndex
					{
						position320, tokenIndex320 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l321
						}
						position++
						if buffer[position] != rune('\\') {
							goto l321
						}
						position++
						goto l320
					l321:
						position, tokenIndex = position320, tokenIndex320
						if buffer[position] != rune('\\') {
							goto l322
						}
						position++
						if buffer[position] != rune('/') {
							goto l322
						}
						position++
						goto l320
					l322:
						position, tokenIndex = position320, tokenIndex320
						{
							position323, tokenIndex323 := position, tokenIndex
							if buffer[position] != rune('/') {
								goto l323
							}
							position++
							goto l319
						l323:
							position, tokenIndex = position323, tokenIndex323
						}
						if !matchDot() {
							goto l319
						}
					}
				l320:
					goto l318
				l319:
					position, tokenIndex = position319, tokenIndex319
				}
				add(ruleregex, position317)
			}
			return true
		},
		/* 49 squareBracketStart <- <('[' space)> */
		func() bool {
			position324, tokenIndex324 := position, tokenIndex
			{
				position325 := position
				if buffer[position] != rune('[') {
					goto l324
				}
				position++
				if !_rules[rulespace]() {
					goto l324
				}
				add(rulesquareBracketStart, position325)
			}
			return true
		l324:
			position, tokenIndex = position324, tokenIndex324
			return false
		},
		/* 50 squareBracketEnd <- <(space ']')> */
		func() bool {
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				if !_rules[rulespace]() {
					goto l326
				}
				if buffer[position] != rune(']') {
					goto l326
				}
				position++
				add(rulesquareBracketEnd, position327)
			}
			return true
		l326:
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 51 scriptStart <- <('(' space)> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				if buffer[position] != rune('(') {
					goto l328
				}
				position++
				if !_rules[rulespace]() {
					goto l328
				}
				add(rulescriptStart, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 52 scriptEnd <- <(space ')')> */
		func() bool {
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				if !_rules[rulespace]() {
					goto l330
				}
				if buffer[position] != rune(')') {
					goto l330
				}
				position++
				add(rulescriptEnd, position331)
			}
			return true
		l330:
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 53 filterStart <- <('?' '(' space)> */
		func() bool {
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if buffer[position] != rune('?') {
					goto l332
				}
				position++
				if buffer[position] != rune('(') {
					goto l332
				}
				position++
				if !_rules[rulespace]() {
					goto l332
				}
				add(rulefilterStart, position333)
			}
			return true
		l332:
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 54 filterEnd <- <(space ')')> */
		func() bool {
			position334, tokenIndex334 := position, tokenIndex
			{
				position335 := position
				if !_rules[rulespace]() {
					goto l334
				}
				if buffer[position] != rune(')') {
					goto l334
				}
				position++
				add(rulefilterEnd, position335)
			}
			return true
		l334:
			position, tokenIndex = position334, tokenIndex334
			return false
		},
		/* 55 subQueryStart <- <('(' space)> */
		func() bool {
			position336, tokenIndex336 := position, tokenIndex
			{
				position337 := position
				if buffer[position] != rune('(') {
					goto l336
				}
				position++
				if !_rules[rulespace]() {
					goto l336
				}
				add(rulesubQueryStart, position337)
			}
			return true
		l336:
			position, tokenIndex = position336, tokenIndex336
			return false
		},
		/* 56 subQueryEnd <- <(space ')')> */
		func() bool {
			position338, tokenIndex338 := position, tokenIndex
			{
				position339 := position
				if !_rules[rulespace]() {
					goto l338
				}
				if buffer[position] != rune(')') {
					goto l338
				}
				position++
				add(rulesubQueryEnd, position339)
			}
			return true
		l338:
			position, tokenIndex = position338, tokenIndex338
			return false
		},
		/* 57 space <- <(' ' / '\t')*> */
		func() bool {
			{
				position341 := position
			l342:
				{
					position343, tokenIndex343 := position, tokenIndex
					{
						position344, tokenIndex344 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l345
						}
						position++
						goto l344
					l345:
						position, tokenIndex = position344, tokenIndex344
						if buffer[position] != rune('\t') {
							goto l343
						}
						position++
					}
				l344:
					goto l342
				l343:
					position, tokenIndex = position343, tokenIndex343
				}
				add(rulespace, position341)
			}
			return true
		},
		/* 59 Action0 <- <{
		    p.root = p.pop().(syntaxNode)
		}> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		nil,
		/* 61 Action1 <- <{
		    p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)
		}> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 62 Action2 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 63 Action3 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 64 Action4 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 65 Action5 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 66 Action6 <- <{
		    p.push(text)
		}> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 67 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 68 Action8 <- <{
		    p.pushRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 69 Action9 <- <{
		    p.pushCurrentRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 70 Action10 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 71 Action11 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 72 Action12 <- <{
		    identifier := p.pop().([]string)
		    if len(identifier) > 1 {
		        p.pushChildMultiIdentifier(identifier)
		    } else {
		        p.pushChildSingleIdentifier(identifier[0])
		    }
		}> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 73 Action13 <- <{
		    identifier2 := p.pop().([]string)
		    identifier1 := p.pop().([]string)
		    p.push(append(identifier1, identifier2...))
		}> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 74 Action14 <- <{
		    p.push([]string{p.pop().(string)})
		}> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 75 Action15 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 76 Action16 <- <{ // '
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 77 Action17 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 78 Action18 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted || step.number == 0 {
		        step.number = 1
		    }

		    if step.number > 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 79 Action19 <- <{
		    p.pushIndexSubscript(text)
		}> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 80 Action20 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 81 Action21 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 82 Action22 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 83 Action23 <- <{
		    p.pushScriptQualifier(text)
		}> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 84 Action24 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 85 Action25 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 86 Action26 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 87 Action27 <- <{
		        if !p.hasErr() {
		            query := p.pop().(syntaxQuery)
		            p.push(query)

					if logicalNot, ok := query.(*syntaxLogicalNot); ok {
						query = (*logicalNot).query
					}
		            if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		                _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
		                _, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
		                if leftIsCurrentRoot && rigthIsCurrentRoot {
		                    p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
		                }
					}
		        }
		    }> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 88 Action28 <- <{
		    _ = p.pop().(bool)
		    jsonpathFilter := p.pop().(syntaxQuery)
		    if text[0:1] == `!` {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 89 Action29 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 90 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 91 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 92 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 93 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 94 Action34 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 95 Action35 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		/* 96 Action36 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 97 Action37 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 98 Action38 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if !p.hasErr() && param.isValueGroupParameter() {
		        p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 99 Action39 <- <{
		    p.saveParams()
		}> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 100 Action40 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootIdentifier:
		        p.pushCompareParameterRoot(node)
		        p.push(true)
		    case *syntaxCurrentRootIdentifier:
		        p.pushCompareParameterCurrentRoot(node)
		        p.push(false)
		    default:
		        p.push(&syntaxQueryParamRoot{})
		        p.push(true)
		    }
		}> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 101 Action41 <- <{
		    p.push(p.toFloat(text))
		}> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 102 Action42 <- <{
		    p.push(true)
		}> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 103 Action43 <- <{
		    p.push(false)
		}> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		/* 104 Action44 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 105 Action45 <- <{ // '
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
		/* 106 Action46 <- <{
		    p.push(nil)
		}> */
		func() bool {
			{
				add(ruleAction46, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
