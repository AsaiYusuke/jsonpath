package jsonpath

// Code generated by peg -inline -switch jsonpath.peg DO NOT EDIT.

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpathQuery
	rulerootlessQuery
	rulejsonpathParameter
	rulerootIdentifier
	rulerootlessNode
	ruleparameterRootNode
	rulecurrentNodeIdentifier
	rulesegments
	rulesegment
	ruledescendantSegment
	rulechildSegment
	rulebracketedSelection
	rulefunction
	rulefunctionName
	rulememberNameShorthand
	rulesignsWithoutHyphenUnderscore
	ruleselectors
	ruleobjectElementSelectors
	ruleobjectElementSelector
	rulewildcardSelector
	rulenameSelector
	rulearrayElementSelectors
	rulearrayElementSelector
	rulearraySliceSelector
	ruleanyIndex
	ruleindexSelector
	ruleindexNumber
	rulesep
	rulesepArraySlice
	rulescriptSelector
	rulecommand
	rulefilterSelector
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulehexDigits
	rulehexDigit
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptSelectorStart
	rulescriptSelectorEnd
	rulefilterSelectorStart
	rulefilterSelectorEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpathQuery",
	"rootlessQuery",
	"jsonpathParameter",
	"rootIdentifier",
	"rootlessNode",
	"parameterRootNode",
	"currentNodeIdentifier",
	"segments",
	"segment",
	"descendantSegment",
	"childSegment",
	"bracketedSelection",
	"function",
	"functionName",
	"memberNameShorthand",
	"signsWithoutHyphenUnderscore",
	"selectors",
	"objectElementSelectors",
	"objectElementSelector",
	"wildcardSelector",
	"nameSelector",
	"arrayElementSelectors",
	"arrayElementSelector",
	"arraySliceSelector",
	"anyIndex",
	"indexSelector",
	"indexNumber",
	"sep",
	"sepArraySlice",
	"scriptSelector",
	"command",
	"filterSelector",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"hexDigits",
	"hexDigit",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptSelectorStart",
	"scriptSelectorEnd",
	"filterSelectorStart",
	"filterSelectorEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer         string
	buffer         []rune
	rules          [112]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
			p.setConnectedText(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.pushRootNodeIdentifier()

		case ruleAction3:

			p.pushRootNodeIdentifier()

		case ruleAction4:

			p.pushCurrentNodeIdentifier()

		case ruleAction5:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction6:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.setLastNodeText(text)

		case ruleAction9:

			p.pushFunction(text, p.pop().(string))

		case ruleAction10:

			p.push(text)

		case ruleAction11:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction12:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction13:

			p.pushChildWildcardIdentifier()

		case ruleAction14:

			p.pushChildSingleIdentifier(p.pop().(string))

		case ruleAction15:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction16:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted {
				step.number = 1
			}

			if step.number >= 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction17:

			p.pushIndexSubscript(text)

		case ruleAction18:

			p.pushWildcardSubscript()

		case ruleAction19:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction20:

			p.pushIndexSubscript(`1`)

		case ruleAction21:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction22:

			p.pushScriptQualifier(text)

		case ruleAction23:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction24:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction25:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction26:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
				_, leftIsCurrentNode := checkQuery.leftParam.param.(*syntaxQueryParamCurrentNode)
				_, rightIsCurrentNode := checkQuery.rightParam.param.(*syntaxQueryParamCurrentNode)
				if leftIsCurrentNode && rightIsCurrentNode {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction27:

			_ = p.pop()
			jsonpathFilter := p.pop().(syntaxQuery)

			if text[0:1] == `!` {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction28:

			boolValue := p.pop().(bool)
			p.pushBooleanLiteralQuery(boolValue)

		case ruleAction29:

			boolValue := p.pop().(bool)
			p.pushBooleanLiteralQuery(!boolValue)

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction34:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction35:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction36:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction37:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction38:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction39:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction40:

			p.saveParams()

		case ruleAction41:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootNodeIdentifier:
				p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
				p.push(true)
			case *syntaxCurrentNodeIdentifier:
				p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
				p.push(false)
			}

		case ruleAction42:

			p.push(p.toFloat(text))

		case ruleAction43:

			p.push(true)

		case ruleAction44:

			p.push(false)

		case ruleAction45:

			p.push(p.unescapeSingleQuotedString(text))

		case ruleAction46:

			p.push(p.unescapeDoubleQuotedString(text))

		case ruleAction47:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func DisableMemoize() func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.disableMemoize = true
		return nil
	}
}

type memo struct {
	Matched bool
	Partial []token32
}

type memoKey struct {
	Rule     uint32
	Position uint32
}

func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
		memoization          map[memoKey]memo
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey]memo)
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	memoize := func(rule uint32, begin uint32, tokenIndexStart uint32, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey{rule, begin}
		if !matched {
			memoization[key] = memo{Matched: false}
		} else {
			t := tree.tree[tokenIndexStart:tokenIndex]
			tokenCopy := make([]token32, len(t))
			copy(tokenCopy, t)
			memoization[key] = memo{Matched: true, Partial: tokenCopy}
		}
	}

	memoizedResult := func(m memo) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += uint32(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > max.end {
			max = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <(((jsonpathQuery / rootlessQuery) END Action0) / ((jsonpathQuery / rootlessQuery)? <.*> END Action1))> */
		func() bool {
			if memoized, ok := memoization[memoKey{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpathQuery]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[rulerootlessQuery]() {
							goto l3
						}
					}
				l4:
					if !_rules[ruleEND]() {
						goto l3
					}
					{
						add(ruleAction0, position)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position7, tokenIndex7 := position, tokenIndex
						{
							position9, tokenIndex9 := position, tokenIndex
							if !_rules[rulejsonpathQuery]() {
								goto l10
							}
							goto l9
						l10:
							position, tokenIndex = position9, tokenIndex9
							if !_rules[rulerootlessQuery]() {
								goto l7
							}
						}
					l9:
						goto l8
					l7:
						position, tokenIndex = position7, tokenIndex7
					}
				l8:
					{
						position11 := position
					l12:
						{
							position13, tokenIndex13 := position, tokenIndex
							if !matchDot() {
								goto l13
							}
							goto l12
						l13:
							position, tokenIndex = position13, tokenIndex13
						}
						add(rulePegText, position11)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					{
						add(ruleAction1, position)
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			if memoized, ok := memoization[memoKey{1, position}]; ok {
				return memoizedResult(memoized)
			}
			position15, tokenIndex15 := position, tokenIndex
			{
				position16 := position
				{
					position17, tokenIndex17 := position, tokenIndex
					if !matchDot() {
						goto l17
					}
					goto l15
				l17:
					position, tokenIndex = position17, tokenIndex17
				}
				add(ruleEND, position16)
			}
			memoize(1, position15, tokenIndex15, true)
			return true
		l15:
			memoize(1, position15, tokenIndex15, false)
			position, tokenIndex = position15, tokenIndex15
			return false
		},
		/* 2 jsonpathQuery <- <(space rootIdentifier segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				if !_rules[rulespace]() {
					goto l18
				}
				if !_rules[rulerootIdentifier]() {
					goto l18
				}
				if !_rules[rulesegments]() {
					goto l18
				}
				add(rulejsonpathQuery, position19)
			}
			memoize(2, position18, tokenIndex18, true)
			return true
		l18:
			memoize(2, position18, tokenIndex18, false)
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 3 rootlessQuery <- <(space rootlessNode segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey{3, position}]; ok {
				return memoizedResult(memoized)
			}
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				if !_rules[rulespace]() {
					goto l20
				}
				{
					position22 := position
					{
						add(ruleAction3, position)
					}
					{
						position24, tokenIndex24 := position, tokenIndex
						if !_rules[rulebracketedSelection]() {
							goto l25
						}
						goto l24
					l25:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[rulememberNameShorthand]() {
							goto l26
						}
						goto l24
					l26:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[ruledescendantSegment]() {
							goto l27
						}
						goto l24
					l27:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[rulechildSegment]() {
							goto l20
						}
					}
				l24:
					add(rulerootlessNode, position22)
				}
				if !_rules[rulesegments]() {
					goto l20
				}
				add(rulerootlessQuery, position21)
			}
			memoize(3, position20, tokenIndex20, true)
			return true
		l20:
			memoize(3, position20, tokenIndex20, false)
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 4 jsonpathParameter <- <(space parameterRootNode segments)> */
		nil,
		/* 5 rootIdentifier <- <('$' Action2)> */
		func() bool {
			if memoized, ok := memoization[memoKey{5, position}]; ok {
				return memoizedResult(memoized)
			}
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				if buffer[position] != rune('$') {
					goto l29
				}
				position++
				{
					add(ruleAction2, position)
				}
				add(rulerootIdentifier, position30)
			}
			memoize(5, position29, tokenIndex29, true)
			return true
		l29:
			memoize(5, position29, tokenIndex29, false)
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 6 rootlessNode <- <(Action3 (bracketedSelection / memberNameShorthand / descendantSegment / childSegment))> */
		nil,
		/* 7 parameterRootNode <- <(rootIdentifier / currentNodeIdentifier)> */
		nil,
		/* 8 currentNodeIdentifier <- <('@' Action4)> */
		nil,
		/* 9 segments <- <(segment* function* space Action5)> */
		func() bool {
			if memoized, ok := memoization[memoKey{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
			l37:
				{
					position38, tokenIndex38 := position, tokenIndex
					{
						position39 := position
						{
							position40, tokenIndex40 := position, tokenIndex
							if !_rules[ruledescendantSegment]() {
								goto l41
							}
							goto l40
						l41:
							position, tokenIndex = position40, tokenIndex40
							if !_rules[rulechildSegment]() {
								goto l38
							}
						}
					l40:
						add(rulesegment, position39)
					}
					goto l37
				l38:
					position, tokenIndex = position38, tokenIndex38
				}
			l42:
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position44 := position
						{
							position45 := position
							if buffer[position] != rune('.') {
								goto l43
							}
							position++
							{
								position46 := position
								{
									position47 := position
									{
										switch buffer[position] {
										case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
											position++
										case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
											position++
										case '_':
											position++
										case '-':
											position++
										default:
											if c := buffer[position]; c < rune('a') || c > rune('z') {
												goto l43
											}
											position++
										}
									}

								l48:
									{
										position49, tokenIndex49 := position, tokenIndex
										{
											switch buffer[position] {
											case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
												position++
											case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
												position++
											case '_':
												position++
											case '-':
												position++
											default:
												if c := buffer[position]; c < rune('a') || c > rune('z') {
													goto l49
												}
												position++
											}
										}

										goto l48
									l49:
										position, tokenIndex = position49, tokenIndex49
									}
									add(rulePegText, position47)
								}
								{
									add(ruleAction10, position)
								}
								add(rulefunctionName, position46)
							}
							if buffer[position] != rune('(') {
								goto l43
							}
							position++
							if buffer[position] != rune(')') {
								goto l43
							}
							position++
							add(rulePegText, position45)
						}
						{
							add(ruleAction9, position)
						}
						add(rulefunction, position44)
					}
					goto l42
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
				if !_rules[rulespace]() {
					goto l35
				}
				{
					add(ruleAction5, position)
				}
				add(rulesegments, position36)
			}
			memoize(9, position35, tokenIndex35, true)
			return true
		l35:
			memoize(9, position35, tokenIndex35, false)
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 10 segment <- <(descendantSegment / childSegment)> */
		nil,
		/* 11 descendantSegment <- <('.' '.' (bracketedSelection / memberNameShorthand) Action6)> */
		func() bool {
			if memoized, ok := memoization[memoKey{11, position}]; ok {
				return memoizedResult(memoized)
			}
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if buffer[position] != rune('.') {
					goto l56
				}
				position++
				if buffer[position] != rune('.') {
					goto l56
				}
				position++
				{
					position58, tokenIndex58 := position, tokenIndex
					if !_rules[rulebracketedSelection]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position58, tokenIndex58
					if !_rules[rulememberNameShorthand]() {
						goto l56
					}
				}
			l58:
				{
					add(ruleAction6, position)
				}
				add(ruledescendantSegment, position57)
			}
			memoize(11, position56, tokenIndex56, true)
			return true
		l56:
			memoize(11, position56, tokenIndex56, false)
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 12 childSegment <- <((<('.' memberNameShorthand)> Action7) / bracketedSelection)> */
		func() bool {
			if memoized, ok := memoization[memoKey{12, position}]; ok {
				return memoizedResult(memoized)
			}
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				{
					position63, tokenIndex63 := position, tokenIndex
					{
						position65 := position
						if buffer[position] != rune('.') {
							goto l64
						}
						position++
						if !_rules[rulememberNameShorthand]() {
							goto l64
						}
						add(rulePegText, position65)
					}
					{
						add(ruleAction7, position)
					}
					goto l63
				l64:
					position, tokenIndex = position63, tokenIndex63
					if !_rules[rulebracketedSelection]() {
						goto l61
					}
				}
			l63:
				add(rulechildSegment, position62)
			}
			memoize(12, position61, tokenIndex61, true)
			return true
		l61:
			memoize(12, position61, tokenIndex61, false)
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 13 bracketedSelection <- <(<(squareBracketStart selectors squareBracketEnd)> Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				{
					position69 := position
					{
						position70 := position
						if buffer[position] != rune('[') {
							goto l67
						}
						position++
						if !_rules[rulespace]() {
							goto l67
						}
						add(rulesquareBracketStart, position70)
					}
					{
						position71 := position
						{
							position72, tokenIndex72 := position, tokenIndex
							{
								position74 := position
								if !_rules[ruleobjectElementSelector]() {
									goto l73
								}
							l75:
								{
									position76, tokenIndex76 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l76
									}
									if !_rules[ruleobjectElementSelector]() {
										goto l76
									}
									{
										add(ruleAction12, position)
									}
									goto l75
								l76:
									position, tokenIndex = position76, tokenIndex76
								}
								{
									position78, tokenIndex78 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l78
									}
									goto l73
								l78:
									position, tokenIndex = position78, tokenIndex78
								}
								add(ruleobjectElementSelectors, position74)
							}
							goto l72
						l73:
							position, tokenIndex = position72, tokenIndex72
							{
								switch buffer[position] {
								case '(':
									{
										position80 := position
										{
											position81 := position
											position++
											if !_rules[rulespace]() {
												goto l67
											}
											add(rulescriptSelectorStart, position81)
										}
										{
											position82 := position
											{
												position83 := position
												{
													position86, tokenIndex86 := position, tokenIndex
													if !_rules[rulescriptSelectorEnd]() {
														goto l86
													}
													goto l67
												l86:
													position, tokenIndex = position86, tokenIndex86
												}
												if !matchDot() {
													goto l67
												}
											l84:
												{
													position85, tokenIndex85 := position, tokenIndex
													{
														position87, tokenIndex87 := position, tokenIndex
														if !_rules[rulescriptSelectorEnd]() {
															goto l87
														}
														goto l85
													l87:
														position, tokenIndex = position87, tokenIndex87
													}
													if !matchDot() {
														goto l85
													}
													goto l84
												l85:
													position, tokenIndex = position85, tokenIndex85
												}
												add(rulecommand, position83)
											}
											add(rulePegText, position82)
										}
										if !_rules[rulescriptSelectorEnd]() {
											goto l67
										}
										{
											add(ruleAction22, position)
										}
										add(rulescriptSelector, position80)
									}
								case '?':
									{
										position89 := position
										{
											position90 := position
											position++
											if buffer[position] != rune('(') {
												goto l67
											}
											position++
											if !_rules[rulespace]() {
												goto l67
											}
											add(rulefilterSelectorStart, position90)
										}
										if !_rules[rulequery]() {
											goto l67
										}
										{
											position91 := position
											if !_rules[rulespace]() {
												goto l67
											}
											if buffer[position] != rune(')') {
												goto l67
											}
											position++
											add(rulefilterSelectorEnd, position91)
										}
										{
											add(ruleAction23, position)
										}
										add(rulefilterSelector, position89)
									}
								default:
									{
										position93 := position
										if !_rules[rulearrayElementSelector]() {
											goto l67
										}
									l94:
										{
											position95, tokenIndex95 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l95
											}
											if !_rules[rulearrayElementSelector]() {
												goto l95
											}
											{
												add(ruleAction15, position)
											}
											goto l94
										l95:
											position, tokenIndex = position95, tokenIndex95
										}
										{
											position97, tokenIndex97 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l97
											}
											goto l67
										l97:
											position, tokenIndex = position97, tokenIndex97
										}
										add(rulearrayElementSelectors, position93)
									}
								}
							}

						}
					l72:
						add(ruleselectors, position71)
					}
					{
						position98 := position
						if !_rules[rulespace]() {
							goto l67
						}
						if buffer[position] != rune(']') {
							goto l67
						}
						position++
						add(rulesquareBracketEnd, position98)
					}
					add(rulePegText, position69)
				}
				{
					add(ruleAction8, position)
				}
				add(rulebracketedSelection, position68)
			}
			memoize(13, position67, tokenIndex67, true)
			return true
		l67:
			memoize(13, position67, tokenIndex67, false)
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 14 function <- <(<('.' functionName ('(' ')'))> Action9)> */
		nil,
		/* 15 functionName <- <(<((&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> Action10)> */
		nil,
		/* 16 memberNameShorthand <- <(wildcardSelector / (<(('\\' signsWithoutHyphenUnderscore) / (!([\x00-\x1f] / '\x7f') !signsWithoutHyphenUnderscore .))+> !('(' ')') Action11))> */
		func() bool {
			if memoized, ok := memoization[memoKey{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					{
						position106 := position
						{
							position109, tokenIndex109 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l110
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l110
							}
							goto l109
						l110:
							position, tokenIndex = position109, tokenIndex109
							{
								position111, tokenIndex111 := position, tokenIndex
								{
									position112, tokenIndex112 := position, tokenIndex
									if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
										goto l113
									}
									position++
									goto l112
								l113:
									position, tokenIndex = position112, tokenIndex112
									if buffer[position] != rune('\x7f') {
										goto l111
									}
									position++
								}
							l112:
								goto l102
							l111:
								position, tokenIndex = position111, tokenIndex111
							}
							{
								position114, tokenIndex114 := position, tokenIndex
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l114
								}
								goto l102
							l114:
								position, tokenIndex = position114, tokenIndex114
							}
							if !matchDot() {
								goto l102
							}
						}
					l109:
					l107:
						{
							position108, tokenIndex108 := position, tokenIndex
							{
								position115, tokenIndex115 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l116
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l116
								}
								goto l115
							l116:
								position, tokenIndex = position115, tokenIndex115
								{
									position117, tokenIndex117 := position, tokenIndex
									{
										position118, tokenIndex118 := position, tokenIndex
										if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
											goto l119
										}
										position++
										goto l118
									l119:
										position, tokenIndex = position118, tokenIndex118
										if buffer[position] != rune('\x7f') {
											goto l117
										}
										position++
									}
								l118:
									goto l108
								l117:
									position, tokenIndex = position117, tokenIndex117
								}
								{
									position120, tokenIndex120 := position, tokenIndex
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l120
									}
									goto l108
								l120:
									position, tokenIndex = position120, tokenIndex120
								}
								if !matchDot() {
									goto l108
								}
							}
						l115:
							goto l107
						l108:
							position, tokenIndex = position108, tokenIndex108
						}
						add(rulePegText, position106)
					}
					{
						position121, tokenIndex121 := position, tokenIndex
						if buffer[position] != rune('(') {
							goto l121
						}
						position++
						if buffer[position] != rune(')') {
							goto l121
						}
						position++
						goto l102
					l121:
						position, tokenIndex = position121, tokenIndex121
					}
					{
						add(ruleAction11, position)
					}
				}
			l104:
				add(rulememberNameShorthand, position103)
			}
			memoize(16, position102, tokenIndex102, true)
			return true
		l102:
			memoize(16, position102, tokenIndex102, false)
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 17 signsWithoutHyphenUnderscore <- <((&('{' | '|' | '}' | '~') [{-~]) | (&('`') '`') | (&('[' | '\\' | ']' | '^') [[-^]) | (&(':' | ';' | '<' | '=' | '>' | '?' | '@') [:-@]) | (&('/') '/') | (&('.') '.') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',') [ -,]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				{
					switch buffer[position] {
					case '{', '|', '}', '~':
						position++
					case '`':
						position++
					case '[', '\\', ']', '^':
						position++
					case ':', ';', '<', '=', '>', '?', '@':
						position++
					case '/':
						position++
					case '.':
						position++
					default:
						if c := buffer[position]; c < rune(' ') || c > rune(',') {
							goto l123
						}
						position++
					}
				}

				add(rulesignsWithoutHyphenUnderscore, position124)
			}
			memoize(17, position123, tokenIndex123, true)
			return true
		l123:
			memoize(17, position123, tokenIndex123, false)
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 18 selectors <- <(objectElementSelectors / ((&('(') scriptSelector) | (&('?') filterSelector) | (&(' ' | '*' | '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':') arrayElementSelectors)))> */
		nil,
		/* 19 objectElementSelectors <- <(objectElementSelector (sep objectElementSelector Action12)* !sep)> */
		nil,
		/* 20 objectElementSelector <- <(wildcardSelector / nameSelector)> */
		func() bool {
			if memoized, ok := memoization[memoKey{20, position}]; ok {
				return memoizedResult(memoized)
			}
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				{
					position130, tokenIndex130 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l131
					}
					goto l130
				l131:
					position, tokenIndex = position130, tokenIndex130
					{
						position132 := position
						if !_rules[rulelString]() {
							goto l128
						}
						{
							add(ruleAction14, position)
						}
						add(rulenameSelector, position132)
					}
				}
			l130:
				add(ruleobjectElementSelector, position129)
			}
			memoize(20, position128, tokenIndex128, true)
			return true
		l128:
			memoize(20, position128, tokenIndex128, false)
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 21 wildcardSelector <- <('*' Action13)> */
		func() bool {
			if memoized, ok := memoization[memoKey{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if buffer[position] != rune('*') {
					goto l134
				}
				position++
				{
					add(ruleAction13, position)
				}
				add(rulewildcardSelector, position135)
			}
			memoize(21, position134, tokenIndex134, true)
			return true
		l134:
			memoize(21, position134, tokenIndex134, false)
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 22 nameSelector <- <(lString Action14)> */
		nil,
		/* 23 arrayElementSelectors <- <(arrayElementSelector (sep arrayElementSelector Action15)* !sep)> */
		nil,
		/* 24 arrayElementSelector <- <(((arraySliceSelector Action16) / (<indexSelector> Action17) / ('*' Action18)) Action19)> */
		func() bool {
			if memoized, ok := memoization[memoKey{24, position}]; ok {
				return memoizedResult(memoized)
			}
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				{
					position141, tokenIndex141 := position, tokenIndex
					{
						position143 := position
						if !_rules[ruleanyIndex]() {
							goto l142
						}
						if !_rules[rulesepArraySlice]() {
							goto l142
						}
						if !_rules[ruleanyIndex]() {
							goto l142
						}
						{
							position144, tokenIndex144 := position, tokenIndex
							if !_rules[rulesepArraySlice]() {
								goto l145
							}
							if !_rules[ruleanyIndex]() {
								goto l145
							}
							goto l144
						l145:
							position, tokenIndex = position144, tokenIndex144
							if !_rules[rulespace]() {
								goto l142
							}
							{
								add(ruleAction20, position)
							}
						}
					l144:
						add(rulearraySliceSelector, position143)
					}
					{
						add(ruleAction16, position)
					}
					goto l141
				l142:
					position, tokenIndex = position141, tokenIndex141
					{
						position149 := position
						{
							position150 := position
							if !_rules[ruleindexNumber]() {
								goto l148
							}
							add(ruleindexSelector, position150)
						}
						add(rulePegText, position149)
					}
					{
						add(ruleAction17, position)
					}
					goto l141
				l148:
					position, tokenIndex = position141, tokenIndex141
					if buffer[position] != rune('*') {
						goto l139
					}
					position++
					{
						add(ruleAction18, position)
					}
				}
			l141:
				{
					add(ruleAction19, position)
				}
				add(rulearrayElementSelector, position140)
			}
			memoize(24, position139, tokenIndex139, true)
			return true
		l139:
			memoize(24, position139, tokenIndex139, false)
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 25 arraySliceSelector <- <(anyIndex sepArraySlice anyIndex ((sepArraySlice anyIndex) / (space Action20)))> */
		nil,
		/* 26 anyIndex <- <(<indexNumber?> Action21)> */
		func() bool {
			if memoized, ok := memoization[memoKey{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				{
					position157 := position
					{
						position158, tokenIndex158 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l158
						}
						goto l159
					l158:
						position, tokenIndex = position158, tokenIndex158
					}
				l159:
					add(rulePegText, position157)
				}
				{
					add(ruleAction21, position)
				}
				add(ruleanyIndex, position156)
			}
			memoize(26, position155, tokenIndex155, true)
			return true
		},
		/* 27 indexSelector <- <indexNumber> */
		nil,
		/* 28 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			if memoized, ok := memoization[memoKey{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					position164, tokenIndex164 := position, tokenIndex
					{
						position166, tokenIndex166 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l167
						}
						position++
						goto l166
					l167:
						position, tokenIndex = position166, tokenIndex166
						if buffer[position] != rune('+') {
							goto l164
						}
						position++
					}
				l166:
					goto l165
				l164:
					position, tokenIndex = position164, tokenIndex164
				}
			l165:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l162
				}
				position++
			l168:
				{
					position169, tokenIndex169 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l169
					}
					position++
					goto l168
				l169:
					position, tokenIndex = position169, tokenIndex169
				}
				add(ruleindexNumber, position163)
			}
			memoize(28, position162, tokenIndex162, true)
			return true
		l162:
			memoize(28, position162, tokenIndex162, false)
			position, tokenIndex = position162, tokenIndex162
			return false
		},
		/* 29 sep <- <(space ',' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				if !_rules[rulespace]() {
					goto l170
				}
				if buffer[position] != rune(',') {
					goto l170
				}
				position++
				if !_rules[rulespace]() {
					goto l170
				}
				add(rulesep, position171)
			}
			memoize(29, position170, tokenIndex170, true)
			return true
		l170:
			memoize(29, position170, tokenIndex170, false)
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 30 sepArraySlice <- <(space ':' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{30, position}]; ok {
				return memoizedResult(memoized)
			}
			position172, tokenIndex172 := position, tokenIndex
			{
				position173 := position
				if !_rules[rulespace]() {
					goto l172
				}
				if buffer[position] != rune(':') {
					goto l172
				}
				position++
				if !_rules[rulespace]() {
					goto l172
				}
				add(rulesepArraySlice, position173)
			}
			memoize(30, position172, tokenIndex172, true)
			return true
		l172:
			memoize(30, position172, tokenIndex172, false)
			position, tokenIndex = position172, tokenIndex172
			return false
		},
		/* 31 scriptSelector <- <(scriptSelectorStart <command> scriptSelectorEnd Action22)> */
		nil,
		/* 32 command <- <(!scriptSelectorEnd .)+> */
		nil,
		/* 33 filterSelector <- <(filterSelectorStart query filterSelectorEnd Action23)> */
		nil,
		/* 34 query <- <(andQuery (logicOr andQuery Action24)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{34, position}]; ok {
				return memoizedResult(memoized)
			}
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				if !_rules[ruleandQuery]() {
					goto l177
				}
			l179:
				{
					position180, tokenIndex180 := position, tokenIndex
					{
						position181 := position
						if !_rules[rulespace]() {
							goto l180
						}
						if buffer[position] != rune('|') {
							goto l180
						}
						position++
						if buffer[position] != rune('|') {
							goto l180
						}
						position++
						if !_rules[rulespace]() {
							goto l180
						}
						add(rulelogicOr, position181)
					}
					if !_rules[ruleandQuery]() {
						goto l180
					}
					{
						add(ruleAction24, position)
					}
					goto l179
				l180:
					position, tokenIndex = position180, tokenIndex180
				}
				add(rulequery, position178)
			}
			memoize(34, position177, tokenIndex177, true)
			return true
		l177:
			memoize(34, position177, tokenIndex177, false)
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 35 andQuery <- <(basicQuery (logicAnd basicQuery Action25)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{35, position}]; ok {
				return memoizedResult(memoized)
			}
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				if !_rules[rulebasicQuery]() {
					goto l183
				}
			l185:
				{
					position186, tokenIndex186 := position, tokenIndex
					{
						position187 := position
						if !_rules[rulespace]() {
							goto l186
						}
						if buffer[position] != rune('&') {
							goto l186
						}
						position++
						if buffer[position] != rune('&') {
							goto l186
						}
						position++
						if !_rules[rulespace]() {
							goto l186
						}
						add(rulelogicAnd, position187)
					}
					if !_rules[rulebasicQuery]() {
						goto l186
					}
					{
						add(ruleAction25, position)
					}
					goto l185
				l186:
					position, tokenIndex = position186, tokenIndex186
				}
				add(ruleandQuery, position184)
			}
			memoize(35, position183, tokenIndex183, true)
			return true
		l183:
			memoize(35, position183, tokenIndex183, false)
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 36 basicQuery <- <((<comparator> Action26) / (<(logicNot? jsonpathFilter)> Action27) / ((&('!') (logicNot <lBool> Action29)) | (&('(') (subQueryStart query subQueryEnd)) | (&('F' | 'T' | 'f' | 't') (<lBool> Action28))))> */
		func() bool {
			if memoized, ok := memoization[memoKey{36, position}]; ok {
				return memoizedResult(memoized)
			}
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				{
					position191, tokenIndex191 := position, tokenIndex
					{
						position193 := position
						{
							position194 := position
							{
								position195, tokenIndex195 := position, tokenIndex
								if !_rules[ruleqParam]() {
									goto l196
								}
								if !_rules[rulespace]() {
									goto l196
								}
								{
									position197, tokenIndex197 := position, tokenIndex
									if buffer[position] != rune('=') {
										goto l198
									}
									position++
									if buffer[position] != rune('=') {
										goto l198
									}
									position++
									if !_rules[rulespace]() {
										goto l198
									}
									if !_rules[ruleqParam]() {
										goto l198
									}
									{
										add(ruleAction30, position)
									}
									goto l197
								l198:
									position, tokenIndex = position197, tokenIndex197
									if buffer[position] != rune('!') {
										goto l196
									}
									position++
									if buffer[position] != rune('=') {
										goto l196
									}
									position++
									if !_rules[rulespace]() {
										goto l196
									}
									if !_rules[ruleqParam]() {
										goto l196
									}
									{
										add(ruleAction31, position)
									}
								}
							l197:
								goto l195
							l196:
								position, tokenIndex = position195, tokenIndex195
								if !_rules[ruleqNumericParam]() {
									goto l201
								}
								if !_rules[rulespace]() {
									goto l201
								}
								{
									position202, tokenIndex202 := position, tokenIndex
									if buffer[position] != rune('<') {
										goto l203
									}
									position++
									if buffer[position] != rune('=') {
										goto l203
									}
									position++
									if !_rules[rulespace]() {
										goto l203
									}
									if !_rules[ruleqNumericParam]() {
										goto l203
									}
									{
										add(ruleAction32, position)
									}
									goto l202
								l203:
									position, tokenIndex = position202, tokenIndex202
									if buffer[position] != rune('<') {
										goto l205
									}
									position++
									if !_rules[rulespace]() {
										goto l205
									}
									if !_rules[ruleqNumericParam]() {
										goto l205
									}
									{
										add(ruleAction33, position)
									}
									goto l202
								l205:
									position, tokenIndex = position202, tokenIndex202
									if buffer[position] != rune('>') {
										goto l207
									}
									position++
									if buffer[position] != rune('=') {
										goto l207
									}
									position++
									if !_rules[rulespace]() {
										goto l207
									}
									if !_rules[ruleqNumericParam]() {
										goto l207
									}
									{
										add(ruleAction34, position)
									}
									goto l202
								l207:
									position, tokenIndex = position202, tokenIndex202
									if buffer[position] != rune('>') {
										goto l201
									}
									position++
									if !_rules[rulespace]() {
										goto l201
									}
									if !_rules[ruleqNumericParam]() {
										goto l201
									}
									{
										add(ruleAction35, position)
									}
								}
							l202:
								goto l195
							l201:
								position, tokenIndex = position195, tokenIndex195
								if !_rules[rulesingleJsonpathFilter]() {
									goto l192
								}
								if !_rules[rulespace]() {
									goto l192
								}
								if buffer[position] != rune('=') {
									goto l192
								}
								position++
								if buffer[position] != rune('~') {
									goto l192
								}
								position++
								if !_rules[rulespace]() {
									goto l192
								}
								if buffer[position] != rune('/') {
									goto l192
								}
								position++
								{
									position210 := position
									{
										position211 := position
									l212:
										{
											position213, tokenIndex213 := position, tokenIndex
											{
												position214, tokenIndex214 := position, tokenIndex
												if buffer[position] != rune('\\') {
													goto l215
												}
												position++
												{
													position216, tokenIndex216 := position, tokenIndex
													if buffer[position] != rune('\\') {
														goto l217
													}
													position++
													goto l216
												l217:
													position, tokenIndex = position216, tokenIndex216
													if buffer[position] != rune('/') {
														goto l215
													}
													position++
												}
											l216:
												goto l214
											l215:
												position, tokenIndex = position214, tokenIndex214
												{
													position218, tokenIndex218 := position, tokenIndex
													if buffer[position] != rune('/') {
														goto l218
													}
													position++
													goto l213
												l218:
													position, tokenIndex = position218, tokenIndex218
												}
												if !matchDot() {
													goto l213
												}
											}
										l214:
											goto l212
										l213:
											position, tokenIndex = position213, tokenIndex213
										}
										add(ruleregex, position211)
									}
									add(rulePegText, position210)
								}
								if buffer[position] != rune('/') {
									goto l192
								}
								position++
								{
									add(ruleAction36, position)
								}
							}
						l195:
							add(rulecomparator, position194)
						}
						add(rulePegText, position193)
					}
					{
						add(ruleAction26, position)
					}
					goto l191
				l192:
					position, tokenIndex = position191, tokenIndex191
					{
						position222 := position
						{
							position223, tokenIndex223 := position, tokenIndex
							if !_rules[rulelogicNot]() {
								goto l223
							}
							goto l224
						l223:
							position, tokenIndex = position223, tokenIndex223
						}
					l224:
						if !_rules[rulejsonpathFilter]() {
							goto l221
						}
						add(rulePegText, position222)
					}
					{
						add(ruleAction27, position)
					}
					goto l191
				l221:
					position, tokenIndex = position191, tokenIndex191
					{
						switch buffer[position] {
						case '!':
							if !_rules[rulelogicNot]() {
								goto l189
							}
							{
								position227 := position
								if !_rules[rulelBool]() {
									goto l189
								}
								add(rulePegText, position227)
							}
							{
								add(ruleAction29, position)
							}
						case '(':
							{
								position229 := position
								position++
								if !_rules[rulespace]() {
									goto l189
								}
								add(rulesubQueryStart, position229)
							}
							if !_rules[rulequery]() {
								goto l189
							}
							{
								position230 := position
								if !_rules[rulespace]() {
									goto l189
								}
								if buffer[position] != rune(')') {
									goto l189
								}
								position++
								add(rulesubQueryEnd, position230)
							}
						default:
							{
								position231 := position
								if !_rules[rulelBool]() {
									goto l189
								}
								add(rulePegText, position231)
							}
							{
								add(ruleAction28, position)
							}
						}
					}

				}
			l191:
				add(rulebasicQuery, position190)
			}
			memoize(36, position189, tokenIndex189, true)
			return true
		l189:
			memoize(36, position189, tokenIndex189, false)
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 37 logicOr <- <(space ('|' '|') space)> */
		nil,
		/* 38 logicAnd <- <(space ('&' '&') space)> */
		nil,
		/* 39 logicNot <- <('!' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				if buffer[position] != rune('!') {
					goto l235
				}
				position++
				if !_rules[rulespace]() {
					goto l235
				}
				add(rulelogicNot, position236)
			}
			memoize(39, position235, tokenIndex235, true)
			return true
		l235:
			memoize(39, position235, tokenIndex235, false)
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 40 comparator <- <((qParam space (('=' '=' space qParam Action30) / ('!' '=' space qParam Action31))) / (qNumericParam space (('<' '=' space qNumericParam Action32) / ('<' space qNumericParam Action33) / ('>' '=' space qNumericParam Action34) / ('>' space qNumericParam Action35))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action36))> */
		nil,
		/* 41 qParam <- <((qLiteral Action37) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey{41, position}]; ok {
				return memoizedResult(memoized)
			}
			position238, tokenIndex238 := position, tokenIndex
			{
				position239 := position
				{
					position240, tokenIndex240 := position, tokenIndex
					{
						position242 := position
						{
							switch buffer[position] {
							case 'N', 'n':
								{
									position244 := position
									{
										position245, tokenIndex245 := position, tokenIndex
										if buffer[position] != rune('n') {
											goto l246
										}
										position++
										if buffer[position] != rune('u') {
											goto l246
										}
										position++
										if buffer[position] != rune('l') {
											goto l246
										}
										position++
										if buffer[position] != rune('l') {
											goto l246
										}
										position++
										goto l245
									l246:
										position, tokenIndex = position245, tokenIndex245
										if buffer[position] != rune('N') {
											goto l247
										}
										position++
										if buffer[position] != rune('u') {
											goto l247
										}
										position++
										if buffer[position] != rune('l') {
											goto l247
										}
										position++
										if buffer[position] != rune('l') {
											goto l247
										}
										position++
										goto l245
									l247:
										position, tokenIndex = position245, tokenIndex245
										if buffer[position] != rune('N') {
											goto l241
										}
										position++
										if buffer[position] != rune('U') {
											goto l241
										}
										position++
										if buffer[position] != rune('L') {
											goto l241
										}
										position++
										if buffer[position] != rune('L') {
											goto l241
										}
										position++
									}
								l245:
									{
										add(ruleAction47, position)
									}
									add(rulelNull, position244)
								}
							case '"', '\'':
								if !_rules[rulelString]() {
									goto l241
								}
							case 'F', 'T', 'f', 't':
								if !_rules[rulelBool]() {
									goto l241
								}
							default:
								if !_rules[rulelNumber]() {
									goto l241
								}
							}
						}

						add(ruleqLiteral, position242)
					}
					{
						add(ruleAction37, position)
					}
					goto l240
				l241:
					position, tokenIndex = position240, tokenIndex240
					if !_rules[rulesingleJsonpathFilter]() {
						goto l238
					}
				}
			l240:
				add(ruleqParam, position239)
			}
			memoize(41, position238, tokenIndex238, true)
			return true
		l238:
			memoize(41, position238, tokenIndex238, false)
			position, tokenIndex = position238, tokenIndex238
			return false
		},
		/* 42 qNumericParam <- <((lNumber Action38) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey{42, position}]; ok {
				return memoizedResult(memoized)
			}
			position250, tokenIndex250 := position, tokenIndex
			{
				position251 := position
				{
					position252, tokenIndex252 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l253
					}
					{
						add(ruleAction38, position)
					}
					goto l252
				l253:
					position, tokenIndex = position252, tokenIndex252
					if !_rules[rulesingleJsonpathFilter]() {
						goto l250
					}
				}
			l252:
				add(ruleqNumericParam, position251)
			}
			memoize(42, position250, tokenIndex250, true)
			return true
		l250:
			memoize(42, position250, tokenIndex250, false)
			position, tokenIndex = position250, tokenIndex250
			return false
		},
		/* 43 qLiteral <- <((&('N' | 'n') lNull) | (&('"' | '\'') lString) | (&('F' | 'T' | 'f' | 't') lBool) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') lNumber))> */
		nil,
		/* 44 singleJsonpathFilter <- <(<jsonpathFilter> Action39)> */
		func() bool {
			if memoized, ok := memoization[memoKey{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				{
					position258 := position
					if !_rules[rulejsonpathFilter]() {
						goto l256
					}
					add(rulePegText, position258)
				}
				{
					add(ruleAction39, position)
				}
				add(rulesingleJsonpathFilter, position257)
			}
			memoize(44, position256, tokenIndex256, true)
			return true
		l256:
			memoize(44, position256, tokenIndex256, false)
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 45 jsonpathFilter <- <(Action40 jsonpathParameter Action41)> */
		func() bool {
			if memoized, ok := memoization[memoKey{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position260, tokenIndex260 := position, tokenIndex
			{
				position261 := position
				{
					add(ruleAction40, position)
				}
				{
					position263 := position
					if !_rules[rulespace]() {
						goto l260
					}
					{
						position264 := position
						{
							position265, tokenIndex265 := position, tokenIndex
							if !_rules[rulerootIdentifier]() {
								goto l266
							}
							goto l265
						l266:
							position, tokenIndex = position265, tokenIndex265
							{
								position267 := position
								if buffer[position] != rune('@') {
									goto l260
								}
								position++
								{
									add(ruleAction4, position)
								}
								add(rulecurrentNodeIdentifier, position267)
							}
						}
					l265:
						add(ruleparameterRootNode, position264)
					}
					if !_rules[rulesegments]() {
						goto l260
					}
					add(rulejsonpathParameter, position263)
				}
				{
					add(ruleAction41, position)
				}
				add(rulejsonpathFilter, position261)
			}
			memoize(45, position260, tokenIndex260, true)
			return true
		l260:
			memoize(45, position260, tokenIndex260, false)
			position, tokenIndex = position260, tokenIndex260
			return false
		},
		/* 46 lNumber <- <(<(('-' / '+')? [0-9] ((&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('.') '.') | (&('+') '+') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action42)> */
		func() bool {
			if memoized, ok := memoization[memoKey{46, position}]; ok {
				return memoizedResult(memoized)
			}
			position270, tokenIndex270 := position, tokenIndex
			{
				position271 := position
				{
					position272 := position
					{
						position273, tokenIndex273 := position, tokenIndex
						{
							position275, tokenIndex275 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l276
							}
							position++
							goto l275
						l276:
							position, tokenIndex = position275, tokenIndex275
							if buffer[position] != rune('+') {
								goto l273
							}
							position++
						}
					l275:
						goto l274
					l273:
						position, tokenIndex = position273, tokenIndex273
					}
				l274:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l270
					}
					position++
				l277:
					{
						position278, tokenIndex278 := position, tokenIndex
						{
							switch buffer[position] {
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								position++
							case '.':
								position++
							case '+':
								position++
							case '-':
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								position++
							default:
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l278
								}
								position++
							}
						}

						goto l277
					l278:
						position, tokenIndex = position278, tokenIndex278
					}
					add(rulePegText, position272)
				}
				{
					add(ruleAction42, position)
				}
				add(rulelNumber, position271)
			}
			memoize(46, position270, tokenIndex270, true)
			return true
		l270:
			memoize(46, position270, tokenIndex270, false)
			position, tokenIndex = position270, tokenIndex270
			return false
		},
		/* 47 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action43) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action44))> */
		func() bool {
			if memoized, ok := memoization[memoKey{47, position}]; ok {
				return memoizedResult(memoized)
			}
			position281, tokenIndex281 := position, tokenIndex
			{
				position282 := position
				{
					position283, tokenIndex283 := position, tokenIndex
					{
						position285, tokenIndex285 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l286
						}
						position++
						if buffer[position] != rune('r') {
							goto l286
						}
						position++
						if buffer[position] != rune('u') {
							goto l286
						}
						position++
						if buffer[position] != rune('e') {
							goto l286
						}
						position++
						goto l285
					l286:
						position, tokenIndex = position285, tokenIndex285
						if buffer[position] != rune('T') {
							goto l287
						}
						position++
						if buffer[position] != rune('r') {
							goto l287
						}
						position++
						if buffer[position] != rune('u') {
							goto l287
						}
						position++
						if buffer[position] != rune('e') {
							goto l287
						}
						position++
						goto l285
					l287:
						position, tokenIndex = position285, tokenIndex285
						if buffer[position] != rune('T') {
							goto l284
						}
						position++
						if buffer[position] != rune('R') {
							goto l284
						}
						position++
						if buffer[position] != rune('U') {
							goto l284
						}
						position++
						if buffer[position] != rune('E') {
							goto l284
						}
						position++
					}
				l285:
					{
						add(ruleAction43, position)
					}
					goto l283
				l284:
					position, tokenIndex = position283, tokenIndex283
					{
						position289, tokenIndex289 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l290
						}
						position++
						if buffer[position] != rune('a') {
							goto l290
						}
						position++
						if buffer[position] != rune('l') {
							goto l290
						}
						position++
						if buffer[position] != rune('s') {
							goto l290
						}
						position++
						if buffer[position] != rune('e') {
							goto l290
						}
						position++
						goto l289
					l290:
						position, tokenIndex = position289, tokenIndex289
						if buffer[position] != rune('F') {
							goto l291
						}
						position++
						if buffer[position] != rune('a') {
							goto l291
						}
						position++
						if buffer[position] != rune('l') {
							goto l291
						}
						position++
						if buffer[position] != rune('s') {
							goto l291
						}
						position++
						if buffer[position] != rune('e') {
							goto l291
						}
						position++
						goto l289
					l291:
						position, tokenIndex = position289, tokenIndex289
						if buffer[position] != rune('F') {
							goto l281
						}
						position++
						if buffer[position] != rune('A') {
							goto l281
						}
						position++
						if buffer[position] != rune('L') {
							goto l281
						}
						position++
						if buffer[position] != rune('S') {
							goto l281
						}
						position++
						if buffer[position] != rune('E') {
							goto l281
						}
						position++
					}
				l289:
					{
						add(ruleAction44, position)
					}
				}
			l283:
				add(rulelBool, position282)
			}
			memoize(47, position281, tokenIndex281, true)
			return true
		l281:
			memoize(47, position281, tokenIndex281, false)
			position, tokenIndex = position281, tokenIndex281
			return false
		},
		/* 48 lString <- <(('\'' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('\'') '\''))) / (!('\'' / '\\') .))*> '\'' Action45) / ('"' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('"') '"'))) / (!('"' / '\\') .))*> '"' Action46))> */
		func() bool {
			if memoized, ok := memoization[memoKey{48, position}]; ok {
				return memoizedResult(memoized)
			}
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				{
					position295, tokenIndex295 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l296
					}
					position++
					{
						position297 := position
					l298:
						{
							position299, tokenIndex299 := position, tokenIndex
							{
								position300, tokenIndex300 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l301
								}
								position++
								{
									switch buffer[position] {
									case 'u':
										if !_rules[rulehexDigits]() {
											goto l301
										}
									case 't':
										position++
									case 'r':
										position++
									case 'n':
										position++
									case 'f':
										position++
									case 'b':
										position++
									case '\\':
										position++
									case '/':
										position++
									default:
										if buffer[position] != rune('\'') {
											goto l301
										}
										position++
									}
								}

								goto l300
							l301:
								position, tokenIndex = position300, tokenIndex300
								{
									position303, tokenIndex303 := position, tokenIndex
									{
										position304, tokenIndex304 := position, tokenIndex
										if buffer[position] != rune('\'') {
											goto l305
										}
										position++
										goto l304
									l305:
										position, tokenIndex = position304, tokenIndex304
										if buffer[position] != rune('\\') {
											goto l303
										}
										position++
									}
								l304:
									goto l299
								l303:
									position, tokenIndex = position303, tokenIndex303
								}
								if !matchDot() {
									goto l299
								}
							}
						l300:
							goto l298
						l299:
							position, tokenIndex = position299, tokenIndex299
						}
						add(rulePegText, position297)
					}
					if buffer[position] != rune('\'') {
						goto l296
					}
					position++
					{
						add(ruleAction45, position)
					}
					goto l295
				l296:
					position, tokenIndex = position295, tokenIndex295
					if buffer[position] != rune('"') {
						goto l293
					}
					position++
					{
						position307 := position
					l308:
						{
							position309, tokenIndex309 := position, tokenIndex
							{
								position310, tokenIndex310 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l311
								}
								position++
								{
									switch buffer[position] {
									case 'u':
										if !_rules[rulehexDigits]() {
											goto l311
										}
									case 't':
										position++
									case 'r':
										position++
									case 'n':
										position++
									case 'f':
										position++
									case 'b':
										position++
									case '\\':
										position++
									case '/':
										position++
									default:
										if buffer[position] != rune('"') {
											goto l311
										}
										position++
									}
								}

								goto l310
							l311:
								position, tokenIndex = position310, tokenIndex310
								{
									position313, tokenIndex313 := position, tokenIndex
									{
										position314, tokenIndex314 := position, tokenIndex
										if buffer[position] != rune('"') {
											goto l315
										}
										position++
										goto l314
									l315:
										position, tokenIndex = position314, tokenIndex314
										if buffer[position] != rune('\\') {
											goto l313
										}
										position++
									}
								l314:
									goto l309
								l313:
									position, tokenIndex = position313, tokenIndex313
								}
								if !matchDot() {
									goto l309
								}
							}
						l310:
							goto l308
						l309:
							position, tokenIndex = position309, tokenIndex309
						}
						add(rulePegText, position307)
					}
					if buffer[position] != rune('"') {
						goto l293
					}
					position++
					{
						add(ruleAction46, position)
					}
				}
			l295:
				add(rulelString, position294)
			}
			memoize(48, position293, tokenIndex293, true)
			return true
		l293:
			memoize(48, position293, tokenIndex293, false)
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 49 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			if memoized, ok := memoization[memoKey{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if buffer[position] != rune('u') {
					goto l317
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l317
				}
				if !_rules[rulehexDigit]() {
					goto l317
				}
				if !_rules[rulehexDigit]() {
					goto l317
				}
				if !_rules[rulehexDigit]() {
					goto l317
				}
				add(rulehexDigits, position318)
			}
			memoize(49, position317, tokenIndex317, true)
			return true
		l317:
			memoize(49, position317, tokenIndex317, false)
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 50 hexDigit <- <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{50, position}]; ok {
				return memoizedResult(memoized)
			}
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				{
					switch buffer[position] {
					case 'A', 'B', 'C', 'D', 'E', 'F':
						position++
					case 'a', 'b', 'c', 'd', 'e', 'f':
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l319
						}
						position++
					}
				}

				add(rulehexDigit, position320)
			}
			memoize(50, position319, tokenIndex319, true)
			return true
		l319:
			memoize(50, position319, tokenIndex319, false)
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 51 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action47)> */
		nil,
		/* 52 regex <- <(('\\' ('\\' / '/')) / (!'/' .))*> */
		nil,
		/* 53 squareBracketStart <- <('[' space)> */
		nil,
		/* 54 squareBracketEnd <- <(space ']')> */
		nil,
		/* 55 scriptSelectorStart <- <('(' space)> */
		nil,
		/* 56 scriptSelectorEnd <- <(space ')')> */
		func() bool {
			if memoized, ok := memoization[memoKey{56, position}]; ok {
				return memoizedResult(memoized)
			}
			position327, tokenIndex327 := position, tokenIndex
			{
				position328 := position
				if !_rules[rulespace]() {
					goto l327
				}
				if buffer[position] != rune(')') {
					goto l327
				}
				position++
				add(rulescriptSelectorEnd, position328)
			}
			memoize(56, position327, tokenIndex327, true)
			return true
		l327:
			memoize(56, position327, tokenIndex327, false)
			position, tokenIndex = position327, tokenIndex327
			return false
		},
		/* 57 filterSelectorStart <- <('?' '(' space)> */
		nil,
		/* 58 filterSelectorEnd <- <(space ')')> */
		nil,
		/* 59 subQueryStart <- <('(' space)> */
		nil,
		/* 60 subQueryEnd <- <(space ')')> */
		nil,
		/* 61 space <- <' '*> */
		func() bool {
			if memoized, ok := memoization[memoKey{61, position}]; ok {
				return memoizedResult(memoized)
			}
			position333, tokenIndex333 := position, tokenIndex
			{
				position334 := position
			l335:
				{
					position336, tokenIndex336 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l336
					}
					position++
					goto l335
				l336:
					position, tokenIndex = position336, tokenIndex336
				}
				add(rulespace, position334)
			}
			memoize(61, position333, tokenIndex333, true)
			return true
		},
		/* 63 Action0 <- <{
		    p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
		    p.setConnectedText(p.root)
		}> */
		nil,
		nil,
		/* 65 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		nil,
		/* 66 Action2 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 67 Action3 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 68 Action4 <- <{
		    p.pushCurrentNodeIdentifier()
		}> */
		nil,
		/* 69 Action5 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		nil,
		/* 70 Action6 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		nil,
		/* 71 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		nil,
		/* 72 Action8 <- <{
		    p.setLastNodeText(text)
		}> */
		nil,
		/* 73 Action9 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		nil,
		/* 74 Action10 <- <{
		    p.push(text)
		}> */
		nil,
		/* 75 Action11 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		nil,
		/* 76 Action12 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		nil,
		/* 77 Action13 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		nil,
		/* 78 Action14 <- <{
		    p.pushChildSingleIdentifier(p.pop().(string))
		}> */
		nil,
		/* 79 Action15 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		nil,
		/* 80 Action16 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted {
		        step.number = 1
		    }

		    if step.number >= 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		nil,
		/* 81 Action17 <- <{
		    p.pushIndexSubscript(text)
		}> */
		nil,
		/* 82 Action18 <- <{
		    p.pushWildcardSubscript()
		}> */
		nil,
		/* 83 Action19 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		nil,
		/* 84 Action20 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		nil,
		/* 85 Action21 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		nil,
		/* 86 Action22 <- <{
		    p.pushScriptQualifier(text)
		}> */
		nil,
		/* 87 Action23 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		nil,
		/* 88 Action24 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		nil,
		/* 89 Action25 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		nil,
		/* 90 Action26 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		        _, leftIsCurrentNode := checkQuery.leftParam.param.(*syntaxQueryParamCurrentNode)
		        _, rightIsCurrentNode := checkQuery.rightParam.param.(*syntaxQueryParamCurrentNode)
		        if leftIsCurrentNode && rightIsCurrentNode {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		nil,
		/* 91 Action27 <- <{
		    _ = p.pop()
		    jsonpathFilter := p.pop().(syntaxQuery)

		    if text[0:1] == `!` {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		nil,
		/* 92 Action28 <- <{
		    boolValue := p.pop().(bool)
		    p.pushBooleanLiteralQuery(boolValue)
		}> */
		nil,
		/* 93 Action29 <- <{
		    boolValue := p.pop().(bool)
		    p.pushBooleanLiteralQuery(!boolValue)
		}> */
		nil,
		/* 94 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		nil,
		/* 95 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		nil,
		/* 96 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		nil,
		/* 97 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		nil,
		/* 98 Action34 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		nil,
		/* 99 Action35 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		nil,
		/* 100 Action36 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		nil,
		/* 101 Action37 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 102 Action38 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 103 Action39 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		nil,
		/* 104 Action40 <- <{
		    p.saveParams()
		}> */
		nil,
		/* 105 Action41 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootNodeIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
		        p.push(true)
		    case *syntaxCurrentNodeIdentifier:
		        p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
		        p.push(false)
		    }
		}> */
		nil,
		/* 106 Action42 <- <{
		    p.push(p.toFloat(text))
		}> */
		nil,
		/* 107 Action43 <- <{
		    p.push(true)
		}> */
		nil,
		/* 108 Action44 <- <{
		    p.push(false)
		}> */
		nil,
		/* 109 Action45 <- <{
		    p.push(p.unescapeSingleQuotedString(text))
		}> */
		nil,
		/* 110 Action46 <- <{
		    p.push(p.unescapeDoubleQuotedString(text))
		}> */
		nil,
		/* 111 Action47 <- <{
		    p.push(nil)
		}> */
		nil,
	}
	p.rules = _rules
	return nil
}
