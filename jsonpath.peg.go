package jsonpath

// Code generated by peg jsonpath.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpath
	rulejsonpathParameter
	rulecontinuedJsonpath
	rulerootNode
	ruleparameterRootNode
	rulechildNode
	rulefunction
	rulefunctionName
	rulebracketNode
	rulerootIdentifier
	rulecurrentRootIdentifier
	ruledotChildIdentifier
	rulesignsWithoutHyphenUnderscore
	rulebracketChildIdentifier
	rulebracketNodeIdentifier
	rulewildcardIdentifier
	rulesingleQuotedNodeIdentifier
	ruledoubleQuotedNodeIdentifier
	rulehexDigits
	rulehexDigit
	rulequalifier
	ruleunion
	ruleindex
	ruleslice
	ruleanyIndex
	ruleindexNumber
	rulesep
	rulesepSlice
	rulescript
	rulecommand
	rulefilter
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptStart
	rulescriptEnd
	rulefilterStart
	rulefilterEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpath",
	"jsonpathParameter",
	"continuedJsonpath",
	"rootNode",
	"parameterRootNode",
	"childNode",
	"function",
	"functionName",
	"bracketNode",
	"rootIdentifier",
	"currentRootIdentifier",
	"dotChildIdentifier",
	"signsWithoutHyphenUnderscore",
	"bracketChildIdentifier",
	"bracketNodeIdentifier",
	"wildcardIdentifier",
	"singleQuotedNodeIdentifier",
	"doubleQuotedNodeIdentifier",
	"hexDigits",
	"hexDigit",
	"qualifier",
	"union",
	"index",
	"slice",
	"anyIndex",
	"indexNumber",
	"sep",
	"sepSlice",
	"script",
	"command",
	"filter",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptStart",
	"scriptEnd",
	"filterStart",
	"filterEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type pegJSONPathParser struct {
	jsonPathParser

	Buffer string
	buffer []rune
	rules  [107]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *pegJSONPathParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *pegJSONPathParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *pegJSONPathParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootIdentifier(p.pop().(syntaxNode))
			p.setConnectedText(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction3:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction4:

			p.setLastNodeText(text)

		case ruleAction5:

			p.pushFunction(text, p.pop().(string))

		case ruleAction6:

			p.push(text)

		case ruleAction7:

			p.setLastNodeText(text)

		case ruleAction8:

			p.pushRootIdentifier()

		case ruleAction9:

			p.pushCurrentRootIdentifier()

		case ruleAction10:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction11:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction12:

			p.pushChildWildcardIdentifier()

		case ruleAction13:

			p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))

		case ruleAction14:

			p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))

		case ruleAction15:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction16:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted {
				step.number = 1
			}

			if step.number >= 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction17:

			p.pushIndexSubscript(text)

		case ruleAction18:

			p.pushWildcardSubscript()

		case ruleAction19:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction20:

			p.pushIndexSubscript(`1`)

		case ruleAction21:

			if len(text) > 0 {
				p.pushIndexSubscript(text)
			} else {
				p.pushOmittedIndexSubscript(`0`)
			}

		case ruleAction22:

			p.pushScriptQualifier(text)

		case ruleAction23:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction24:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction25:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction26:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
				_, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
				_, rightIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
				if leftIsCurrentRoot && rightIsCurrentRoot {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction27:

			_ = p.pop()
			jsonpathFilter := p.pop().(syntaxQuery)
			if text[0:1] == `!` {
				p.pushLogicalNot(jsonpathFilter)
			} else {
				p.push(jsonpathFilter)
			}

		case ruleAction28:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			if leftParam.isLiteral {
				p.pushCompareEQ(rightParam, leftParam)
			} else {
				p.pushCompareEQ(leftParam, rightParam)
			}

		case ruleAction29:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			if leftParam.isLiteral {
				p.pushCompareNE(rightParam, leftParam)
			} else {
				p.pushCompareNE(leftParam, rightParam)
			}

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			if leftParam.isLiteral {
				p.pushCompareLE(rightParam, leftParam)
			} else {
				p.pushCompareGE(leftParam, rightParam)
			}

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			if leftParam.isLiteral {
				p.pushCompareLT(rightParam, leftParam)
			} else {
				p.pushCompareGT(leftParam, rightParam)
			}

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			if leftParam.isLiteral {
				p.pushCompareGE(rightParam, leftParam)
			} else {
				p.pushCompareLE(leftParam, rightParam)
			}

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			if leftParam.isLiteral {
				p.pushCompareGT(rightParam, leftParam)
			} else {
				p.pushCompareLT(leftParam, rightParam)
			}

		case ruleAction34:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction35:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction36:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction37:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction38:

			p.saveParams()

		case ruleAction39:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootIdentifier:
				p.pushCompareParameterRoot(p.deleteRootIdentifier(node))
				p.push(true)
			case *syntaxCurrentRootIdentifier:
				p.pushCompareParameterCurrentRoot(p.deleteRootIdentifier(node))
				p.push(false)
			}

		case ruleAction40:

			p.push(p.toFloat(text))

		case ruleAction41:

			p.push(true)

		case ruleAction42:

			p.push(false)

		case ruleAction43:

			p.push(p.unescape(text))

		case ruleAction44:

			p.push(p.unescape(text))

		case ruleAction45:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*pegJSONPathParser) error {
	return func(p *pegJSONPathParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *pegJSONPathParser) Init(options ...func(*pegJSONPathParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 expression <- <((jsonpath END Action0) / (jsonpath? <.*> END Action1))> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[rulejsonpath]() {
						goto l3
					}
					if !_rules[ruleEND]() {
						goto l3
					}
					if !_rules[ruleAction0]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpath]() {
							goto l4
						}
						goto l5
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
				l5:
					{
						position6 := position
					l7:
						{
							position8, tokenIndex8 := position, tokenIndex
							if !matchDot() {
								goto l8
							}
							goto l7
						l8:
							position, tokenIndex = position8, tokenIndex8
						}
						add(rulePegText, position6)
					}
					if !_rules[ruleEND]() {
						goto l0
					}
					if !_rules[ruleAction1]() {
						goto l0
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 END <- <!.> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position11, tokenIndex11 := position, tokenIndex
					if !matchDot() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position11, tokenIndex11
				}
				add(ruleEND, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 2 jsonpath <- <(space rootNode continuedJsonpath)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[rulespace]() {
					goto l12
				}
				if !_rules[rulerootNode]() {
					goto l12
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l12
				}
				add(rulejsonpath, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 jsonpathParameter <- <(space parameterRootNode continuedJsonpath)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[rulespace]() {
					goto l14
				}
				if !_rules[ruleparameterRootNode]() {
					goto l14
				}
				if !_rules[rulecontinuedJsonpath]() {
					goto l14
				}
				add(rulejsonpathParameter, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 4 continuedJsonpath <- <(childNode* function* space Action2)> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
			l18:
				{
					position19, tokenIndex19 := position, tokenIndex
					if !_rules[rulechildNode]() {
						goto l19
					}
					goto l18
				l19:
					position, tokenIndex = position19, tokenIndex19
				}
			l20:
				{
					position21, tokenIndex21 := position, tokenIndex
					if !_rules[rulefunction]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position21, tokenIndex21
				}
				if !_rules[rulespace]() {
					goto l16
				}
				if !_rules[ruleAction2]() {
					goto l16
				}
				add(rulecontinuedJsonpath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 5 rootNode <- <(rootIdentifier / bracketNode / dotChildIdentifier)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				{
					position24, tokenIndex24 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l25
					}
					goto l24
				l25:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[rulebracketNode]() {
						goto l26
					}
					goto l24
				l26:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[ruledotChildIdentifier]() {
						goto l22
					}
				}
			l24:
				add(rulerootNode, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 6 parameterRootNode <- <(rootIdentifier / currentRootIdentifier)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[rulerootIdentifier]() {
						goto l30
					}
					goto l29
				l30:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[rulecurrentRootIdentifier]() {
						goto l27
					}
				}
			l29:
				add(ruleparameterRootNode, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 7 childNode <- <(('.' '.' (bracketNode / dotChildIdentifier) Action3) / (<('.' dotChildIdentifier)> Action4) / bracketNode)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				{
					position33, tokenIndex33 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l34
					}
					position++
					if buffer[position] != rune('.') {
						goto l34
					}
					position++
					{
						position35, tokenIndex35 := position, tokenIndex
						if !_rules[rulebracketNode]() {
							goto l36
						}
						goto l35
					l36:
						position, tokenIndex = position35, tokenIndex35
						if !_rules[ruledotChildIdentifier]() {
							goto l34
						}
					}
				l35:
					if !_rules[ruleAction3]() {
						goto l34
					}
					goto l33
				l34:
					position, tokenIndex = position33, tokenIndex33
					{
						position38 := position
						if buffer[position] != rune('.') {
							goto l37
						}
						position++
						if !_rules[ruledotChildIdentifier]() {
							goto l37
						}
						add(rulePegText, position38)
					}
					if !_rules[ruleAction4]() {
						goto l37
					}
					goto l33
				l37:
					position, tokenIndex = position33, tokenIndex33
					if !_rules[rulebracketNode]() {
						goto l31
					}
				}
			l33:
				add(rulechildNode, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 8 function <- <(<('.' functionName ('(' ')'))> Action5)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				{
					position41 := position
					if buffer[position] != rune('.') {
						goto l39
					}
					position++
					if !_rules[rulefunctionName]() {
						goto l39
					}
					if buffer[position] != rune('(') {
						goto l39
					}
					position++
					if buffer[position] != rune(')') {
						goto l39
					}
					position++
					add(rulePegText, position41)
				}
				if !_rules[ruleAction5]() {
					goto l39
				}
				add(rulefunction, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 9 functionName <- <(<('-' / '_' / [a-z] / [A-Z] / [0-9])+> Action6)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44 := position
					{
						position47, tokenIndex47 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l48
						}
						position++
						goto l47
					l48:
						position, tokenIndex = position47, tokenIndex47
						if buffer[position] != rune('_') {
							goto l49
						}
						position++
						goto l47
					l49:
						position, tokenIndex = position47, tokenIndex47
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l50
						}
						position++
						goto l47
					l50:
						position, tokenIndex = position47, tokenIndex47
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l51
						}
						position++
						goto l47
					l51:
						position, tokenIndex = position47, tokenIndex47
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l42
						}
						position++
					}
				l47:
				l45:
					{
						position46, tokenIndex46 := position, tokenIndex
						{
							position52, tokenIndex52 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l53
							}
							position++
							goto l52
						l53:
							position, tokenIndex = position52, tokenIndex52
							if buffer[position] != rune('_') {
								goto l54
							}
							position++
							goto l52
						l54:
							position, tokenIndex = position52, tokenIndex52
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l55
							}
							position++
							goto l52
						l55:
							position, tokenIndex = position52, tokenIndex52
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l56
							}
							position++
							goto l52
						l56:
							position, tokenIndex = position52, tokenIndex52
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l46
							}
							position++
						}
					l52:
						goto l45
					l46:
						position, tokenIndex = position46, tokenIndex46
					}
					add(rulePegText, position44)
				}
				if !_rules[ruleAction6]() {
					goto l42
				}
				add(rulefunctionName, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 10 bracketNode <- <(<(squareBracketStart (bracketChildIdentifier / qualifier) squareBracketEnd)> Action7)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				{
					position59 := position
					if !_rules[rulesquareBracketStart]() {
						goto l57
					}
					{
						position60, tokenIndex60 := position, tokenIndex
						if !_rules[rulebracketChildIdentifier]() {
							goto l61
						}
						goto l60
					l61:
						position, tokenIndex = position60, tokenIndex60
						if !_rules[rulequalifier]() {
							goto l57
						}
					}
				l60:
					if !_rules[rulesquareBracketEnd]() {
						goto l57
					}
					add(rulePegText, position59)
				}
				if !_rules[ruleAction7]() {
					goto l57
				}
				add(rulebracketNode, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 11 rootIdentifier <- <('$' Action8)> */
		func() bool {
			position62, tokenIndex62 := position, tokenIndex
			{
				position63 := position
				if buffer[position] != rune('$') {
					goto l62
				}
				position++
				if !_rules[ruleAction8]() {
					goto l62
				}
				add(rulerootIdentifier, position63)
			}
			return true
		l62:
			position, tokenIndex = position62, tokenIndex62
			return false
		},
		/* 12 currentRootIdentifier <- <('@' Action9)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if buffer[position] != rune('@') {
					goto l64
				}
				position++
				if !_rules[ruleAction9]() {
					goto l64
				}
				add(rulecurrentRootIdentifier, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 13 dotChildIdentifier <- <(wildcardIdentifier / (<(('\\' signsWithoutHyphenUnderscore) / (!([\x00-\x1f] / '\u007f') !signsWithoutHyphenUnderscore .))+> !('(' ')') Action10))> */
		func() bool {
			position66, tokenIndex66 := position, tokenIndex
			{
				position67 := position
				{
					position68, tokenIndex68 := position, tokenIndex
					if !_rules[rulewildcardIdentifier]() {
						goto l69
					}
					goto l68
				l69:
					position, tokenIndex = position68, tokenIndex68
					{
						position70 := position
						{
							position73, tokenIndex73 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l74
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l74
							}
							goto l73
						l74:
							position, tokenIndex = position73, tokenIndex73
							{
								position75, tokenIndex75 := position, tokenIndex
								{
									position76, tokenIndex76 := position, tokenIndex
									if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
										goto l77
									}
									position++
									goto l76
								l77:
									position, tokenIndex = position76, tokenIndex76
									if buffer[position] != rune('\u007f') {
										goto l75
									}
									position++
								}
							l76:
								goto l66
							l75:
								position, tokenIndex = position75, tokenIndex75
							}
							{
								position78, tokenIndex78 := position, tokenIndex
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l78
								}
								goto l66
							l78:
								position, tokenIndex = position78, tokenIndex78
							}
							if !matchDot() {
								goto l66
							}
						}
					l73:
					l71:
						{
							position72, tokenIndex72 := position, tokenIndex
							{
								position79, tokenIndex79 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l80
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l80
								}
								goto l79
							l80:
								position, tokenIndex = position79, tokenIndex79
								{
									position81, tokenIndex81 := position, tokenIndex
									{
										position82, tokenIndex82 := position, tokenIndex
										if c := buffer[position]; c < rune('\x00') || c > rune('\x1f') {
											goto l83
										}
										position++
										goto l82
									l83:
										position, tokenIndex = position82, tokenIndex82
										if buffer[position] != rune('\u007f') {
											goto l81
										}
										position++
									}
								l82:
									goto l72
								l81:
									position, tokenIndex = position81, tokenIndex81
								}
								{
									position84, tokenIndex84 := position, tokenIndex
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l84
									}
									goto l72
								l84:
									position, tokenIndex = position84, tokenIndex84
								}
								if !matchDot() {
									goto l72
								}
							}
						l79:
							goto l71
						l72:
							position, tokenIndex = position72, tokenIndex72
						}
						add(rulePegText, position70)
					}
					{
						position85, tokenIndex85 := position, tokenIndex
						if buffer[position] != rune('(') {
							goto l85
						}
						position++
						if buffer[position] != rune(')') {
							goto l85
						}
						position++
						goto l66
					l85:
						position, tokenIndex = position85, tokenIndex85
					}
					if !_rules[ruleAction10]() {
						goto l66
					}
				}
			l68:
				add(ruledotChildIdentifier, position67)
			}
			return true
		l66:
			position, tokenIndex = position66, tokenIndex66
			return false
		},
		/* 14 signsWithoutHyphenUnderscore <- <([ -,] / '.' / '/' / [:-@] / [[-^] / '`' / [{-~])> */
		func() bool {
			position86, tokenIndex86 := position, tokenIndex
			{
				position87 := position
				{
					position88, tokenIndex88 := position, tokenIndex
					if c := buffer[position]; c < rune(' ') || c > rune(',') {
						goto l89
					}
					position++
					goto l88
				l89:
					position, tokenIndex = position88, tokenIndex88
					if buffer[position] != rune('.') {
						goto l90
					}
					position++
					goto l88
				l90:
					position, tokenIndex = position88, tokenIndex88
					if buffer[position] != rune('/') {
						goto l91
					}
					position++
					goto l88
				l91:
					position, tokenIndex = position88, tokenIndex88
					if c := buffer[position]; c < rune(':') || c > rune('@') {
						goto l92
					}
					position++
					goto l88
				l92:
					position, tokenIndex = position88, tokenIndex88
					if c := buffer[position]; c < rune('[') || c > rune('^') {
						goto l93
					}
					position++
					goto l88
				l93:
					position, tokenIndex = position88, tokenIndex88
					if buffer[position] != rune('`') {
						goto l94
					}
					position++
					goto l88
				l94:
					position, tokenIndex = position88, tokenIndex88
					if c := buffer[position]; c < rune('{') || c > rune('~') {
						goto l86
					}
					position++
				}
			l88:
				add(rulesignsWithoutHyphenUnderscore, position87)
			}
			return true
		l86:
			position, tokenIndex = position86, tokenIndex86
			return false
		},
		/* 15 bracketChildIdentifier <- <(bracketNodeIdentifier (sep bracketNodeIdentifier Action11)* !sep)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				if !_rules[rulebracketNodeIdentifier]() {
					goto l95
				}
			l97:
				{
					position98, tokenIndex98 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l98
					}
					if !_rules[rulebracketNodeIdentifier]() {
						goto l98
					}
					if !_rules[ruleAction11]() {
						goto l98
					}
					goto l97
				l98:
					position, tokenIndex = position98, tokenIndex98
				}
				{
					position99, tokenIndex99 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l99
					}
					goto l95
				l99:
					position, tokenIndex = position99, tokenIndex99
				}
				add(rulebracketChildIdentifier, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 16 bracketNodeIdentifier <- <(wildcardIdentifier / singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier)> */
		func() bool {
			position100, tokenIndex100 := position, tokenIndex
			{
				position101 := position
				{
					position102, tokenIndex102 := position, tokenIndex
					if !_rules[rulewildcardIdentifier]() {
						goto l103
					}
					goto l102
				l103:
					position, tokenIndex = position102, tokenIndex102
					if !_rules[rulesingleQuotedNodeIdentifier]() {
						goto l104
					}
					goto l102
				l104:
					position, tokenIndex = position102, tokenIndex102
					if !_rules[ruledoubleQuotedNodeIdentifier]() {
						goto l100
					}
				}
			l102:
				add(rulebracketNodeIdentifier, position101)
			}
			return true
		l100:
			position, tokenIndex = position100, tokenIndex100
			return false
		},
		/* 17 wildcardIdentifier <- <('*' Action12)> */
		func() bool {
			position105, tokenIndex105 := position, tokenIndex
			{
				position106 := position
				if buffer[position] != rune('*') {
					goto l105
				}
				position++
				if !_rules[ruleAction12]() {
					goto l105
				}
				add(rulewildcardIdentifier, position106)
			}
			return true
		l105:
			position, tokenIndex = position105, tokenIndex105
			return false
		},
		/* 18 singleQuotedNodeIdentifier <- <('\'' <(('\\' ('\'' / '/' / '\\' / 'b' / 'f' / 'n' / 'r' / 't' / hexDigits)) / (!('\'' / '\\') .))*> '\'' Action13)> */
		func() bool {
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				if buffer[position] != rune('\'') {
					goto l107
				}
				position++
				{
					position109 := position
				l110:
					{
						position111, tokenIndex111 := position, tokenIndex
						{
							position112, tokenIndex112 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l113
							}
							position++
							{
								position114, tokenIndex114 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l115
								}
								position++
								goto l114
							l115:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('/') {
									goto l116
								}
								position++
								goto l114
							l116:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('\\') {
									goto l117
								}
								position++
								goto l114
							l117:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('b') {
									goto l118
								}
								position++
								goto l114
							l118:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('f') {
									goto l119
								}
								position++
								goto l114
							l119:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('n') {
									goto l120
								}
								position++
								goto l114
							l120:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('r') {
									goto l121
								}
								position++
								goto l114
							l121:
								position, tokenIndex = position114, tokenIndex114
								if buffer[position] != rune('t') {
									goto l122
								}
								position++
								goto l114
							l122:
								position, tokenIndex = position114, tokenIndex114
								if !_rules[rulehexDigits]() {
									goto l113
								}
							}
						l114:
							goto l112
						l113:
							position, tokenIndex = position112, tokenIndex112
							{
								position123, tokenIndex123 := position, tokenIndex
								{
									position124, tokenIndex124 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l125
									}
									position++
									goto l124
								l125:
									position, tokenIndex = position124, tokenIndex124
									if buffer[position] != rune('\\') {
										goto l123
									}
									position++
								}
							l124:
								goto l111
							l123:
								position, tokenIndex = position123, tokenIndex123
							}
							if !matchDot() {
								goto l111
							}
						}
					l112:
						goto l110
					l111:
						position, tokenIndex = position111, tokenIndex111
					}
					add(rulePegText, position109)
				}
				if buffer[position] != rune('\'') {
					goto l107
				}
				position++
				if !_rules[ruleAction13]() {
					goto l107
				}
				add(rulesingleQuotedNodeIdentifier, position108)
			}
			return true
		l107:
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 19 doubleQuotedNodeIdentifier <- <('"' <(('\\' ('"' / '/' / '\\' / 'b' / 'f' / 'n' / 'r' / 't' / hexDigits)) / (!('"' / '\\') .))*> '"' Action14)> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if buffer[position] != rune('"') {
					goto l126
				}
				position++
				{
					position128 := position
				l129:
					{
						position130, tokenIndex130 := position, tokenIndex
						{
							position131, tokenIndex131 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l132
							}
							position++
							{
								position133, tokenIndex133 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l134
								}
								position++
								goto l133
							l134:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('/') {
									goto l135
								}
								position++
								goto l133
							l135:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('\\') {
									goto l136
								}
								position++
								goto l133
							l136:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('b') {
									goto l137
								}
								position++
								goto l133
							l137:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('f') {
									goto l138
								}
								position++
								goto l133
							l138:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('n') {
									goto l139
								}
								position++
								goto l133
							l139:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('r') {
									goto l140
								}
								position++
								goto l133
							l140:
								position, tokenIndex = position133, tokenIndex133
								if buffer[position] != rune('t') {
									goto l141
								}
								position++
								goto l133
							l141:
								position, tokenIndex = position133, tokenIndex133
								if !_rules[rulehexDigits]() {
									goto l132
								}
							}
						l133:
							goto l131
						l132:
							position, tokenIndex = position131, tokenIndex131
							{
								position142, tokenIndex142 := position, tokenIndex
								{
									position143, tokenIndex143 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l144
									}
									position++
									goto l143
								l144:
									position, tokenIndex = position143, tokenIndex143
									if buffer[position] != rune('\\') {
										goto l142
									}
									position++
								}
							l143:
								goto l130
							l142:
								position, tokenIndex = position142, tokenIndex142
							}
							if !matchDot() {
								goto l130
							}
						}
					l131:
						goto l129
					l130:
						position, tokenIndex = position130, tokenIndex130
					}
					add(rulePegText, position128)
				}
				if buffer[position] != rune('"') {
					goto l126
				}
				position++
				if !_rules[ruleAction14]() {
					goto l126
				}
				add(ruledoubleQuotedNodeIdentifier, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 20 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune('u') {
					goto l145
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l145
				}
				if !_rules[rulehexDigit]() {
					goto l145
				}
				if !_rules[rulehexDigit]() {
					goto l145
				}
				if !_rules[rulehexDigit]() {
					goto l145
				}
				add(rulehexDigits, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 21 hexDigit <- <([a-f] / [A-F] / [0-9])> */
		func() bool {
			position147, tokenIndex147 := position, tokenIndex
			{
				position148 := position
				{
					position149, tokenIndex149 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('f') {
						goto l150
					}
					position++
					goto l149
				l150:
					position, tokenIndex = position149, tokenIndex149
					if c := buffer[position]; c < rune('A') || c > rune('F') {
						goto l151
					}
					position++
					goto l149
				l151:
					position, tokenIndex = position149, tokenIndex149
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l147
					}
					position++
				}
			l149:
				add(rulehexDigit, position148)
			}
			return true
		l147:
			position, tokenIndex = position147, tokenIndex147
			return false
		},
		/* 22 qualifier <- <(union / script / filter)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if !_rules[ruleunion]() {
						goto l155
					}
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[rulescript]() {
						goto l156
					}
					goto l154
				l156:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[rulefilter]() {
						goto l152
					}
				}
			l154:
				add(rulequalifier, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 23 union <- <(index (sep index Action15)* !sep)> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				if !_rules[ruleindex]() {
					goto l157
				}
			l159:
				{
					position160, tokenIndex160 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l160
					}
					if !_rules[ruleindex]() {
						goto l160
					}
					if !_rules[ruleAction15]() {
						goto l160
					}
					goto l159
				l160:
					position, tokenIndex = position160, tokenIndex160
				}
				{
					position161, tokenIndex161 := position, tokenIndex
					if !_rules[rulesep]() {
						goto l161
					}
					goto l157
				l161:
					position, tokenIndex = position161, tokenIndex161
				}
				add(ruleunion, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
		/* 24 index <- <(((slice Action16) / (<indexNumber> Action17) / ('*' Action18)) Action19)> */
		func() bool {
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					position164, tokenIndex164 := position, tokenIndex
					if !_rules[ruleslice]() {
						goto l165
					}
					if !_rules[ruleAction16]() {
						goto l165
					}
					goto l164
				l165:
					position, tokenIndex = position164, tokenIndex164
					{
						position167 := position
						if !_rules[ruleindexNumber]() {
							goto l166
						}
						add(rulePegText, position167)
					}
					if !_rules[ruleAction17]() {
						goto l166
					}
					goto l164
				l166:
					position, tokenIndex = position164, tokenIndex164
					if buffer[position] != rune('*') {
						goto l162
					}
					position++
					if !_rules[ruleAction18]() {
						goto l162
					}
				}
			l164:
				if !_rules[ruleAction19]() {
					goto l162
				}
				add(ruleindex, position163)
			}
			return true
		l162:
			position, tokenIndex = position162, tokenIndex162
			return false
		},
		/* 25 slice <- <(anyIndex sepSlice anyIndex ((sepSlice anyIndex) / (space Action20)))> */
		func() bool {
			position168, tokenIndex168 := position, tokenIndex
			{
				position169 := position
				if !_rules[ruleanyIndex]() {
					goto l168
				}
				if !_rules[rulesepSlice]() {
					goto l168
				}
				if !_rules[ruleanyIndex]() {
					goto l168
				}
				{
					position170, tokenIndex170 := position, tokenIndex
					if !_rules[rulesepSlice]() {
						goto l171
					}
					if !_rules[ruleanyIndex]() {
						goto l171
					}
					goto l170
				l171:
					position, tokenIndex = position170, tokenIndex170
					if !_rules[rulespace]() {
						goto l168
					}
					if !_rules[ruleAction20]() {
						goto l168
					}
				}
			l170:
				add(ruleslice, position169)
			}
			return true
		l168:
			position, tokenIndex = position168, tokenIndex168
			return false
		},
		/* 26 anyIndex <- <(<indexNumber?> Action21)> */
		func() bool {
			position172, tokenIndex172 := position, tokenIndex
			{
				position173 := position
				{
					position174 := position
					{
						position175, tokenIndex175 := position, tokenIndex
						if !_rules[ruleindexNumber]() {
							goto l175
						}
						goto l176
					l175:
						position, tokenIndex = position175, tokenIndex175
					}
				l176:
					add(rulePegText, position174)
				}
				if !_rules[ruleAction21]() {
					goto l172
				}
				add(ruleanyIndex, position173)
			}
			return true
		l172:
			position, tokenIndex = position172, tokenIndex172
			return false
		},
		/* 27 indexNumber <- <(('-' / '+')? [0-9]+)> */
		func() bool {
			position177, tokenIndex177 := position, tokenIndex
			{
				position178 := position
				{
					position179, tokenIndex179 := position, tokenIndex
					{
						position181, tokenIndex181 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l182
						}
						position++
						goto l181
					l182:
						position, tokenIndex = position181, tokenIndex181
						if buffer[position] != rune('+') {
							goto l179
						}
						position++
					}
				l181:
					goto l180
				l179:
					position, tokenIndex = position179, tokenIndex179
				}
			l180:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l177
				}
				position++
			l183:
				{
					position184, tokenIndex184 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l184
					}
					position++
					goto l183
				l184:
					position, tokenIndex = position184, tokenIndex184
				}
				add(ruleindexNumber, position178)
			}
			return true
		l177:
			position, tokenIndex = position177, tokenIndex177
			return false
		},
		/* 28 sep <- <(space ',' space)> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				if !_rules[rulespace]() {
					goto l185
				}
				if buffer[position] != rune(',') {
					goto l185
				}
				position++
				if !_rules[rulespace]() {
					goto l185
				}
				add(rulesep, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 29 sepSlice <- <(space ':' space)> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				if !_rules[rulespace]() {
					goto l187
				}
				if buffer[position] != rune(':') {
					goto l187
				}
				position++
				if !_rules[rulespace]() {
					goto l187
				}
				add(rulesepSlice, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 30 script <- <(scriptStart <command> scriptEnd Action22)> */
		func() bool {
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				if !_rules[rulescriptStart]() {
					goto l189
				}
				{
					position191 := position
					if !_rules[rulecommand]() {
						goto l189
					}
					add(rulePegText, position191)
				}
				if !_rules[rulescriptEnd]() {
					goto l189
				}
				if !_rules[ruleAction22]() {
					goto l189
				}
				add(rulescript, position190)
			}
			return true
		l189:
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 31 command <- <(!scriptEnd .)+> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position196, tokenIndex196 := position, tokenIndex
					if !_rules[rulescriptEnd]() {
						goto l196
					}
					goto l192
				l196:
					position, tokenIndex = position196, tokenIndex196
				}
				if !matchDot() {
					goto l192
				}
			l194:
				{
					position195, tokenIndex195 := position, tokenIndex
					{
						position197, tokenIndex197 := position, tokenIndex
						if !_rules[rulescriptEnd]() {
							goto l197
						}
						goto l195
					l197:
						position, tokenIndex = position197, tokenIndex197
					}
					if !matchDot() {
						goto l195
					}
					goto l194
				l195:
					position, tokenIndex = position195, tokenIndex195
				}
				add(rulecommand, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 32 filter <- <(filterStart query filterEnd Action23)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if !_rules[rulefilterStart]() {
					goto l198
				}
				if !_rules[rulequery]() {
					goto l198
				}
				if !_rules[rulefilterEnd]() {
					goto l198
				}
				if !_rules[ruleAction23]() {
					goto l198
				}
				add(rulefilter, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 33 query <- <(andQuery (logicOr andQuery Action24)*)> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				if !_rules[ruleandQuery]() {
					goto l200
				}
			l202:
				{
					position203, tokenIndex203 := position, tokenIndex
					if !_rules[rulelogicOr]() {
						goto l203
					}
					if !_rules[ruleandQuery]() {
						goto l203
					}
					if !_rules[ruleAction24]() {
						goto l203
					}
					goto l202
				l203:
					position, tokenIndex = position203, tokenIndex203
				}
				add(rulequery, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 34 andQuery <- <(basicQuery (logicAnd basicQuery Action25)*)> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				if !_rules[rulebasicQuery]() {
					goto l204
				}
			l206:
				{
					position207, tokenIndex207 := position, tokenIndex
					if !_rules[rulelogicAnd]() {
						goto l207
					}
					if !_rules[rulebasicQuery]() {
						goto l207
					}
					if !_rules[ruleAction25]() {
						goto l207
					}
					goto l206
				l207:
					position, tokenIndex = position207, tokenIndex207
				}
				add(ruleandQuery, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 35 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action26) / (<(logicNot? jsonpathFilter)> Action27))> */
		func() bool {
			position208, tokenIndex208 := position, tokenIndex
			{
				position209 := position
				{
					position210, tokenIndex210 := position, tokenIndex
					if !_rules[rulesubQueryStart]() {
						goto l211
					}
					if !_rules[rulequery]() {
						goto l211
					}
					if !_rules[rulesubQueryEnd]() {
						goto l211
					}
					goto l210
				l211:
					position, tokenIndex = position210, tokenIndex210
					{
						position213 := position
						if !_rules[rulecomparator]() {
							goto l212
						}
						add(rulePegText, position213)
					}
					if !_rules[ruleAction26]() {
						goto l212
					}
					goto l210
				l212:
					position, tokenIndex = position210, tokenIndex210
					{
						position214 := position
						{
							position215, tokenIndex215 := position, tokenIndex
							if !_rules[rulelogicNot]() {
								goto l215
							}
							goto l216
						l215:
							position, tokenIndex = position215, tokenIndex215
						}
					l216:
						if !_rules[rulejsonpathFilter]() {
							goto l208
						}
						add(rulePegText, position214)
					}
					if !_rules[ruleAction27]() {
						goto l208
					}
				}
			l210:
				add(rulebasicQuery, position209)
			}
			return true
		l208:
			position, tokenIndex = position208, tokenIndex208
			return false
		},
		/* 36 logicOr <- <(space ('|' '|') space)> */
		func() bool {
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				if !_rules[rulespace]() {
					goto l217
				}
				if buffer[position] != rune('|') {
					goto l217
				}
				position++
				if buffer[position] != rune('|') {
					goto l217
				}
				position++
				if !_rules[rulespace]() {
					goto l217
				}
				add(rulelogicOr, position218)
			}
			return true
		l217:
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 37 logicAnd <- <(space ('&' '&') space)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if !_rules[rulespace]() {
					goto l219
				}
				if buffer[position] != rune('&') {
					goto l219
				}
				position++
				if buffer[position] != rune('&') {
					goto l219
				}
				position++
				if !_rules[rulespace]() {
					goto l219
				}
				add(rulelogicAnd, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 38 logicNot <- <('!' space)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				if buffer[position] != rune('!') {
					goto l221
				}
				position++
				if !_rules[rulespace]() {
					goto l221
				}
				add(rulelogicNot, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 39 comparator <- <((qParam space (('=' '=' space qParam Action28) / ('!' '=' space qParam Action29))) / (qNumericParam space (('<' '=' space qNumericParam Action30) / ('<' space qNumericParam Action31) / ('>' '=' space qNumericParam Action32) / ('>' space qNumericParam Action33))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action34))> */
		func() bool {
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				{
					position225, tokenIndex225 := position, tokenIndex
					if !_rules[ruleqParam]() {
						goto l226
					}
					if !_rules[rulespace]() {
						goto l226
					}
					{
						position227, tokenIndex227 := position, tokenIndex
						if buffer[position] != rune('=') {
							goto l228
						}
						position++
						if buffer[position] != rune('=') {
							goto l228
						}
						position++
						if !_rules[rulespace]() {
							goto l228
						}
						if !_rules[ruleqParam]() {
							goto l228
						}
						if !_rules[ruleAction28]() {
							goto l228
						}
						goto l227
					l228:
						position, tokenIndex = position227, tokenIndex227
						if buffer[position] != rune('!') {
							goto l226
						}
						position++
						if buffer[position] != rune('=') {
							goto l226
						}
						position++
						if !_rules[rulespace]() {
							goto l226
						}
						if !_rules[ruleqParam]() {
							goto l226
						}
						if !_rules[ruleAction29]() {
							goto l226
						}
					}
				l227:
					goto l225
				l226:
					position, tokenIndex = position225, tokenIndex225
					if !_rules[ruleqNumericParam]() {
						goto l229
					}
					if !_rules[rulespace]() {
						goto l229
					}
					{
						position230, tokenIndex230 := position, tokenIndex
						if buffer[position] != rune('<') {
							goto l231
						}
						position++
						if buffer[position] != rune('=') {
							goto l231
						}
						position++
						if !_rules[rulespace]() {
							goto l231
						}
						if !_rules[ruleqNumericParam]() {
							goto l231
						}
						if !_rules[ruleAction30]() {
							goto l231
						}
						goto l230
					l231:
						position, tokenIndex = position230, tokenIndex230
						if buffer[position] != rune('<') {
							goto l232
						}
						position++
						if !_rules[rulespace]() {
							goto l232
						}
						if !_rules[ruleqNumericParam]() {
							goto l232
						}
						if !_rules[ruleAction31]() {
							goto l232
						}
						goto l230
					l232:
						position, tokenIndex = position230, tokenIndex230
						if buffer[position] != rune('>') {
							goto l233
						}
						position++
						if buffer[position] != rune('=') {
							goto l233
						}
						position++
						if !_rules[rulespace]() {
							goto l233
						}
						if !_rules[ruleqNumericParam]() {
							goto l233
						}
						if !_rules[ruleAction32]() {
							goto l233
						}
						goto l230
					l233:
						position, tokenIndex = position230, tokenIndex230
						if buffer[position] != rune('>') {
							goto l229
						}
						position++
						if !_rules[rulespace]() {
							goto l229
						}
						if !_rules[ruleqNumericParam]() {
							goto l229
						}
						if !_rules[ruleAction33]() {
							goto l229
						}
					}
				l230:
					goto l225
				l229:
					position, tokenIndex = position225, tokenIndex225
					if !_rules[rulesingleJsonpathFilter]() {
						goto l223
					}
					if !_rules[rulespace]() {
						goto l223
					}
					if buffer[position] != rune('=') {
						goto l223
					}
					position++
					if buffer[position] != rune('~') {
						goto l223
					}
					position++
					if !_rules[rulespace]() {
						goto l223
					}
					if buffer[position] != rune('/') {
						goto l223
					}
					position++
					{
						position234 := position
						if !_rules[ruleregex]() {
							goto l223
						}
						add(rulePegText, position234)
					}
					if buffer[position] != rune('/') {
						goto l223
					}
					position++
					if !_rules[ruleAction34]() {
						goto l223
					}
				}
			l225:
				add(rulecomparator, position224)
			}
			return true
		l223:
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 40 qParam <- <((qLiteral Action35) / singleJsonpathFilter)> */
		func() bool {
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				{
					position237, tokenIndex237 := position, tokenIndex
					if !_rules[ruleqLiteral]() {
						goto l238
					}
					if !_rules[ruleAction35]() {
						goto l238
					}
					goto l237
				l238:
					position, tokenIndex = position237, tokenIndex237
					if !_rules[rulesingleJsonpathFilter]() {
						goto l235
					}
				}
			l237:
				add(ruleqParam, position236)
			}
			return true
		l235:
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 41 qNumericParam <- <((lNumber Action36) / singleJsonpathFilter)> */
		func() bool {
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				{
					position241, tokenIndex241 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l242
					}
					if !_rules[ruleAction36]() {
						goto l242
					}
					goto l241
				l242:
					position, tokenIndex = position241, tokenIndex241
					if !_rules[rulesingleJsonpathFilter]() {
						goto l239
					}
				}
			l241:
				add(ruleqNumericParam, position240)
			}
			return true
		l239:
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 42 qLiteral <- <(lNumber / lBool / lString / lNull)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l246
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[rulelBool]() {
						goto l247
					}
					goto l245
				l247:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[rulelString]() {
						goto l248
					}
					goto l245
				l248:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[rulelNull]() {
						goto l243
					}
				}
			l245:
				add(ruleqLiteral, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 43 singleJsonpathFilter <- <(<jsonpathFilter> Action37)> */
		func() bool {
			position249, tokenIndex249 := position, tokenIndex
			{
				position250 := position
				{
					position251 := position
					if !_rules[rulejsonpathFilter]() {
						goto l249
					}
					add(rulePegText, position251)
				}
				if !_rules[ruleAction37]() {
					goto l249
				}
				add(rulesingleJsonpathFilter, position250)
			}
			return true
		l249:
			position, tokenIndex = position249, tokenIndex249
			return false
		},
		/* 44 jsonpathFilter <- <(Action38 jsonpathParameter Action39)> */
		func() bool {
			position252, tokenIndex252 := position, tokenIndex
			{
				position253 := position
				if !_rules[ruleAction38]() {
					goto l252
				}
				if !_rules[rulejsonpathParameter]() {
					goto l252
				}
				if !_rules[ruleAction39]() {
					goto l252
				}
				add(rulejsonpathFilter, position253)
			}
			return true
		l252:
			position, tokenIndex = position252, tokenIndex252
			return false
		},
		/* 45 lNumber <- <(<(('-' / '+')? [0-9] ('-' / '+' / '.' / [0-9] / [a-z] / [A-Z])*)> Action40)> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				{
					position256 := position
					{
						position257, tokenIndex257 := position, tokenIndex
						{
							position259, tokenIndex259 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l260
							}
							position++
							goto l259
						l260:
							position, tokenIndex = position259, tokenIndex259
							if buffer[position] != rune('+') {
								goto l257
							}
							position++
						}
					l259:
						goto l258
					l257:
						position, tokenIndex = position257, tokenIndex257
					}
				l258:
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l254
					}
					position++
				l261:
					{
						position262, tokenIndex262 := position, tokenIndex
						{
							position263, tokenIndex263 := position, tokenIndex
							if buffer[position] != rune('-') {
								goto l264
							}
							position++
							goto l263
						l264:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('+') {
								goto l265
							}
							position++
							goto l263
						l265:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('.') {
								goto l266
							}
							position++
							goto l263
						l266:
							position, tokenIndex = position263, tokenIndex263
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l267
							}
							position++
							goto l263
						l267:
							position, tokenIndex = position263, tokenIndex263
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l268
							}
							position++
							goto l263
						l268:
							position, tokenIndex = position263, tokenIndex263
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l262
							}
							position++
						}
					l263:
						goto l261
					l262:
						position, tokenIndex = position262, tokenIndex262
					}
					add(rulePegText, position256)
				}
				if !_rules[ruleAction40]() {
					goto l254
				}
				add(rulelNumber, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 46 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action41) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action42))> */
		func() bool {
			position269, tokenIndex269 := position, tokenIndex
			{
				position270 := position
				{
					position271, tokenIndex271 := position, tokenIndex
					{
						position273, tokenIndex273 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l274
						}
						position++
						if buffer[position] != rune('r') {
							goto l274
						}
						position++
						if buffer[position] != rune('u') {
							goto l274
						}
						position++
						if buffer[position] != rune('e') {
							goto l274
						}
						position++
						goto l273
					l274:
						position, tokenIndex = position273, tokenIndex273
						if buffer[position] != rune('T') {
							goto l275
						}
						position++
						if buffer[position] != rune('r') {
							goto l275
						}
						position++
						if buffer[position] != rune('u') {
							goto l275
						}
						position++
						if buffer[position] != rune('e') {
							goto l275
						}
						position++
						goto l273
					l275:
						position, tokenIndex = position273, tokenIndex273
						if buffer[position] != rune('T') {
							goto l272
						}
						position++
						if buffer[position] != rune('R') {
							goto l272
						}
						position++
						if buffer[position] != rune('U') {
							goto l272
						}
						position++
						if buffer[position] != rune('E') {
							goto l272
						}
						position++
					}
				l273:
					if !_rules[ruleAction41]() {
						goto l272
					}
					goto l271
				l272:
					position, tokenIndex = position271, tokenIndex271
					{
						position276, tokenIndex276 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l277
						}
						position++
						if buffer[position] != rune('a') {
							goto l277
						}
						position++
						if buffer[position] != rune('l') {
							goto l277
						}
						position++
						if buffer[position] != rune('s') {
							goto l277
						}
						position++
						if buffer[position] != rune('e') {
							goto l277
						}
						position++
						goto l276
					l277:
						position, tokenIndex = position276, tokenIndex276
						if buffer[position] != rune('F') {
							goto l278
						}
						position++
						if buffer[position] != rune('a') {
							goto l278
						}
						position++
						if buffer[position] != rune('l') {
							goto l278
						}
						position++
						if buffer[position] != rune('s') {
							goto l278
						}
						position++
						if buffer[position] != rune('e') {
							goto l278
						}
						position++
						goto l276
					l278:
						position, tokenIndex = position276, tokenIndex276
						if buffer[position] != rune('F') {
							goto l269
						}
						position++
						if buffer[position] != rune('A') {
							goto l269
						}
						position++
						if buffer[position] != rune('L') {
							goto l269
						}
						position++
						if buffer[position] != rune('S') {
							goto l269
						}
						position++
						if buffer[position] != rune('E') {
							goto l269
						}
						position++
					}
				l276:
					if !_rules[ruleAction42]() {
						goto l269
					}
				}
			l271:
				add(rulelBool, position270)
			}
			return true
		l269:
			position, tokenIndex = position269, tokenIndex269
			return false
		},
		/* 47 lString <- <(('\'' <(('\\' ('\\' / '\'')) / (!'\'' .))*> '\'' Action43) / ('"' <(('\\' ('\\' / '"')) / (!'"' .))*> '"' Action44))> */
		func() bool {
			position279, tokenIndex279 := position, tokenIndex
			{
				position280 := position
				{
					position281, tokenIndex281 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l282
					}
					position++
					{
						position283 := position
					l284:
						{
							position285, tokenIndex285 := position, tokenIndex
							{
								position286, tokenIndex286 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l287
								}
								position++
								{
									position288, tokenIndex288 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l289
									}
									position++
									goto l288
								l289:
									position, tokenIndex = position288, tokenIndex288
									if buffer[position] != rune('\'') {
										goto l287
									}
									position++
								}
							l288:
								goto l286
							l287:
								position, tokenIndex = position286, tokenIndex286
								{
									position290, tokenIndex290 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l290
									}
									position++
									goto l285
								l290:
									position, tokenIndex = position290, tokenIndex290
								}
								if !matchDot() {
									goto l285
								}
							}
						l286:
							goto l284
						l285:
							position, tokenIndex = position285, tokenIndex285
						}
						add(rulePegText, position283)
					}
					if buffer[position] != rune('\'') {
						goto l282
					}
					position++
					if !_rules[ruleAction43]() {
						goto l282
					}
					goto l281
				l282:
					position, tokenIndex = position281, tokenIndex281
					if buffer[position] != rune('"') {
						goto l279
					}
					position++
					{
						position291 := position
					l292:
						{
							position293, tokenIndex293 := position, tokenIndex
							{
								position294, tokenIndex294 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l295
								}
								position++
								{
									position296, tokenIndex296 := position, tokenIndex
									if buffer[position] != rune('\\') {
										goto l297
									}
									position++
									goto l296
								l297:
									position, tokenIndex = position296, tokenIndex296
									if buffer[position] != rune('"') {
										goto l295
									}
									position++
								}
							l296:
								goto l294
							l295:
								position, tokenIndex = position294, tokenIndex294
								{
									position298, tokenIndex298 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l298
									}
									position++
									goto l293
								l298:
									position, tokenIndex = position298, tokenIndex298
								}
								if !matchDot() {
									goto l293
								}
							}
						l294:
							goto l292
						l293:
							position, tokenIndex = position293, tokenIndex293
						}
						add(rulePegText, position291)
					}
					if buffer[position] != rune('"') {
						goto l279
					}
					position++
					if !_rules[ruleAction44]() {
						goto l279
					}
				}
			l281:
				add(rulelString, position280)
			}
			return true
		l279:
			position, tokenIndex = position279, tokenIndex279
			return false
		},
		/* 48 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action45)> */
		func() bool {
			position299, tokenIndex299 := position, tokenIndex
			{
				position300 := position
				{
					position301, tokenIndex301 := position, tokenIndex
					if buffer[position] != rune('n') {
						goto l302
					}
					position++
					if buffer[position] != rune('u') {
						goto l302
					}
					position++
					if buffer[position] != rune('l') {
						goto l302
					}
					position++
					if buffer[position] != rune('l') {
						goto l302
					}
					position++
					goto l301
				l302:
					position, tokenIndex = position301, tokenIndex301
					if buffer[position] != rune('N') {
						goto l303
					}
					position++
					if buffer[position] != rune('u') {
						goto l303
					}
					position++
					if buffer[position] != rune('l') {
						goto l303
					}
					position++
					if buffer[position] != rune('l') {
						goto l303
					}
					position++
					goto l301
				l303:
					position, tokenIndex = position301, tokenIndex301
					if buffer[position] != rune('N') {
						goto l299
					}
					position++
					if buffer[position] != rune('U') {
						goto l299
					}
					position++
					if buffer[position] != rune('L') {
						goto l299
					}
					position++
					if buffer[position] != rune('L') {
						goto l299
					}
					position++
				}
			l301:
				if !_rules[ruleAction45]() {
					goto l299
				}
				add(rulelNull, position300)
			}
			return true
		l299:
			position, tokenIndex = position299, tokenIndex299
			return false
		},
		/* 49 regex <- <(('\\' ('\\' / '/')) / (!'/' .))*> */
		func() bool {
			{
				position305 := position
			l306:
				{
					position307, tokenIndex307 := position, tokenIndex
					{
						position308, tokenIndex308 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l309
						}
						position++
						{
							position310, tokenIndex310 := position, tokenIndex
							if buffer[position] != rune('\\') {
								goto l311
							}
							position++
							goto l310
						l311:
							position, tokenIndex = position310, tokenIndex310
							if buffer[position] != rune('/') {
								goto l309
							}
							position++
						}
					l310:
						goto l308
					l309:
						position, tokenIndex = position308, tokenIndex308
						{
							position312, tokenIndex312 := position, tokenIndex
							if buffer[position] != rune('/') {
								goto l312
							}
							position++
							goto l307
						l312:
							position, tokenIndex = position312, tokenIndex312
						}
						if !matchDot() {
							goto l307
						}
					}
				l308:
					goto l306
				l307:
					position, tokenIndex = position307, tokenIndex307
				}
				add(ruleregex, position305)
			}
			return true
		},
		/* 50 squareBracketStart <- <('[' space)> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if buffer[position] != rune('[') {
					goto l313
				}
				position++
				if !_rules[rulespace]() {
					goto l313
				}
				add(rulesquareBracketStart, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 51 squareBracketEnd <- <(space ']')> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if !_rules[rulespace]() {
					goto l315
				}
				if buffer[position] != rune(']') {
					goto l315
				}
				position++
				add(rulesquareBracketEnd, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 52 scriptStart <- <('(' space)> */
		func() bool {
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if buffer[position] != rune('(') {
					goto l317
				}
				position++
				if !_rules[rulespace]() {
					goto l317
				}
				add(rulescriptStart, position318)
			}
			return true
		l317:
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 53 scriptEnd <- <(space ')')> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				if !_rules[rulespace]() {
					goto l319
				}
				if buffer[position] != rune(')') {
					goto l319
				}
				position++
				add(rulescriptEnd, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 54 filterStart <- <('?' '(' space)> */
		func() bool {
			position321, tokenIndex321 := position, tokenIndex
			{
				position322 := position
				if buffer[position] != rune('?') {
					goto l321
				}
				position++
				if buffer[position] != rune('(') {
					goto l321
				}
				position++
				if !_rules[rulespace]() {
					goto l321
				}
				add(rulefilterStart, position322)
			}
			return true
		l321:
			position, tokenIndex = position321, tokenIndex321
			return false
		},
		/* 55 filterEnd <- <(space ')')> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				if !_rules[rulespace]() {
					goto l323
				}
				if buffer[position] != rune(')') {
					goto l323
				}
				position++
				add(rulefilterEnd, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 56 subQueryStart <- <('(' space)> */
		func() bool {
			position325, tokenIndex325 := position, tokenIndex
			{
				position326 := position
				if buffer[position] != rune('(') {
					goto l325
				}
				position++
				if !_rules[rulespace]() {
					goto l325
				}
				add(rulesubQueryStart, position326)
			}
			return true
		l325:
			position, tokenIndex = position325, tokenIndex325
			return false
		},
		/* 57 subQueryEnd <- <(space ')')> */
		func() bool {
			position327, tokenIndex327 := position, tokenIndex
			{
				position328 := position
				if !_rules[rulespace]() {
					goto l327
				}
				if buffer[position] != rune(')') {
					goto l327
				}
				position++
				add(rulesubQueryEnd, position328)
			}
			return true
		l327:
			position, tokenIndex = position327, tokenIndex327
			return false
		},
		/* 58 space <- <' '*> */
		func() bool {
			{
				position330 := position
			l331:
				{
					position332, tokenIndex332 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l332
					}
					position++
					goto l331
				l332:
					position, tokenIndex = position332, tokenIndex332
				}
				add(rulespace, position330)
			}
			return true
		},
		/* 60 Action0 <- <{
		    p.root = p.deleteRootIdentifier(p.pop().(syntaxNode))
		    p.setConnectedText(p.root)
		}> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		nil,
		/* 62 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 63 Action2 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 64 Action3 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 65 Action4 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 66 Action5 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 67 Action6 <- <{
		    p.push(text)
		}> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 68 Action7 <- <{
		    p.setLastNodeText(text)
		}> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 69 Action8 <- <{
		    p.pushRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 70 Action9 <- <{
		    p.pushCurrentRootIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 71 Action10 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 72 Action11 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 73 Action12 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 74 Action13 <- <{
		    p.pushChildSingleIdentifier(p.unescapeSingleQuotedString(text))
		}> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 75 Action14 <- <{
		    p.pushChildSingleIdentifier(p.unescapeDoubleQuotedString(text))
		}> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 76 Action15 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 77 Action16 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted {
		        step.number = 1
		    }

		    if step.number >= 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 78 Action17 <- <{
		    p.pushIndexSubscript(text)
		}> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 79 Action18 <- <{
		    p.pushWildcardSubscript()
		}> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 80 Action19 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 81 Action20 <- <{
		    p.pushIndexSubscript(`1`)
		}> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 82 Action21 <- <{
		    if len(text) > 0 {
		        p.pushIndexSubscript(text)
		    } else {
		        p.pushOmittedIndexSubscript(`0`)
		    }
		}> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 83 Action22 <- <{
		    p.pushScriptQualifier(text)
		}> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 84 Action23 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 85 Action24 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 86 Action25 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 87 Action26 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		        _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
		        _, rightIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
		        if leftIsCurrentRoot && rightIsCurrentRoot {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 88 Action27 <- <{
		    _ = p.pop()
		    jsonpathFilter := p.pop().(syntaxQuery)
		    if text[0:1] == `!` {
		        p.pushLogicalNot(jsonpathFilter)
		    } else {
		        p.push(jsonpathFilter)
		    }
		}> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 89 Action28 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    if leftParam.isLiteral {
		        p.pushCompareEQ(rightParam, leftParam)
		    } else {
		        p.pushCompareEQ(leftParam, rightParam)
		    }
		}> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 90 Action29 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    if leftParam.isLiteral {
		        p.pushCompareNE(rightParam, leftParam)
		    } else {
		        p.pushCompareNE(leftParam, rightParam)
		    }
		}> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 91 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    if leftParam.isLiteral {
		        p.pushCompareLE(rightParam, leftParam)
		    } else {
		        p.pushCompareGE(leftParam, rightParam)
		    }
		}> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 92 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    if leftParam.isLiteral {
		        p.pushCompareLT(rightParam, leftParam)
		    } else {
		        p.pushCompareGT(leftParam, rightParam)
		    }
		}> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 93 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    if leftParam.isLiteral {
		        p.pushCompareGE(rightParam, leftParam)
		    } else {
		        p.pushCompareLE(leftParam, rightParam)
		    }
		}> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 94 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    if leftParam.isLiteral {
		        p.pushCompareGT(rightParam, leftParam)
		    } else {
		        p.pushCompareLT(leftParam, rightParam)
		    }
		}> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 95 Action34 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 96 Action35 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		/* 97 Action36 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 98 Action37 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 99 Action38 <- <{
		    p.saveParams()
		}> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 100 Action39 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootIdentifier(node))
		        p.push(true)
		    case *syntaxCurrentRootIdentifier:
		        p.pushCompareParameterCurrentRoot(p.deleteRootIdentifier(node))
		        p.push(false)
		    }
		}> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 101 Action40 <- <{
		    p.push(p.toFloat(text))
		}> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 102 Action41 <- <{
		    p.push(true)
		}> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 103 Action42 <- <{
		    p.push(false)
		}> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 104 Action43 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		/* 105 Action44 <- <{
		    p.push(p.unescape(text))
		}> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 106 Action45 <- <{
		    p.push(nil)
		}> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
