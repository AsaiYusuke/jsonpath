package jsonpath

type pegJSONPathParser Peg {
    jsonPathParser
}

expression <-
    jsonpath END {
        p.root = p.pop().(syntaxNode)
    } /

    jsonpath? < .* > END {
        p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)
    }

END <- !.

jsonpath <-
    space {
        p.saveParams()
    } rootNode childNode* function* space {
        p.setNodeChain()
        p.setRecursiveMultiValue()
        p.loadParams()
    }

rootNode <-
    rootIdentifier /

    < currentRootIdentifier > {
        if len(p.paramsList) == 0 {
            p.syntaxErr(begin, msgErrorInvalidSyntaxUseBeginAtsign, buffer)
        }
    } /

    < ( bracketNode / dotChildIdentifier ) > {
        if len(p.paramsList) != 0 {
            p.syntaxErr(begin, msgErrorInvalidSyntaxOmitDollar, buffer)
        }
    }

childNode <-
    '..' ( bracketNode / dotChildIdentifier ) {
        p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
    } /

    < '.' dotChildIdentifier > {
        p.setLastNodeText(text)
    } /

    bracketNode

function <-
    < '.' functionName '()' > {
        p.pushFunction(text, p.pop().(string))
    }

functionName <-
    < [-_a-zA-Z]+ > {
        p.push(text)
    }

bracketNode <-
    < squareBracketStart ( bracketChildIdentifier / qualifier ) squareBracketEnd > {
        p.setLastNodeText(text)
    }

rootIdentifier <-
    '$' {
        p.pushRootIdentifier()
    }

currentRootIdentifier <-
    '@' {
        p.pushCurrentRootIdentifier()
    }

dotChildIdentifier <-
    < ( '\\' '\\' / '\\' [.[()=!><\t\r\n ] / [^\\.[()=!><\t\r\n ] )+ > !'()' {
        unescapedText := p.unescape(text)
        if unescapedText == `*` {
            p.pushChildAsteriskIdentifier(unescapedText)
        } else {
            p.pushChildSingleIdentifier(unescapedText)
        }
    }

bracketChildIdentifier <-
    bracketNodeIdentifiers {
        identifier := p.pop().([]string)
        if len(identifier) > 1 {
            p.pushChildMultiIdentifier(identifier)
        } else {
            p.pushChildSingleIdentifier(identifier[0])
        }
    }

bracketNodeIdentifiers <-
    ( singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier ) {
        p.push([]string{p.pop().(string)})
    } (
        sepBracketIdentifier bracketNodeIdentifiers {
            identifier2 := p.pop().([]string)
            identifier1 := p.pop().([]string)
            p.push(append(identifier1, identifier2...))
        }
    )?

singleQuotedNodeIdentifier <-
    '\'' < ( '\\' '\\' / '\\' '\'' / [^\\'] )* > '\'' {
        p.push(p.unescape(text))
    }

doubleQuotedNodeIdentifier <-
    '"' < ( '\\' '\\' / '\\' '"' / [^\\"] )* > '"' { // '
        p.push(p.unescape(text))
    }

sepBracketIdentifier <- space ',' space

qualifier <- union / script / filter

union <-
    index {
        subscript := p.pop().(syntaxSubscript)
        p.pushUnionQualifier(subscript)
    } (
        sepUnion union {
            childIndexUnion := p.pop().(*syntaxUnionQualifier)
            parentIndexUnion := p.pop().(*syntaxUnionQualifier)
            parentIndexUnion.merge(childIndexUnion)
            parentIndexUnion.setMultiValue()
            p.push(parentIndexUnion)
        }
    )?

index <-
    slice {
        step  := p.pop().(*syntaxIndexSubscript)
        end   := p.pop().(*syntaxIndexSubscript)
        start := p.pop().(*syntaxIndexSubscript)

        if step.isOmitted || step.number == 0 {
            step.number = 1
        }

        if step.number > 0 {
            p.pushSlicePositiveStepSubscript(start, end, step)
        } else {
            p.pushSliceNegativeStepSubscript(start, end, step)
        }
    } /

    < indexNumber > {
        p.pushIndexSubscript(text)
    } /

    '*' {
        p.pushAsteriskSubscript()
    }

slice <-
    anyIndex sepSlice anyIndex (
        sepSlice anyIndex /
        space {
            p.pushIndexSubscript(`1`)
        }
    )

anyIndex <-
    < ( indexNumber )? > {
        if len(text) > 0 {
            p.pushIndexSubscript(text)
        } else {
            p.pushOmittedIndexSubscript(`0`)
        }
    }

indexNumber <- [-+]? [0-9]+

sepUnion <- space ',' space
sepSlice <- space ':' space

script <-
    scriptStart < command > scriptEnd {
        p.pushScriptQualifier(text)
    }

command <- [^)]+

filter <-
    filterStart query filterEnd {
        p.pushFilterQualifier(p.pop().(syntaxQuery))
    }

query <-
    andQuery (
        logicOr query {
            childQuery := p.pop().(syntaxQuery)
            parentQuery := p.pop().(syntaxQuery)
            p.pushLogicalOr(parentQuery, childQuery)
        }
    )?

andQuery <-
    subQueryStart query subQueryEnd /
    
    basicQuery (
        logicAnd andQuery {
            childQuery := p.pop().(syntaxQuery)
            parentQuery := p.pop().(syntaxQuery)
            p.pushLogicalAnd(parentQuery, childQuery)
        }
    )?

basicQuery <-
    < comparator > {
        if !p.hasErr() {
            query := p.pop().(syntaxQuery)
            p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).param
			}
            if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
                _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
                _, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
                if leftIsCurrentRoot && rigthIsCurrentRoot {
                    p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
                }
			}
        }
    } /
    
    < ( logicNot )? > {
        p.push(len(text) > 0 && text[0:1] == `!`)
    } jsonpathFilter {
        _ = p.pop().(bool)
        jsonpathFilter := p.pop().(syntaxQuery)
        isLogicalNot := p.pop().(bool)
        if isLogicalNot {
            p.pushLogicalNot(jsonpathFilter)
        } else {
            p.push(jsonpathFilter)
        }
    }

logicOr  <- space '||' space
logicAnd <- space '&&' space
logicNot <- '!' space

comparator <-
    qParam space (
        '==' space qParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.pushCompareEQ(leftParam, rightParam)
        } /

        '!=' space qParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.pushCompareNE(leftParam, rightParam)
        }
    ) /

    qNumericParam space (
        '<=' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.pushCompareGE(leftParam, rightParam)
        } /

        '<' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareGT{},
            })
        } /

        '>=' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.pushCompareLE(leftParam, rightParam)
        } /

        '>' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.pushCompareLT(leftParam, rightParam)
        }
    ) /

    singleJsonpathFilter space '=~' space '/' < regex > '/' {
        leftParam := p.pop().(*syntaxBasicCompareParameter)
        p.pushCompareRegex(leftParam, text)
    }

qParam <-
    qLiteral {
        p.pushCompareParameterLiteral(p.pop())
    } /

    singleJsonpathFilter
    
qNumericParam <-
    lNumber {
        p.pushCompareParameterLiteral(p.pop())
    } /

    singleJsonpathFilter

qLiteral <- lNumber / lBool / lString / lNull

singleJsonpathFilter <-
    jsonpathFilter {
        isLiteral := p.pop().(bool)
        param := p.pop().(syntaxQueryParameter)
        if !p.hasErr() && param.isMultiValueParameter() {
            p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
        }
        p.pushBasicCompareParameter(param, isLiteral)
    }

jsonpathFilter <-
    < jsonpath > {
        node := p.pop().(syntaxNode)
        checkNode := node
        if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
            checkNode = aggregateFunction.param
        }

        switch checkNode.(type) {
        case *syntaxRootIdentifier:
            p.pushCompareParameterRoot(node)
            p.push(true)
        case *syntaxCurrentRootIdentifier:
            p.pushCompareParameterCurrentRoot(node)
            p.push(false)
        default:
            p.push(&syntaxQueryParamRoot{})
            p.push(true)
        }
    }

lNumber <- < [-+]? [0-9] [-+.0-9a-zA-Z]* > {
        p.push(p.toFloat(text))
    }

lBool <-
    ( 'true' / 'True' / 'TRUE' ) {
        p.push(true)
    } /
    
    ( 'false' / 'False' / 'FALSE' ) {
        p.push(false)
    }

lString <-
    '\'' < ( '\\' '\\' / '\\' '\'' / [^'] )* > '\'' {
        p.push(p.unescape(text))
    } /

    '"' < ( '\\' '\\' / '\\' '"' / [^"] )* > '"' { // '
        p.push(p.unescape(text))
    }

lNull <- ( 'null' / 'Null' / 'NULL' ) {
        p.push(nil)
    }

regex <- ( '\\' '\\' / '\\' '/' / [^/] )*

squareBracketStart <- '[' space
squareBracketEnd   <- space ']'

scriptStart <- '(' space
scriptEnd   <- space ')'

filterStart <- '?(' space
filterEnd   <- space ')'

subQueryStart <- '(' space
subQueryEnd   <- space ')'

space <- ( ' ' / '\t' )*