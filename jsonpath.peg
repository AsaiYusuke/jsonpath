package jsonpath

import "strings"
import "regexp"

type pegJSONPathParser Peg {
    jsonPathParser
}

expression <-
    jsonpath END {
        p.root = p.pop().(syntaxNode)
    } /

    jsonpath? < .* > END {
        p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)
    }

END <- !.

jsonpath <-
    space rootNode (
        childNodes {
            child := p.pop().(syntaxNode)
            root := p.pop().(syntaxNode)
            root.setNext(child)
            p.push(root)
        }
    )? space {
        rootNode := p.pop().(syntaxNode)
        checkNode := rootNode
        for checkNode != nil {
			if checkNode.isMultiValue() {
                rootNode.setMultiValue()
                break
            }
            checkNode =  checkNode.getNext()
        }
        p.push(rootNode)
    }

rootNode <-
    rootIdentifier /
    < currentRootIdentifier > {
        if len(p.params) == 1 {
            p.syntaxErr(begin, msgErrorInvalidSyntaxUseBeginAtsign, buffer)
        }
    } /
    < ( bracketNode / dotChildIdentifier ) > {
        if len(p.params) != 1 {
            p.syntaxErr(begin, msgErrorInvalidSyntaxOmitDollar, buffer)
        }
    }

childNodes <-
    (
        '..' ( bracketNode / dotChildIdentifier ) {
            node := p.pop().(syntaxNode)
            p.push(&syntaxRecursiveChildIdentifier{
                syntaxBasicNode: &syntaxBasicNode{
                    text: `..`,
                    multiValue: true,
                    next: node,
                    result: &p.resultPtr,
                },
            })
        } /

        < '.' dotChildIdentifier > {
            identifier := p.pop().(syntaxNode)
            identifier.setText(text)
            p.push(identifier)
        } /

        bracketNode

    ) ( childNodes {
        child := p.pop().(syntaxNode)
        parent := p.pop().(syntaxNode)
        parent.setNext(child)
        p.push(parent)
    } )?

bracketNode <-
    < squareBracketStart ( bracketChildIdentifier / qualifier ) squareBracketEnd > {
        node := p.pop().(syntaxNode)
        node.setText(text)
        p.push(node)
    }

rootIdentifier <-
    '$' {
        p.push(&syntaxRootIdentifier{
            syntaxBasicNode: &syntaxBasicNode{
                text: `$`,
                result: &p.resultPtr,
            },
        })
    }
currentRootIdentifier <-
    '@' {
        p.push(&syntaxCurrentRootIdentifier{
            syntaxBasicNode: &syntaxBasicNode{
                text: `@`,
                result: &p.resultPtr,
            },
        })
    }

dotChildIdentifier <-
    < ( '\\' '\\' / '\\' [.[)=!>< \t\r\n] / [^\\.[)=!>< \t\r\n] )+ > {
        unescapedText := p.unescape(text)
        if unescapedText == `*` {
            p.push(&syntaxChildAsteriskIdentifier{
                syntaxBasicNode: &syntaxBasicNode{
                    text: unescapedText,
                    multiValue: true,
                    result: &p.resultPtr,
                },
            })
        } else {
            p.push(&syntaxChildSingleIdentifier{
                identifier: unescapedText,
                syntaxBasicNode: &syntaxBasicNode{
                    text: unescapedText,
                    multiValue: false,
                    result: &p.resultPtr,
                },
            })
        }
    }

bracketChildIdentifier <-
    bracketNodeIdentifiers {
        identifier := p.pop().([]string)
        if len(identifier) > 1 {
            p.push(&syntaxChildMultiIdentifier{
                identifiers: identifier,
                syntaxBasicNode: &syntaxBasicNode{
                    multiValue: true,
                    result: &p.resultPtr,
                },
            })
        } else {
            p.push(&syntaxChildSingleIdentifier{
                identifier: identifier[0],
                syntaxBasicNode: &syntaxBasicNode{
                    multiValue: false,
                    result: &p.resultPtr,
                },
            })
        }
    }

bracketNodeIdentifiers <-
    ( singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier ) {
        p.push([]string{p.pop().(string)})
    } (
        sepBracketIdentifier bracketNodeIdentifiers {
            identifier2 := p.pop().([]string)
            identifier1 := p.pop().([]string)
            identifier1 = append(identifier1, identifier2...)
            p.push(identifier1)
        }
    )?

singleQuotedNodeIdentifier <-
    '\'' < ( '\\' '\\' / '\\' '\'' / [^\\'] )* > '\'' {
        p.push(p.unescape(text))
    }

doubleQuotedNodeIdentifier <-
    '"' < ( '\\' '\\' / '\\' '"' / [^\\"] )* > '"' { // '
        p.push(p.unescape(text))
    }

sepBracketIdentifier <- space ',' space

qualifier <- union / script / filter

union <-
    index {
        subscript := p.pop().(syntaxSubscript)
        p.push(&syntaxUnionQualifier{
            syntaxBasicNode: &syntaxBasicNode{
                multiValue: subscript.isMultiValue(),
                result: &p.resultPtr,
            },
            subscripts: []syntaxSubscript{subscript},
        })
    } (
        sepUnion union {
            childIndexUnion := p.pop().(*syntaxUnionQualifier)
            parentIndexUnion := p.pop().(*syntaxUnionQualifier)
            parentIndexUnion.merge(childIndexUnion)
            parentIndexUnion.setMultiValue()
            p.push(parentIndexUnion)
        }
    )?

index <-
    slice {
        step  := p.pop().(*syntaxIndex)
        end   := p.pop().(*syntaxIndex)
        start := p.pop().(*syntaxIndex)

        if step.isOmitted || step.number == 0 {
            step.number = 1
        }

        if step.number > 0 {
            p.push(&syntaxSlicePositiveStep{
                syntaxBasicSubscript: &syntaxBasicSubscript{
                    multiValue: true,
                },
                start: start,
                end: end,
                step: step,
            })
        } else {
            p.push(&syntaxSliceNegativeStep{
                syntaxBasicSubscript: &syntaxBasicSubscript{
                    multiValue: true,
                },
                start: start,
                end: end,
                step: step,
            })
        }
    } /

    < indexNumber > {
        p.push(&syntaxIndex{
            syntaxBasicSubscript: &syntaxBasicSubscript{
                multiValue: false,
            },
            number: p.toInt(text),
        })
    } /

    '*' {
        p.push(&syntaxAsterisk{
            syntaxBasicSubscript: &syntaxBasicSubscript{
                multiValue: true,
            },
        })
    }

slice <-
    anyIndex sepSlice anyIndex (
        sepSlice anyIndex /
        space {
            p.push(&syntaxIndex{number: 1})
        }
    )

anyIndex <-
    < ( indexNumber )? > {
        if len(text) > 0 {
            p.push(&syntaxIndex{number: p.toInt(text)})
        } else {
            p.push(&syntaxIndex{number: 0, isOmitted: true})
        }
    }

indexNumber <- [-+]? [0-9]+

sepUnion <- space ',' space
sepSlice <- space ':' space

script <-
    scriptStart < command > scriptEnd {
        p.push(&syntaxScriptQualifier{
            command: text,
            syntaxBasicNode: &syntaxBasicNode{
                multiValue: true,
                result: &p.resultPtr,
            },
        })
    }

command <- [^)]+

filter <-
    filterStart query filterEnd {
        query := p.pop().(syntaxQuery)
        p.push(&syntaxFilterQualifier{
            query: query,
            syntaxBasicNode: &syntaxBasicNode{
                multiValue: true,
                result: &p.resultPtr,
            },
        })
    }

query <-
    andQuery (
        logicOr query {
            childQuery := p.pop().(syntaxQuery)
            parentQuery := p.pop().(syntaxQuery)
            p.push(&syntaxLogicalOr{parentQuery, childQuery})
        }
    )?

andQuery <-
    subQueryStart query subQueryEnd /
    
    basicQuery (
        logicAnd andQuery {
            childQuery := p.pop().(syntaxQuery)
            parentQuery := p.pop().(syntaxQuery)
            p.push(&syntaxLogicalAnd{parentQuery, childQuery})
        }
    )?

basicQuery <-
    < comparator > {
        if !p.hasErr() {
            query := p.pop().(syntaxQuery)
            p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).param
			}
            if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
                _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
                _, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
                if leftIsCurrentRoot && rigthIsCurrentRoot {
                    p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
                }
			}
        }
    } /
    
    < ( logicNot )? > {
        p.push(strings.HasPrefix(text, `!`))
    } jsonpathFilter {
        _ = p.pop().(bool)
        jsonpathFilter := p.pop().(syntaxQuery)
        isLogicalNot := p.pop().(bool)
        if isLogicalNot {
            p.push(&syntaxLogicalNot{
                param: jsonpathFilter,
            })
        } else {
            p.push(jsonpathFilter)
        }
    }

logicOr  <- space '||' space
logicAnd <- space '&&' space
logicNot <- '!' space

comparator <-
    qParam space (
        '==' space qParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareEQ{},
            })
        } /

        '!=' space qParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxLogicalNot{
                param: &syntaxBasicCompareQuery{
                    leftParam: leftParam,
                    rightParam: rightParam,
                    comparator: &syntaxCompareEQ{},
                },
            })
        }
    ) /

    qNumericParam space (
        '<=' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareGE{},
            })
        } /

        '<' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareGT{},
            })
        } /

        '>=' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareLE{},
            })
        } /

        '>' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareLT{},
            })
        }
    ) /

    singleJsonpathFilter space '=~' space '/' < regex > '/' {
        leftParam := p.pop().(*syntaxBasicCompareParameter)
        regex := regexp.MustCompile(text)
        p.push(&syntaxBasicCompareQuery{
            leftParam: leftParam,
            rightParam: &syntaxBasicCompareParameter{
                param: &syntaxQueryParamLiteral{literal: `regex`},
                isLiteral: true,
            },
            comparator: &syntaxCompareRegex{
                regex: regex,
            },
        })
    }

qParam <-
    qLiteral {
        p.push(&syntaxBasicCompareParameter{
            param: &syntaxQueryParamLiteral{p.pop()},
            isLiteral: true,
        })
    } /

    singleJsonpathFilter
    
qNumericParam <-
    lNumber {
        p.push(&syntaxBasicCompareParameter{
            param: &syntaxQueryParamLiteral{p.pop()},
            isLiteral: true,
        })
    } /

    singleJsonpathFilter

qLiteral <- lNumber / lBool / lString / lNull

singleJsonpathFilter <-
    jsonpathFilter {
        isLiteral := p.pop().(bool)
        param := p.pop().(syntaxQueryParameter)
        if !p.hasErr() && param.isMultiValueParameter() {
            p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
        }
        p.push(&syntaxBasicCompareParameter{
            param: param,
            isLiteral: isLiteral,
        })
    }

jsonpathFilter <-
    < jsonpath > {
        node := p.pop().(syntaxNode)
        switch node.(type) {
        case *syntaxRootIdentifier:
            param := &syntaxQueryParamRoot{
                param: node,
                resultPtr: &[]interface{}{},
            }
            p.updateResultPtr(param.param, &param.resultPtr)
            p.push(param)
            p.push(true)
        case *syntaxCurrentRootIdentifier:
            param := &syntaxQueryParamCurrentRoot{
                param: node,
                resultPtr: &[]interface{}{},
            }
            p.updateResultPtr(param.param, &param.resultPtr)
            p.push(param)
            p.push(false)
        default:
            p.push(&syntaxQueryParamRoot{})
            p.push(true)
        }
    }

lNumber <- < [-+]? [0-9] [-+.0-9a-zA-Z]* > {
        p.push(p.toFloat(text))
    }

lBool <-
    ( 'true' / 'True' / 'TRUE' ) {
        p.push(true)
    } /
    
    ( 'false' / 'False' / 'FALSE' ) {
        p.push(false)
    }

lString <-
    '\'' < ( '\\' '\\' / '\\' '\'' / [^'] )* > '\'' {
        p.push(p.unescape(text))
    } /

    '"' < ( '\\' '\\' / '\\' '"' / [^"] )* > '"' { // '
        p.push(p.unescape(text))
    }

lNull <- ( 'null' / 'Null' / 'NULL' ) {
        p.push(nil)
    }

regex <- ( '\\' '\\' / '\\' '/' / [^/] )*

squareBracketStart <- '[' space
squareBracketEnd   <- space ']'

scriptStart <- '(' space
scriptEnd   <- space ')'

filterStart <- '?(' space
filterEnd   <- space ')'

subQueryStart <- '(' space
subQueryEnd   <- space ')'

space <- ( ' ' / '\t' )*