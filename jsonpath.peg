package jsonpath

type pegJSONPathParser Peg {
    jsonPathParser
}

expression <-
    jsonpath END {
        p.root = p.pop().(syntaxNode)
    } /

    jsonpath? < .* > END {
        p.syntaxErr(begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer)
    }

END <- !.

jsonpath <-
    space rootNode (
        childNodes {
            p.setNodeChain()
        }
    )? space {
        rootNode := p.pop().(syntaxNode)
        checkNode := rootNode
        for checkNode != nil {
			if checkNode.isMultiValue() {
                rootNode.setMultiValue()
                break
            }
            checkNode =  checkNode.getNext()
        }
        p.push(rootNode)
    }

rootNode <-
    rootIdentifier /
    < currentRootIdentifier > {
        if len(p.params) == 1 {
            p.syntaxErr(begin, msgErrorInvalidSyntaxUseBeginAtsign, buffer)
        }
    } /
    < ( bracketNode / dotChildIdentifier ) > {
        if len(p.params) != 1 {
            p.syntaxErr(begin, msgErrorInvalidSyntaxOmitDollar, buffer)
        }
    }

childNodes <-
    (
        '..' ( bracketNode / dotChildIdentifier ) {
            p.push(p.createRecursiveChildIdentifier(p.pop().(syntaxNode)))
        } /

        < '.' dotChildIdentifier > {
            p.setNodeText(text)
        } /

        bracketNode

    ) ( childNodes {
        p.setNodeChain()
    } )?

bracketNode <-
    < squareBracketStart ( bracketChildIdentifier / qualifier ) squareBracketEnd > {
        p.setNodeText(text)
    }

rootIdentifier <-
    '$' {
        p.push(p.createRootIdentifier())
    }
currentRootIdentifier <-
    '@' {
        p.push(p.createCurrentRootIdentifier())
    }

dotChildIdentifier <-
    < ( '\\' '\\' / '\\' [.[)=!>< \t\r\n] / [^\\.[)=!>< \t\r\n] )+ > {
        unescapedText := p.unescape(text)
        if unescapedText == `*` {
            p.push(p.createChildAsteriskIdentifier(unescapedText))
        } else {
            p.push(p.createChildSingleIdentifier(unescapedText))
        }
    }

bracketChildIdentifier <-
    bracketNodeIdentifiers {
        identifier := p.pop().([]string)
        if len(identifier) > 1 {
            p.push(p.createChildMultiIdentifier(identifier))
        } else {
            p.push(p.createChildSingleIdentifier(identifier[0]))
        }
    }

bracketNodeIdentifiers <-
    ( singleQuotedNodeIdentifier / doubleQuotedNodeIdentifier ) {
        p.push([]string{p.pop().(string)})
    } (
        sepBracketIdentifier bracketNodeIdentifiers {
            identifier2 := p.pop().([]string)
            identifier1 := p.pop().([]string)
            identifier1 = append(identifier1, identifier2...)
            p.push(identifier1)
        }
    )?

singleQuotedNodeIdentifier <-
    '\'' < ( '\\' '\\' / '\\' '\'' / [^\\'] )* > '\'' {
        p.push(p.unescape(text))
    }

doubleQuotedNodeIdentifier <-
    '"' < ( '\\' '\\' / '\\' '"' / [^\\"] )* > '"' { // '
        p.push(p.unescape(text))
    }

sepBracketIdentifier <- space ',' space

qualifier <- union / script / filter

union <-
    index {
        subscript := p.pop().(syntaxSubscript)
        p.push(p.createUnionQualifier(subscript))
    } (
        sepUnion union {
            childIndexUnion := p.pop().(*syntaxUnionQualifier)
            parentIndexUnion := p.pop().(*syntaxUnionQualifier)
            parentIndexUnion.merge(childIndexUnion)
            parentIndexUnion.setMultiValue()
            p.push(parentIndexUnion)
        }
    )?

index <-
    slice {
        step  := p.pop().(*syntaxIndexSubscript)
        end   := p.pop().(*syntaxIndexSubscript)
        start := p.pop().(*syntaxIndexSubscript)

        if step.isOmitted || step.number == 0 {
            step.number = 1
        }

        if step.number > 0 {
            p.push(p.createSliceSubscript(true, start, end, step))
        } else {
            p.push(p.createSliceSubscript(false, start, end, step))
        }
    } /

    < indexNumber > {
        p.push(p.createIndexSubscript(text, false))
    } /

    '*' {
        p.push(p.createAsteriskSubscript())
    }

slice <-
    anyIndex sepSlice anyIndex (
        sepSlice anyIndex /
        space {
            p.push(p.createIndexSubscript(`1`, false))
        }
    )

anyIndex <-
    < ( indexNumber )? > {
        if len(text) > 0 {
            p.push(p.createIndexSubscript(text, false))
        } else {
            p.push(p.createIndexSubscript(`0`, true))
        }
    }

indexNumber <- [-+]? [0-9]+

sepUnion <- space ',' space
sepSlice <- space ':' space

script <-
    scriptStart < command > scriptEnd {
        p.push(p.createScriptQualifier(text))
    }

command <- [^)]+

filter <-
    filterStart query filterEnd {
        p.push(p.createFilterQualifier(p.pop().(syntaxQuery)))
    }

query <-
    andQuery (
        logicOr query {
            childQuery := p.pop().(syntaxQuery)
            parentQuery := p.pop().(syntaxQuery)
            p.push(p.createLogicalOr(parentQuery, childQuery))
        }
    )?

andQuery <-
    subQueryStart query subQueryEnd /
    
    basicQuery (
        logicAnd andQuery {
            childQuery := p.pop().(syntaxQuery)
            parentQuery := p.pop().(syntaxQuery)
            p.push(p.createLogicalAnd(parentQuery, childQuery))
        }
    )?

basicQuery <-
    < comparator > {
        if !p.hasErr() {
            query := p.pop().(syntaxQuery)
            p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).param
			}
            if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
                _, leftIsCurrentRoot := checkQuery.leftParam.param.(*syntaxQueryParamCurrentRoot)
                _, rigthIsCurrentRoot := checkQuery.rightParam.param.(*syntaxQueryParamCurrentRoot)
                if leftIsCurrentRoot && rigthIsCurrentRoot {
                    p.syntaxErr(begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer)
                }
			}
        }
    } /
    
    < ( logicNot )? > {
        p.push(len(text) > 0 && text[0:1] == `!`)
    } jsonpathFilter {
        _ = p.pop().(bool)
        jsonpathFilter := p.pop().(syntaxQuery)
        isLogicalNot := p.pop().(bool)
        if isLogicalNot {
            p.push(p.createLogicalNot(jsonpathFilter))
        } else {
            p.push(jsonpathFilter)
        }
    }

logicOr  <- space '||' space
logicAnd <- space '&&' space
logicNot <- '!' space

comparator <-
    qParam space (
        '==' space qParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(p.createCompareEQ(leftParam, rightParam))
        } /

        '!=' space qParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(p.createCompareNE(leftParam, rightParam))
        }
    ) /

    qNumericParam space (
        '<=' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(p.createCompareGE(leftParam, rightParam))
        } /

        '<' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(&syntaxBasicCompareQuery{
                leftParam: leftParam,
                rightParam: rightParam,
                comparator: &syntaxCompareGT{},
            })
        } /

        '>=' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(p.createCompareLE(leftParam, rightParam))
        } /

        '>' space qNumericParam {
            rightParam := p.pop().(*syntaxBasicCompareParameter)
            leftParam := p.pop().(*syntaxBasicCompareParameter)
            p.push(p.createCompareLT(leftParam, rightParam))
        }
    ) /

    singleJsonpathFilter space '=~' space '/' < regex > '/' {
        leftParam := p.pop().(*syntaxBasicCompareParameter)
        p.push(p.createCompareRegex(leftParam, text))
    }

qParam <-
    qLiteral {
        p.push(p.createCompareParameterLiteral(p.pop()))
    } /

    singleJsonpathFilter
    
qNumericParam <-
    lNumber {
        p.push(p.createCompareParameterLiteral(p.pop()))
    } /

    singleJsonpathFilter

qLiteral <- lNumber / lBool / lString / lNull

singleJsonpathFilter <-
    jsonpathFilter {
        isLiteral := p.pop().(bool)
        param := p.pop().(syntaxQueryParameter)
        if !p.hasErr() && param.isMultiValueParameter() {
            p.syntaxErr(begin, msgErrorInvalidSyntaxFilterValueGroup, buffer)
        }
        p.push(p.createBasicCompareParameter(param, isLiteral))
    }

jsonpathFilter <-
    < jsonpath > {
        node := p.pop().(syntaxNode)

        switch node.(type) {
        case *syntaxRootIdentifier:
            p.push(p.createCompareParameterRoot(node))
            p.push(true)
        case *syntaxCurrentRootIdentifier:
            p.push(p.createCompareParameterCurrentRoot(node))
            p.push(false)
        default:
            p.push(&syntaxQueryParamRoot{})
            p.push(true)
        }
    }

lNumber <- < [-+]? [0-9] [-+.0-9a-zA-Z]* > {
        p.push(p.toFloat(text))
    }

lBool <-
    ( 'true' / 'True' / 'TRUE' ) {
        p.push(true)
    } /
    
    ( 'false' / 'False' / 'FALSE' ) {
        p.push(false)
    }

lString <-
    '\'' < ( '\\' '\\' / '\\' '\'' / [^'] )* > '\'' {
        p.push(p.unescape(text))
    } /

    '"' < ( '\\' '\\' / '\\' '"' / [^"] )* > '"' { // '
        p.push(p.unescape(text))
    }

lNull <- ( 'null' / 'Null' / 'NULL' ) {
        p.push(nil)
    }

regex <- ( '\\' '\\' / '\\' '/' / [^/] )*

squareBracketStart <- '[' space
squareBracketEnd   <- space ']'

scriptStart <- '(' space
scriptEnd   <- space ')'

filterStart <- '?(' space
filterEnd   <- space ')'

subQueryStart <- '(' space
subQueryEnd   <- space ')'

space <- ( ' ' / '\t' )*