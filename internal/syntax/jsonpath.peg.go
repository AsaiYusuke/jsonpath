// Code generated by peg -inline -switch internal/syntax/jsonpath.peg. DO NOT EDIT.

package syntax

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"slices"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpathQuery
	rulerootlessQuery
	rulejsonpathParameter
	rulerootIdentifier
	rulerootlessNode
	ruleparameterRootNode
	rulecurrentNodeIdentifier
	rulesegments
	rulesegment
	ruledescendantSegment
	rulechildSegment
	rulebracketedSelection
	rulefunction
	rulefunctionName
	rulememberNameShorthand
	rulenameChars
	rulesignsWithoutHyphenUnderscore
	rulecontrolCodeChars
	ruleselectors
	ruleobjectElementSelectors
	ruleobjectElementSelector
	rulewildcardSelector
	rulenameSelector
	rulearrayElementSelectors
	rulearrayElementSelector
	rulearraySliceSelector
	ruleanyIndex
	ruleomittedIndex
	ruleindexSelector
	ruleindexNumber
	rulesep
	rulesepArraySlice
	rulescriptSelector
	rulecommand
	rulefilterSelector
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulerootWithSegment
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulehexDigits
	rulehexDigit
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptSelectorStart
	rulescriptSelectorEnd
	rulefilterSelectorStart
	rulefilterSelectorEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpathQuery",
	"rootlessQuery",
	"jsonpathParameter",
	"rootIdentifier",
	"rootlessNode",
	"parameterRootNode",
	"currentNodeIdentifier",
	"segments",
	"segment",
	"descendantSegment",
	"childSegment",
	"bracketedSelection",
	"function",
	"functionName",
	"memberNameShorthand",
	"nameChars",
	"signsWithoutHyphenUnderscore",
	"controlCodeChars",
	"selectors",
	"objectElementSelectors",
	"objectElementSelector",
	"wildcardSelector",
	"nameSelector",
	"arrayElementSelectors",
	"arrayElementSelector",
	"arraySliceSelector",
	"anyIndex",
	"omittedIndex",
	"indexSelector",
	"indexNumber",
	"sep",
	"sepArraySlice",
	"scriptSelector",
	"command",
	"filterSelector",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"rootWithSegment",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"hexDigits",
	"hexDigit",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptSelectorStart",
	"scriptSelectorEnd",
	"filterSelectorStart",
	"filterSelectorEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
}

type Uint interface {
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type token[U Uint] struct {
	pegRule
	begin, end U
}

func (t *token[_]) String() string {
	// \x1B[34m = blue
	// \x1B[m   = normal (disable color)
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node[U Uint] struct {
	token[U]
	up, next *node[U]
}

func (n *node[U]) print(w io.Writer, pretty bool, buffer string) {
	var printFunc func(n *node[U], depth int)
	printFunc = func(n *node[U], depth int) {
		for n != nil {
			for range depth {
				fmt.Fprint(w, " ")
			}
			rule := rul3s[n.pegRule]
			quote := strconv.Quote(string([]rune(buffer)[n.begin:n.end]))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if n.up != nil {
				print(n.up, depth+1)
			}
			n = n.next
		}
	}
	printFunc(n, 0)
}

func (n *node[_]) Print(w io.Writer, buffer string) {
	n.print(w, false, buffer)
}

func (n *node[_]) PrettyPrint(w io.Writer, buffer string) {
	n.print(w, true, buffer)
}

type tokens[U Uint] struct {
	tree []token[U]
}

func (t *tokens[_]) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens[_]) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens[U]) AST() *node[U] {
	type element struct {
		node *node[U]
		down *element
	}
	tokenSlice := t.Tokens()
	var stack *element
	for _, token := range tokenSlice {
		if token.begin == token.end {
			continue
		}
		node := &node[U]{token: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens[_]) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens[_]) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens[_]) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens[U]) Add(rule pegRule, begin, end, index U) {
	tree, i := t.tree, int(index)
	newToken := token[U]{pegRule: rule, begin: begin, end: end}

	if i >= len(tree) {
		t.tree = append(tree, newToken)
		return
	}
	tree[i] = newToken
}

func (t *tokens[U]) Tokens() []token[U] {
	return t.tree
}

type pegJSONPathParser[U Uint] struct {
	jsonPathParser

	Buffer         string
	buffer         []rune
	rules          [113]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens[U]
}

func (p *pegJSONPathParser[_]) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser[_]) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length := len(positions)
	translations := make(textPositionMap, length)
	posIdx := 0
	line := 1
	symbol := 0

	slices.Sort(positions)

	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[posIdx] {
			translations[positions[posIdx]] = textPosition{line, symbol}
			for posIdx++; posIdx < length; posIdx++ {
				if i == positions[posIdx] {
					return translations
				}
			}
		}
		if posIdx >= length {
			break
		}
	}

	return translations
}

type parseError[U Uint] struct {
	p        *pegJSONPathParser[U]
	maxToken token[U]
}

func (e *parseError[U]) Error() string {
	tokenSlice, err := []token[U]{e.maxToken}, "\n"
	positions, p := make([]int, 2*len(tokenSlice)), 0
	for _, t := range tokenSlice {
		positions[p], p = int(t.begin), p+1
		positions[p], p = int(t.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, t := range tokenSlice {
		begin, end := int(t.begin), int(t.end)
		err += fmt.Sprintf(format,
			rul3s[t.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser[_]) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser[_]) WriteSyntaxTree(w io.Writer) {
	p.tokens.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser[_]) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *pegJSONPathParser[_]) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, t := range p.Tokens() {
		switch t.pegRule {

		case rulePegText:
			begin, end = int(t.begin), int(t.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
			p.setConnectedPath(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.pushRootNodeIdentifier()

		case ruleAction3:

			p.pushRootNodeIdentifier()

		case ruleAction4:

			p.pushCurrentNodeIdentifier()

		case ruleAction5:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction6:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction7:

			p.setLastNodePath(text)

		case ruleAction8:

			p.setLastNodePath(text)

		case ruleAction9:

			p.pushFunction(text, p.pop().(string))

		case ruleAction10:

			p.push(text)

		case ruleAction11:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction12:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction13:

			p.pushChildWildcardIdentifier()

		case ruleAction14:

			p.pushChildSingleIdentifier(p.pop().(string))

		case ruleAction15:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction16:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted {
				step.number = 1
			}

			if step.number >= 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction17:

			p.pushWildcardSubscript()

		case ruleAction18:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction19:

			p.pushOmittedIndexSubscript()

		case ruleAction20:

			p.pushIndexSubscript(text)

		case ruleAction21:

			p.pushScriptQualifier(text)

		case ruleAction22:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction23:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction24:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction25:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxCompareQuery); ok {
				leftIsCurrentNode := false
				switch checkQuery.leftParam.(type) {
				case *syntaxQueryParamCurrentNode, *syntaxQueryParamCurrentNodePath:
					leftIsCurrentNode = true
				}

				rightIsCurrentNode := false
				switch checkQuery.rightParam.(type) {
				case *syntaxQueryParamCurrentNode, *syntaxQueryParamCurrentNodePath:
					rightIsCurrentNode = true
				}
				if leftIsCurrentNode && rightIsCurrentNode {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction26:

			jsonpathFilter := p.pop().(syntaxQuery)
			p.pushLogicalNot(jsonpathFilter)

		case ruleAction27:

			rightParam := p.pop().(syntaxCompareParameter)
			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction28:

			rightParam := p.pop().(syntaxCompareParameter)
			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction29:

			rightParam := p.pop().(syntaxCompareParameter)
			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction30:

			rightParam := p.pop().(syntaxCompareParameter)
			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(syntaxCompareParameter)
			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(syntaxCompareParameter)
			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction33:

			leftParam := p.pop().(syntaxCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction34:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction35:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction36:

			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.push(param)

		case ruleAction37:

			p.saveParams()

		case ruleAction38:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootNodeIdentifier:
				p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
			case *syntaxCurrentNodeIdentifier:
				p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
			}

		case ruleAction39:

			p.push(p.toFloat(text))

		case ruleAction40:

			p.push(true)

		case ruleAction41:

			p.push(false)

		case ruleAction42:

			p.push(p.unescapeSingleQuotedString(text))

		case ruleAction43:

			p.push(p.unescapeDoubleQuotedString(text))

		case ruleAction44:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty[U Uint](pretty bool) func(*pegJSONPathParser[U]) error {
	return func(p *pegJSONPathParser[U]) error {
		p.Pretty = pretty
		return nil
	}
}

func Size[U Uint](size int) func(*pegJSONPathParser[U]) error {
	return func(p *pegJSONPathParser[U]) error {
		p.tokens = tokens[U]{tree: make([]token[U], 0, size)}
		return nil
	}
}

func DisableMemoize[U Uint]() func(*pegJSONPathParser[U]) error {
	return func(p *pegJSONPathParser[U]) error {
		p.disableMemoize = true
		return nil
	}
}

type memo[U Uint] struct {
	Matched bool
	Partial []token[U]
}

type memoKey[U Uint] struct {
	Rule     U
	Position U
}

func (p *pegJSONPathParser[U]) Init(options ...func(*pegJSONPathParser[U]) error) error {
	var (
		maxToken             token[U]
		position, tokenIndex U
		buffer               []rune
		memoization          map[memoKey[U]]memo[U]
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		maxToken = token[U]{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey[U]]memo[U])
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens = tree
		if matches {
			p.Trim(uint32(tokenIndex))
			return nil
		}
		return &parseError[U]{p, maxToken}
	}

	add := func(rule pegRule, begin U) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > maxToken.end {
			maxToken = token[U]{rule, begin, position}
		}
	}

	memoize := func(rule U, begin U, tokenIndexStart U, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey[U]{rule, begin}
		if !matched {
			memoization[key] = memo[U]{Matched: false}
		} else {
			memoization[key] = memo[U]{
				Matched: true,
				Partial: slices.Clone(tree.tree[tokenIndexStart:tokenIndex]),
			}
		}
	}

	memoizedResult := func(m memo[U]) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += U(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > maxToken.end {
			maxToken = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	_rules = [...]func() bool{
		nil,

		/* 0 expression <- <(((jsonpathQuery / rootlessQuery) END Action0) / ((jsonpathQuery / rootlessQuery)? <.*> Action1))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpathQuery]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[rulerootlessQuery]() {
							goto l3
						}
					}
				l4:
					{
						position6 := position
						{
							position7, tokenIndex7 := position, tokenIndex
							if !matchDot() {
								goto l7
							}
							goto l3
						l7:
							position, tokenIndex = position7, tokenIndex7
						}
						add(ruleEND, position6)
					}
					{
						add(ruleAction0, position)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position9, tokenIndex9 := position, tokenIndex
						{
							position11, tokenIndex11 := position, tokenIndex
							if !_rules[rulejsonpathQuery]() {
								goto l12
							}
							goto l11
						l12:
							position, tokenIndex = position11, tokenIndex11
							if !_rules[rulerootlessQuery]() {
								goto l9
							}
						}
					l11:
						goto l10
					l9:
						position, tokenIndex = position9, tokenIndex9
					}
				l10:
					{
						position13 := position
					l14:
						{
							position15, tokenIndex15 := position, tokenIndex
							if !matchDot() {
								goto l15
							}
							goto l14
						l15:
							position, tokenIndex = position15, tokenIndex15
						}
						add(rulePegText, position13)
					}
					{
						add(ruleAction1, position)
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		},
		/* 1 END <- <!.> */
		nil,
		/* 2 jsonpathQuery <- <(space rootIdentifier segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				_rules[rulespace]()
				if !_rules[rulerootIdentifier]() {
					goto l18
				}
				_rules[rulesegments]()
				add(rulejsonpathQuery, position19)
			}
			memoize(2, position18, tokenIndex18, true)
			return true
		l18:
			memoize(2, position18, tokenIndex18, false)
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 3 rootlessQuery <- <(space rootlessNode segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{3, position}]; ok {
				return memoizedResult(memoized)
			}
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				_rules[rulespace]()
				{
					position22 := position
					{
						add(ruleAction3, position)
					}
					{
						position24, tokenIndex24 := position, tokenIndex
						if !_rules[rulesegment]() {
							goto l25
						}
						goto l24
					l25:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[rulememberNameShorthand]() {
							goto l20
						}
					}
				l24:
					add(rulerootlessNode, position22)
				}
				_rules[rulesegments]()
				add(rulerootlessQuery, position21)
			}
			memoize(3, position20, tokenIndex20, true)
			return true
		l20:
			memoize(3, position20, tokenIndex20, false)
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 4 jsonpathParameter <- <(space parameterRootNode segments)> */
		nil,
		/* 5 rootIdentifier <- <('$' Action2)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{5, position}]; ok {
				return memoizedResult(memoized)
			}
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if buffer[position] != '$' {
					goto l27
				}
				position++
				{
					add(ruleAction2, position)
				}
				add(rulerootIdentifier, position28)
			}
			memoize(5, position27, tokenIndex27, true)
			return true
		l27:
			memoize(5, position27, tokenIndex27, false)
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 6 rootlessNode <- <(Action3 (segment / memberNameShorthand))> */
		nil,
		/* 7 parameterRootNode <- <(rootIdentifier / currentNodeIdentifier)> */
		nil,
		/* 8 currentNodeIdentifier <- <('@' Action4)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{8, position}]; ok {
				return memoizedResult(memoized)
			}
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if buffer[position] != '@' {
					goto l32
				}
				position++
				{
					add(ruleAction4, position)
				}
				add(rulecurrentNodeIdentifier, position33)
			}
			memoize(8, position32, tokenIndex32, true)
			return true
		l32:
			memoize(8, position32, tokenIndex32, false)
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 9 segments <- <(segment* function* space Action5)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
			l37:
				{
					position38, tokenIndex38 := position, tokenIndex
					if !_rules[rulesegment]() {
						goto l38
					}
					goto l37
				l38:
					position, tokenIndex = position38, tokenIndex38
				}
			l39:
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[rulefunction]() {
						goto l40
					}
					goto l39
				l40:
					position, tokenIndex = position40, tokenIndex40
				}
				_rules[rulespace]()
				{
					add(ruleAction5, position)
				}
				add(rulesegments, position36)
			}
			memoize(9, position35, tokenIndex35, true)
			return true
		},
		/* 10 segment <- <(descendantSegment / childSegment)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{10, position}]; ok {
				return memoizedResult(memoized)
			}
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44, tokenIndex44 := position, tokenIndex
					{
						position46 := position
						if buffer[position] != '.' {
							goto l45
						}
						position++
						if buffer[position] != '.' {
							goto l45
						}
						position++
						{
							position47, tokenIndex47 := position, tokenIndex
							if !_rules[rulebracketedSelection]() {
								goto l48
							}
							goto l47
						l48:
							position, tokenIndex = position47, tokenIndex47
							if !_rules[rulememberNameShorthand]() {
								goto l45
							}
						}
					l47:
						{
							add(ruleAction6, position)
						}
						add(ruledescendantSegment, position46)
					}
					goto l44
				l45:
					position, tokenIndex = position44, tokenIndex44
					{
						position50 := position
						{
							position51, tokenIndex51 := position, tokenIndex
							{
								position53 := position
								if buffer[position] != '.' {
									goto l52
								}
								position++
								if !_rules[rulememberNameShorthand]() {
									goto l52
								}
								add(rulePegText, position53)
							}
							{
								add(ruleAction7, position)
							}
							goto l51
						l52:
							position, tokenIndex = position51, tokenIndex51
							if !_rules[rulebracketedSelection]() {
								goto l42
							}
						}
					l51:
						add(rulechildSegment, position50)
					}
				}
			l44:
				add(rulesegment, position43)
			}
			memoize(10, position42, tokenIndex42, true)
			return true
		l42:
			memoize(10, position42, tokenIndex42, false)
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 11 descendantSegment <- <('.' '.' (bracketedSelection / memberNameShorthand) Action6)> */
		nil,
		/* 12 childSegment <- <((<('.' memberNameShorthand)> Action7) / bracketedSelection)> */
		nil,
		/* 13 bracketedSelection <- <(<(squareBracketStart selectors squareBracketEnd)> Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				{
					position59 := position
					{
						position60 := position
						if buffer[position] != '[' {
							goto l57
						}
						position++
						_rules[rulespace]()
						add(rulesquareBracketStart, position60)
					}
					{
						position61 := position
						{
							position62, tokenIndex62 := position, tokenIndex
							{
								position64 := position
								if !_rules[ruleobjectElementSelector]() {
									goto l63
								}
							l65:
								{
									position66, tokenIndex66 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l66
									}
									if !_rules[ruleobjectElementSelector]() {
										goto l66
									}
									{
										add(ruleAction12, position)
									}
									goto l65
								l66:
									position, tokenIndex = position66, tokenIndex66
								}
								{
									position68, tokenIndex68 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l68
									}
									goto l63
								l68:
									position, tokenIndex = position68, tokenIndex68
								}
								add(ruleobjectElementSelectors, position64)
							}
							goto l62
						l63:
							position, tokenIndex = position62, tokenIndex62
							{
								switch buffer[position] {
								case '(':
									{
										position70 := position
										{
											position71 := position
											position++
											_rules[rulespace]()
											add(rulescriptSelectorStart, position71)
										}
										{
											position72 := position
											{
												position73 := position
												{
													position76, tokenIndex76 := position, tokenIndex
													if !_rules[rulescriptSelectorEnd]() {
														goto l76
													}
													goto l57
												l76:
													position, tokenIndex = position76, tokenIndex76
												}
												if !matchDot() {
													goto l57
												}
											l74:
												{
													position75, tokenIndex75 := position, tokenIndex
													{
														position77, tokenIndex77 := position, tokenIndex
														if !_rules[rulescriptSelectorEnd]() {
															goto l77
														}
														goto l75
													l77:
														position, tokenIndex = position77, tokenIndex77
													}
													if !matchDot() {
														goto l75
													}
													goto l74
												l75:
													position, tokenIndex = position75, tokenIndex75
												}
												add(rulecommand, position73)
											}
											add(rulePegText, position72)
										}
										if !_rules[rulescriptSelectorEnd]() {
											goto l57
										}
										{
											add(ruleAction21, position)
										}
										add(rulescriptSelector, position70)
									}
								case '?':
									{
										position79 := position
										{
											position80 := position
											position++
											if buffer[position] != '(' {
												goto l57
											}
											position++
											_rules[rulespace]()
											add(rulefilterSelectorStart, position80)
										}
										if !_rules[rulequery]() {
											goto l57
										}
										{
											position81 := position
											_rules[rulespace]()
											if buffer[position] != ')' {
												goto l57
											}
											position++
											add(rulefilterSelectorEnd, position81)
										}
										{
											add(ruleAction22, position)
										}
										add(rulefilterSelector, position79)
									}
								default:
									{
										position83 := position
										if !_rules[rulearrayElementSelector]() {
											goto l57
										}
									l84:
										{
											position85, tokenIndex85 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l85
											}
											if !_rules[rulearrayElementSelector]() {
												goto l85
											}
											{
												add(ruleAction15, position)
											}
											goto l84
										l85:
											position, tokenIndex = position85, tokenIndex85
										}
										{
											position87, tokenIndex87 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l87
											}
											goto l57
										l87:
											position, tokenIndex = position87, tokenIndex87
										}
										add(rulearrayElementSelectors, position83)
									}
								}
							}

						}
					l62:
						add(ruleselectors, position61)
					}
					{
						position88 := position
						_rules[rulespace]()
						if buffer[position] != ']' {
							goto l57
						}
						position++
						add(rulesquareBracketEnd, position88)
					}
					add(rulePegText, position59)
				}
				{
					add(ruleAction8, position)
				}
				add(rulebracketedSelection, position58)
			}
			memoize(13, position57, tokenIndex57, true)
			return true
		l57:
			memoize(13, position57, tokenIndex57, false)
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 14 function <- <(<('.' functionName ('(' ')'))> Action9)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{14, position}]; ok {
				return memoizedResult(memoized)
			}
			position90, tokenIndex90 := position, tokenIndex
			{
				position91 := position
				{
					position92 := position
					if buffer[position] != '.' {
						goto l90
					}
					position++
					{
						position93 := position
						{
							position94 := position
							if !_rules[rulenameChars]() {
								goto l90
							}
						l95:
							{
								position96, tokenIndex96 := position, tokenIndex
								if !_rules[rulenameChars]() {
									goto l96
								}
								goto l95
							l96:
								position, tokenIndex = position96, tokenIndex96
							}
							add(rulePegText, position94)
						}
						{
							add(ruleAction10, position)
						}
						add(rulefunctionName, position93)
					}
					if buffer[position] != '(' {
						goto l90
					}
					position++
					if buffer[position] != ')' {
						goto l90
					}
					position++
					add(rulePegText, position92)
				}
				{
					add(ruleAction9, position)
				}
				add(rulefunction, position91)
			}
			memoize(14, position90, tokenIndex90, true)
			return true
		l90:
			memoize(14, position90, tokenIndex90, false)
			position, tokenIndex = position90, tokenIndex90
			return false
		},
		/* 15 functionName <- <(<nameChars+> Action10)> */
		nil,
		/* 16 memberNameShorthand <- <(wildcardSelector / (<(('\\' signsWithoutHyphenUnderscore) / (!(controlCodeChars / signsWithoutHyphenUnderscore) .))+> !('(' ')') Action11))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position100, tokenIndex100 := position, tokenIndex
			{
				position101 := position
				{
					position102, tokenIndex102 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l103
					}
					goto l102
				l103:
					position, tokenIndex = position102, tokenIndex102
					{
						position104 := position
						{
							position107, tokenIndex107 := position, tokenIndex
							if buffer[position] != '\\' {
								goto l108
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l108
							}
							goto l107
						l108:
							position, tokenIndex = position107, tokenIndex107
							{
								position109, tokenIndex109 := position, tokenIndex
								{
									position110, tokenIndex110 := position, tokenIndex
									{
										position112 := position
										{
											position113, tokenIndex113 := position, tokenIndex
											if c := buffer[position]; c < '\x00' || c > '\x1f' {
												goto l114
											}
											position++
											goto l113
										l114:
											position, tokenIndex = position113, tokenIndex113
											if buffer[position] != '\x7f' {
												goto l111
											}
											position++
										}
									l113:
										add(rulecontrolCodeChars, position112)
									}
									goto l110
								l111:
									position, tokenIndex = position110, tokenIndex110
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l109
									}
								}
							l110:
								goto l100
							l109:
								position, tokenIndex = position109, tokenIndex109
							}
							if !matchDot() {
								goto l100
							}
						}
					l107:
					l105:
						{
							position106, tokenIndex106 := position, tokenIndex
							{
								position115, tokenIndex115 := position, tokenIndex
								if buffer[position] != '\\' {
									goto l116
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l116
								}
								goto l115
							l116:
								position, tokenIndex = position115, tokenIndex115
								{
									position117, tokenIndex117 := position, tokenIndex
									{
										position118, tokenIndex118 := position, tokenIndex
										{
											position120 := position
											{
												position121, tokenIndex121 := position, tokenIndex
												if c := buffer[position]; c < '\x00' || c > '\x1f' {
													goto l122
												}
												position++
												goto l121
											l122:
												position, tokenIndex = position121, tokenIndex121
												if buffer[position] != '\x7f' {
													goto l119
												}
												position++
											}
										l121:
											add(rulecontrolCodeChars, position120)
										}
										goto l118
									l119:
										position, tokenIndex = position118, tokenIndex118
										if !_rules[rulesignsWithoutHyphenUnderscore]() {
											goto l117
										}
									}
								l118:
									goto l106
								l117:
									position, tokenIndex = position117, tokenIndex117
								}
								if !matchDot() {
									goto l106
								}
							}
						l115:
							goto l105
						l106:
							position, tokenIndex = position106, tokenIndex106
						}
						add(rulePegText, position104)
					}
					{
						position123, tokenIndex123 := position, tokenIndex
						if buffer[position] != '(' {
							goto l123
						}
						position++
						if buffer[position] != ')' {
							goto l123
						}
						position++
						goto l100
					l123:
						position, tokenIndex = position123, tokenIndex123
					}
					{
						add(ruleAction11, position)
					}
				}
			l102:
				add(rulememberNameShorthand, position101)
			}
			memoize(16, position100, tokenIndex100, true)
			return true
		l100:
			memoize(16, position100, tokenIndex100, false)
			position, tokenIndex = position100, tokenIndex100
			return false
		},
		/* 17 nameChars <- <((&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					switch buffer[position] {
					case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
						position++
					case '_':
						position++
					case '-':
						position++
					default:
						if c := buffer[position]; c < 'a' || c > 'z' {
							goto l125
						}
						position++
					}
				}

				add(rulenameChars, position126)
			}
			memoize(17, position125, tokenIndex125, true)
			return true
		l125:
			memoize(17, position125, tokenIndex125, false)
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 18 signsWithoutHyphenUnderscore <- <(!nameChars [ -~])> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{18, position}]; ok {
				return memoizedResult(memoized)
			}
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				{
					position130, tokenIndex130 := position, tokenIndex
					if !_rules[rulenameChars]() {
						goto l130
					}
					goto l128
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
				if c := buffer[position]; c < ' ' || c > '~' {
					goto l128
				}
				position++
				add(rulesignsWithoutHyphenUnderscore, position129)
			}
			memoize(18, position128, tokenIndex128, true)
			return true
		l128:
			memoize(18, position128, tokenIndex128, false)
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 19 controlCodeChars <- <([\x00-\x1f] / '\x7f')> */
		nil,
		/* 20 selectors <- <(objectElementSelectors / ((&('(') scriptSelector) | (&('?') filterSelector) | (&(' ' | '*' | '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':') arrayElementSelectors)))> */
		nil,
		/* 21 objectElementSelectors <- <(objectElementSelector (sep objectElementSelector Action12)* !sep)> */
		nil,
		/* 22 objectElementSelector <- <(wildcardSelector / nameSelector)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{22, position}]; ok {
				return memoizedResult(memoized)
			}
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				{
					position136, tokenIndex136 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l137
					}
					goto l136
				l137:
					position, tokenIndex = position136, tokenIndex136
					{
						position138 := position
						if !_rules[rulelString]() {
							goto l134
						}
						{
							add(ruleAction14, position)
						}
						add(rulenameSelector, position138)
					}
				}
			l136:
				add(ruleobjectElementSelector, position135)
			}
			memoize(22, position134, tokenIndex134, true)
			return true
		l134:
			memoize(22, position134, tokenIndex134, false)
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 23 wildcardSelector <- <('*' Action13)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{23, position}]; ok {
				return memoizedResult(memoized)
			}
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				if buffer[position] != '*' {
					goto l140
				}
				position++
				{
					add(ruleAction13, position)
				}
				add(rulewildcardSelector, position141)
			}
			memoize(23, position140, tokenIndex140, true)
			return true
		l140:
			memoize(23, position140, tokenIndex140, false)
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 24 nameSelector <- <(lString Action14)> */
		nil,
		/* 25 arrayElementSelectors <- <(arrayElementSelector (sep arrayElementSelector Action15)* !sep)> */
		nil,
		/* 26 arrayElementSelector <- <(((arraySliceSelector Action16) / indexSelector / ('*' Action17)) Action18)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				{
					position147, tokenIndex147 := position, tokenIndex
					{
						position149 := position
						_rules[ruleanyIndex]()
						if !_rules[rulesepArraySlice]() {
							goto l148
						}
						_rules[ruleanyIndex]()
						{
							position150, tokenIndex150 := position, tokenIndex
							if !_rules[rulesepArraySlice]() {
								goto l151
							}
							_rules[ruleanyIndex]()
							goto l150
						l151:
							position, tokenIndex = position150, tokenIndex150
							_rules[ruleomittedIndex]()
						}
					l150:
						add(rulearraySliceSelector, position149)
					}
					{
						add(ruleAction16, position)
					}
					goto l147
				l148:
					position, tokenIndex = position147, tokenIndex147
					{
						position154 := position
						if !_rules[ruleindexNumber]() {
							goto l153
						}
						add(ruleindexSelector, position154)
					}
					goto l147
				l153:
					position, tokenIndex = position147, tokenIndex147
					if buffer[position] != '*' {
						goto l145
					}
					position++
					{
						add(ruleAction17, position)
					}
				}
			l147:
				{
					add(ruleAction18, position)
				}
				add(rulearrayElementSelector, position146)
			}
			memoize(26, position145, tokenIndex145, true)
			return true
		l145:
			memoize(26, position145, tokenIndex145, false)
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 27 arraySliceSelector <- <(anyIndex sepArraySlice anyIndex ((sepArraySlice anyIndex) / omittedIndex))> */
		nil,
		/* 28 anyIndex <- <(indexNumber / omittedIndex)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position158, tokenIndex158 := position, tokenIndex
			{
				position159 := position
				{
					position160, tokenIndex160 := position, tokenIndex
					if !_rules[ruleindexNumber]() {
						goto l161
					}
					goto l160
				l161:
					position, tokenIndex = position160, tokenIndex160
					_rules[ruleomittedIndex]()
				}
			l160:
				add(ruleanyIndex, position159)
			}
			memoize(28, position158, tokenIndex158, true)
			return true
		},
		/* 29 omittedIndex <- <Action19> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					add(ruleAction19, position)
				}
				add(ruleomittedIndex, position163)
			}
			memoize(29, position162, tokenIndex162, true)
			return true
		},
		/* 30 indexSelector <- <indexNumber> */
		nil,
		/* 31 indexNumber <- <(<(('-' / '+')? [0-9]+)> Action20)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{31, position}]; ok {
				return memoizedResult(memoized)
			}
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				{
					position168 := position
					{
						position169, tokenIndex169 := position, tokenIndex
						{
							position171, tokenIndex171 := position, tokenIndex
							if buffer[position] != '-' {
								goto l172
							}
							position++
							goto l171
						l172:
							position, tokenIndex = position171, tokenIndex171
							if buffer[position] != '+' {
								goto l169
							}
							position++
						}
					l171:
						goto l170
					l169:
						position, tokenIndex = position169, tokenIndex169
					}
				l170:
					if c := buffer[position]; c < '0' || c > '9' {
						goto l166
					}
					position++
				l173:
					{
						position174, tokenIndex174 := position, tokenIndex
						if c := buffer[position]; c < '0' || c > '9' {
							goto l174
						}
						position++
						goto l173
					l174:
						position, tokenIndex = position174, tokenIndex174
					}
					add(rulePegText, position168)
				}
				{
					add(ruleAction20, position)
				}
				add(ruleindexNumber, position167)
			}
			memoize(31, position166, tokenIndex166, true)
			return true
		l166:
			memoize(31, position166, tokenIndex166, false)
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 32 sep <- <(space ',' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{32, position}]; ok {
				return memoizedResult(memoized)
			}
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				_rules[rulespace]()
				if buffer[position] != ',' {
					goto l176
				}
				position++
				_rules[rulespace]()
				add(rulesep, position177)
			}
			memoize(32, position176, tokenIndex176, true)
			return true
		l176:
			memoize(32, position176, tokenIndex176, false)
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 33 sepArraySlice <- <(space ':' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				_rules[rulespace]()
				if buffer[position] != ':' {
					goto l178
				}
				position++
				_rules[rulespace]()
				add(rulesepArraySlice, position179)
			}
			memoize(33, position178, tokenIndex178, true)
			return true
		l178:
			memoize(33, position178, tokenIndex178, false)
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 34 scriptSelector <- <(scriptSelectorStart <command> scriptSelectorEnd Action21)> */
		nil,
		/* 35 command <- <(!scriptSelectorEnd .)+> */
		nil,
		/* 36 filterSelector <- <(filterSelectorStart query filterSelectorEnd Action22)> */
		nil,
		/* 37 query <- <(andQuery (logicOr andQuery Action23)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{37, position}]; ok {
				return memoizedResult(memoized)
			}
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				if !_rules[ruleandQuery]() {
					goto l183
				}
			l185:
				{
					position186, tokenIndex186 := position, tokenIndex
					{
						position187 := position
						_rules[rulespace]()
						if buffer[position] != '|' {
							goto l186
						}
						position++
						if buffer[position] != '|' {
							goto l186
						}
						position++
						_rules[rulespace]()
						add(rulelogicOr, position187)
					}
					if !_rules[ruleandQuery]() {
						goto l186
					}
					{
						add(ruleAction23, position)
					}
					goto l185
				l186:
					position, tokenIndex = position186, tokenIndex186
				}
				add(rulequery, position184)
			}
			memoize(37, position183, tokenIndex183, true)
			return true
		l183:
			memoize(37, position183, tokenIndex183, false)
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 38 andQuery <- <(basicQuery (logicAnd basicQuery Action24)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{38, position}]; ok {
				return memoizedResult(memoized)
			}
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				if !_rules[rulebasicQuery]() {
					goto l189
				}
			l191:
				{
					position192, tokenIndex192 := position, tokenIndex
					{
						position193 := position
						_rules[rulespace]()
						if buffer[position] != '&' {
							goto l192
						}
						position++
						if buffer[position] != '&' {
							goto l192
						}
						position++
						_rules[rulespace]()
						add(rulelogicAnd, position193)
					}
					if !_rules[rulebasicQuery]() {
						goto l192
					}
					{
						add(ruleAction24, position)
					}
					goto l191
				l192:
					position, tokenIndex = position192, tokenIndex192
				}
				add(ruleandQuery, position190)
			}
			memoize(38, position189, tokenIndex189, true)
			return true
		l189:
			memoize(38, position189, tokenIndex189, false)
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 39 basicQuery <- <((<comparator> Action25) / ((&('!') (logicNot jsonpathFilter Action26)) | (&('(') (subQueryStart query subQueryEnd)) | (&(' ' | '$' | '@') jsonpathFilter)))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position195, tokenIndex195 := position, tokenIndex
			{
				position196 := position
				{
					position197, tokenIndex197 := position, tokenIndex
					{
						position199 := position
						{
							position200 := position
							{
								position201, tokenIndex201 := position, tokenIndex
								if !_rules[ruleqParam]() {
									goto l202
								}
								_rules[rulespace]()
								{
									position203, tokenIndex203 := position, tokenIndex
									if buffer[position] != '=' {
										goto l204
									}
									position++
									if buffer[position] != '=' {
										goto l204
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqParam]() {
										goto l204
									}
									{
										add(ruleAction27, position)
									}
									goto l203
								l204:
									position, tokenIndex = position203, tokenIndex203
									if buffer[position] != '!' {
										goto l202
									}
									position++
									if buffer[position] != '=' {
										goto l202
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqParam]() {
										goto l202
									}
									{
										add(ruleAction28, position)
									}
								}
							l203:
								goto l201
							l202:
								position, tokenIndex = position201, tokenIndex201
								if !_rules[ruleqNumericParam]() {
									goto l207
								}
								_rules[rulespace]()
								{
									position208, tokenIndex208 := position, tokenIndex
									if buffer[position] != '<' {
										goto l209
									}
									position++
									if buffer[position] != '=' {
										goto l209
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l209
									}
									{
										add(ruleAction29, position)
									}
									goto l208
								l209:
									position, tokenIndex = position208, tokenIndex208
									if buffer[position] != '<' {
										goto l211
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l211
									}
									{
										add(ruleAction30, position)
									}
									goto l208
								l211:
									position, tokenIndex = position208, tokenIndex208
									if buffer[position] != '>' {
										goto l213
									}
									position++
									if buffer[position] != '=' {
										goto l213
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l213
									}
									{
										add(ruleAction31, position)
									}
									goto l208
								l213:
									position, tokenIndex = position208, tokenIndex208
									if buffer[position] != '>' {
										goto l207
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l207
									}
									{
										add(ruleAction32, position)
									}
								}
							l208:
								goto l201
							l207:
								position, tokenIndex = position201, tokenIndex201
								if !_rules[rulesingleJsonpathFilter]() {
									goto l198
								}
								_rules[rulespace]()
								if buffer[position] != '=' {
									goto l198
								}
								position++
								if buffer[position] != '~' {
									goto l198
								}
								position++
								_rules[rulespace]()
								if buffer[position] != '/' {
									goto l198
								}
								position++
								{
									position216 := position
									{
										position217 := position
									l218:
										{
											position219, tokenIndex219 := position, tokenIndex
											{
												position220, tokenIndex220 := position, tokenIndex
												{
													position222, tokenIndex222 := position, tokenIndex
													{
														position223, tokenIndex223 := position, tokenIndex
														if buffer[position] != '/' {
															goto l224
														}
														position++
														goto l223
													l224:
														position, tokenIndex = position223, tokenIndex223
														if buffer[position] != '\\' {
															goto l222
														}
														position++
													}
												l223:
													goto l221
												l222:
													position, tokenIndex = position222, tokenIndex222
												}
												if !matchDot() {
													goto l221
												}
												goto l220
											l221:
												position, tokenIndex = position220, tokenIndex220
												if buffer[position] != '\\' {
													goto l219
												}
												position++
												if !matchDot() {
													goto l219
												}
											}
										l220:
											goto l218
										l219:
											position, tokenIndex = position219, tokenIndex219
										}
										add(ruleregex, position217)
									}
									add(rulePegText, position216)
								}
								if buffer[position] != '/' {
									goto l198
								}
								position++
								{
									add(ruleAction33, position)
								}
							}
						l201:
							add(rulecomparator, position200)
						}
						add(rulePegText, position199)
					}
					{
						add(ruleAction25, position)
					}
					goto l197
				l198:
					position, tokenIndex = position197, tokenIndex197
					{
						switch buffer[position] {
						case '!':
							{
								position228 := position
								position++
								_rules[rulespace]()
								add(rulelogicNot, position228)
							}
							if !_rules[rulejsonpathFilter]() {
								goto l195
							}
							{
								add(ruleAction26, position)
							}
						case '(':
							{
								position230 := position
								position++
								_rules[rulespace]()
								add(rulesubQueryStart, position230)
							}
							if !_rules[rulequery]() {
								goto l195
							}
							{
								position231 := position
								_rules[rulespace]()
								if buffer[position] != ')' {
									goto l195
								}
								position++
								add(rulesubQueryEnd, position231)
							}
						default:
							if !_rules[rulejsonpathFilter]() {
								goto l195
							}
						}
					}

				}
			l197:
				add(rulebasicQuery, position196)
			}
			memoize(39, position195, tokenIndex195, true)
			return true
		l195:
			memoize(39, position195, tokenIndex195, false)
			position, tokenIndex = position195, tokenIndex195
			return false
		},
		/* 40 logicOr <- <(space ('|' '|') space)> */
		nil,
		/* 41 logicAnd <- <(space ('&' '&') space)> */
		nil,
		/* 42 logicNot <- <('!' space)> */
		nil,
		/* 43 comparator <- <((qParam space (('=' '=' space qParam Action27) / ('!' '=' space qParam Action28))) / (qNumericParam space (('<' '=' space qNumericParam Action29) / ('<' space qNumericParam Action30) / ('>' '=' space qNumericParam Action31) / ('>' space qNumericParam Action32))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action33))> */
		nil,
		/* 44 qParam <- <((qLiteral Action34) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position236, tokenIndex236 := position, tokenIndex
			{
				position237 := position
				{
					position238, tokenIndex238 := position, tokenIndex
					{
						position240 := position
						{
							switch buffer[position] {
							case 'N', 'n':
								{
									position242 := position
									{
										position243, tokenIndex243 := position, tokenIndex
										if buffer[position] != 'n' {
											goto l244
										}
										position++
										if buffer[position] != 'u' {
											goto l244
										}
										position++
										if buffer[position] != 'l' {
											goto l244
										}
										position++
										if buffer[position] != 'l' {
											goto l244
										}
										position++
										goto l243
									l244:
										position, tokenIndex = position243, tokenIndex243
										if buffer[position] != 'N' {
											goto l245
										}
										position++
										if buffer[position] != 'u' {
											goto l245
										}
										position++
										if buffer[position] != 'l' {
											goto l245
										}
										position++
										if buffer[position] != 'l' {
											goto l245
										}
										position++
										goto l243
									l245:
										position, tokenIndex = position243, tokenIndex243
										if buffer[position] != 'N' {
											goto l239
										}
										position++
										if buffer[position] != 'U' {
											goto l239
										}
										position++
										if buffer[position] != 'L' {
											goto l239
										}
										position++
										if buffer[position] != 'L' {
											goto l239
										}
										position++
									}
								l243:
									{
										add(ruleAction44, position)
									}
									add(rulelNull, position242)
								}
							case '"', '\'':
								if !_rules[rulelString]() {
									goto l239
								}
							case 'F', 'T', 'f', 't':
								{
									position247 := position
									{
										position248, tokenIndex248 := position, tokenIndex
										{
											position250, tokenIndex250 := position, tokenIndex
											if buffer[position] != 't' {
												goto l251
											}
											position++
											if buffer[position] != 'r' {
												goto l251
											}
											position++
											if buffer[position] != 'u' {
												goto l251
											}
											position++
											if buffer[position] != 'e' {
												goto l251
											}
											position++
											goto l250
										l251:
											position, tokenIndex = position250, tokenIndex250
											if buffer[position] != 'T' {
												goto l252
											}
											position++
											if buffer[position] != 'r' {
												goto l252
											}
											position++
											if buffer[position] != 'u' {
												goto l252
											}
											position++
											if buffer[position] != 'e' {
												goto l252
											}
											position++
											goto l250
										l252:
											position, tokenIndex = position250, tokenIndex250
											if buffer[position] != 'T' {
												goto l249
											}
											position++
											if buffer[position] != 'R' {
												goto l249
											}
											position++
											if buffer[position] != 'U' {
												goto l249
											}
											position++
											if buffer[position] != 'E' {
												goto l249
											}
											position++
										}
									l250:
										{
											add(ruleAction40, position)
										}
										goto l248
									l249:
										position, tokenIndex = position248, tokenIndex248
										{
											position254, tokenIndex254 := position, tokenIndex
											if buffer[position] != 'f' {
												goto l255
											}
											position++
											if buffer[position] != 'a' {
												goto l255
											}
											position++
											if buffer[position] != 'l' {
												goto l255
											}
											position++
											if buffer[position] != 's' {
												goto l255
											}
											position++
											if buffer[position] != 'e' {
												goto l255
											}
											position++
											goto l254
										l255:
											position, tokenIndex = position254, tokenIndex254
											if buffer[position] != 'F' {
												goto l256
											}
											position++
											if buffer[position] != 'a' {
												goto l256
											}
											position++
											if buffer[position] != 'l' {
												goto l256
											}
											position++
											if buffer[position] != 's' {
												goto l256
											}
											position++
											if buffer[position] != 'e' {
												goto l256
											}
											position++
											goto l254
										l256:
											position, tokenIndex = position254, tokenIndex254
											if buffer[position] != 'F' {
												goto l239
											}
											position++
											if buffer[position] != 'A' {
												goto l239
											}
											position++
											if buffer[position] != 'L' {
												goto l239
											}
											position++
											if buffer[position] != 'S' {
												goto l239
											}
											position++
											if buffer[position] != 'E' {
												goto l239
											}
											position++
										}
									l254:
										{
											add(ruleAction41, position)
										}
									}
								l248:
									add(rulelBool, position247)
								}
							default:
								if !_rules[rulelNumber]() {
									goto l239
								}
							}
						}

						add(ruleqLiteral, position240)
					}
					{
						add(ruleAction34, position)
					}
					goto l238
				l239:
					position, tokenIndex = position238, tokenIndex238
					if !_rules[rulesingleJsonpathFilter]() {
						goto l236
					}
				}
			l238:
				add(ruleqParam, position237)
			}
			memoize(44, position236, tokenIndex236, true)
			return true
		l236:
			memoize(44, position236, tokenIndex236, false)
			position, tokenIndex = position236, tokenIndex236
			return false
		},
		/* 45 qNumericParam <- <((lNumber Action35) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position259, tokenIndex259 := position, tokenIndex
			{
				position260 := position
				{
					position261, tokenIndex261 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l262
					}
					{
						add(ruleAction35, position)
					}
					goto l261
				l262:
					position, tokenIndex = position261, tokenIndex261
					if !_rules[rulesingleJsonpathFilter]() {
						goto l259
					}
				}
			l261:
				add(ruleqNumericParam, position260)
			}
			memoize(45, position259, tokenIndex259, true)
			return true
		l259:
			memoize(45, position259, tokenIndex259, false)
			position, tokenIndex = position259, tokenIndex259
			return false
		},
		/* 46 qLiteral <- <((&('N' | 'n') lNull) | (&('"' | '\'') lString) | (&('F' | 'T' | 'f' | 't') lBool) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') lNumber))> */
		nil,
		/* 47 singleJsonpathFilter <- <(<(&(rootWithSegment / currentNodeIdentifier) jsonpathFilter)> Action36)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{47, position}]; ok {
				return memoizedResult(memoized)
			}
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				{
					position267 := position
					{
						position268, tokenIndex268 := position, tokenIndex
						{
							position269, tokenIndex269 := position, tokenIndex
							{
								position271 := position
								if !_rules[rulerootIdentifier]() {
									goto l270
								}
								{
									position272, tokenIndex272 := position, tokenIndex
									if !_rules[rulesegment]() {
										goto l273
									}
									goto l272
								l273:
									position, tokenIndex = position272, tokenIndex272
									if !_rules[rulefunction]() {
										goto l270
									}
								}
							l272:
								add(rulerootWithSegment, position271)
							}
							goto l269
						l270:
							position, tokenIndex = position269, tokenIndex269
							if !_rules[rulecurrentNodeIdentifier]() {
								goto l265
							}
						}
					l269:
						position, tokenIndex = position268, tokenIndex268
					}
					if !_rules[rulejsonpathFilter]() {
						goto l265
					}
					add(rulePegText, position267)
				}
				{
					add(ruleAction36, position)
				}
				add(rulesingleJsonpathFilter, position266)
			}
			memoize(47, position265, tokenIndex265, true)
			return true
		l265:
			memoize(47, position265, tokenIndex265, false)
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 48 rootWithSegment <- <(rootIdentifier (segment / function))> */
		nil,
		/* 49 jsonpathFilter <- <(Action37 jsonpathParameter Action38)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position276, tokenIndex276 := position, tokenIndex
			{
				position277 := position
				{
					add(ruleAction37, position)
				}
				{
					position279 := position
					_rules[rulespace]()
					{
						position280 := position
						{
							position281, tokenIndex281 := position, tokenIndex
							if !_rules[rulerootIdentifier]() {
								goto l282
							}
							goto l281
						l282:
							position, tokenIndex = position281, tokenIndex281
							if !_rules[rulecurrentNodeIdentifier]() {
								goto l276
							}
						}
					l281:
						add(ruleparameterRootNode, position280)
					}
					_rules[rulesegments]()
					add(rulejsonpathParameter, position279)
				}
				{
					add(ruleAction38, position)
				}
				add(rulejsonpathFilter, position277)
			}
			memoize(49, position276, tokenIndex276, true)
			return true
		l276:
			memoize(49, position276, tokenIndex276, false)
			position, tokenIndex = position276, tokenIndex276
			return false
		},
		/* 50 lNumber <- <(<(('-' / '+')? [0-9] ((&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('.') '.') | (&('+') '+') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action39)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{50, position}]; ok {
				return memoizedResult(memoized)
			}
			position284, tokenIndex284 := position, tokenIndex
			{
				position285 := position
				{
					position286 := position
					{
						position287, tokenIndex287 := position, tokenIndex
						{
							position289, tokenIndex289 := position, tokenIndex
							if buffer[position] != '-' {
								goto l290
							}
							position++
							goto l289
						l290:
							position, tokenIndex = position289, tokenIndex289
							if buffer[position] != '+' {
								goto l287
							}
							position++
						}
					l289:
						goto l288
					l287:
						position, tokenIndex = position287, tokenIndex287
					}
				l288:
					if c := buffer[position]; c < '0' || c > '9' {
						goto l284
					}
					position++
				l291:
					{
						position292, tokenIndex292 := position, tokenIndex
						{
							switch buffer[position] {
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								position++
							case '.':
								position++
							case '+':
								position++
							case '-':
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								position++
							default:
								if c := buffer[position]; c < 'a' || c > 'z' {
									goto l292
								}
								position++
							}
						}

						goto l291
					l292:
						position, tokenIndex = position292, tokenIndex292
					}
					add(rulePegText, position286)
				}
				{
					add(ruleAction39, position)
				}
				add(rulelNumber, position285)
			}
			memoize(50, position284, tokenIndex284, true)
			return true
		l284:
			memoize(50, position284, tokenIndex284, false)
			position, tokenIndex = position284, tokenIndex284
			return false
		},
		/* 51 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action40) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action41))> */
		nil,
		/* 52 lString <- <(('\'' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('\'') '\''))) / (!('\'' / '\\') .))*> '\'' Action42) / ('"' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('"') '"'))) / (!('"' / '\\') .))*> '"' Action43))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{52, position}]; ok {
				return memoizedResult(memoized)
			}
			position296, tokenIndex296 := position, tokenIndex
			{
				position297 := position
				{
					position298, tokenIndex298 := position, tokenIndex
					if buffer[position] != '\'' {
						goto l299
					}
					position++
					{
						position300 := position
					l301:
						{
							position302, tokenIndex302 := position, tokenIndex
							{
								position303, tokenIndex303 := position, tokenIndex
								if buffer[position] != '\\' {
									goto l304
								}
								position++
								{
									switch buffer[position] {
									case 'u':
										if !_rules[rulehexDigits]() {
											goto l304
										}
									case 't':
										position++
									case 'r':
										position++
									case 'n':
										position++
									case 'f':
										position++
									case 'b':
										position++
									case '\\':
										position++
									case '/':
										position++
									default:
										if buffer[position] != '\'' {
											goto l304
										}
										position++
									}
								}

								goto l303
							l304:
								position, tokenIndex = position303, tokenIndex303
								{
									position306, tokenIndex306 := position, tokenIndex
									{
										position307, tokenIndex307 := position, tokenIndex
										if buffer[position] != '\'' {
											goto l308
										}
										position++
										goto l307
									l308:
										position, tokenIndex = position307, tokenIndex307
										if buffer[position] != '\\' {
											goto l306
										}
										position++
									}
								l307:
									goto l302
								l306:
									position, tokenIndex = position306, tokenIndex306
								}
								if !matchDot() {
									goto l302
								}
							}
						l303:
							goto l301
						l302:
							position, tokenIndex = position302, tokenIndex302
						}
						add(rulePegText, position300)
					}
					if buffer[position] != '\'' {
						goto l299
					}
					position++
					{
						add(ruleAction42, position)
					}
					goto l298
				l299:
					position, tokenIndex = position298, tokenIndex298
					if buffer[position] != '"' {
						goto l296
					}
					position++
					{
						position310 := position
					l311:
						{
							position312, tokenIndex312 := position, tokenIndex
							{
								position313, tokenIndex313 := position, tokenIndex
								if buffer[position] != '\\' {
									goto l314
								}
								position++
								{
									switch buffer[position] {
									case 'u':
										if !_rules[rulehexDigits]() {
											goto l314
										}
									case 't':
										position++
									case 'r':
										position++
									case 'n':
										position++
									case 'f':
										position++
									case 'b':
										position++
									case '\\':
										position++
									case '/':
										position++
									default:
										if buffer[position] != '"' {
											goto l314
										}
										position++
									}
								}

								goto l313
							l314:
								position, tokenIndex = position313, tokenIndex313
								{
									position316, tokenIndex316 := position, tokenIndex
									{
										position317, tokenIndex317 := position, tokenIndex
										if buffer[position] != '"' {
											goto l318
										}
										position++
										goto l317
									l318:
										position, tokenIndex = position317, tokenIndex317
										if buffer[position] != '\\' {
											goto l316
										}
										position++
									}
								l317:
									goto l312
								l316:
									position, tokenIndex = position316, tokenIndex316
								}
								if !matchDot() {
									goto l312
								}
							}
						l313:
							goto l311
						l312:
							position, tokenIndex = position312, tokenIndex312
						}
						add(rulePegText, position310)
					}
					if buffer[position] != '"' {
						goto l296
					}
					position++
					{
						add(ruleAction43, position)
					}
				}
			l298:
				add(rulelString, position297)
			}
			memoize(52, position296, tokenIndex296, true)
			return true
		l296:
			memoize(52, position296, tokenIndex296, false)
			position, tokenIndex = position296, tokenIndex296
			return false
		},
		/* 53 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{53, position}]; ok {
				return memoizedResult(memoized)
			}
			position320, tokenIndex320 := position, tokenIndex
			{
				position321 := position
				if buffer[position] != 'u' {
					goto l320
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l320
				}
				if !_rules[rulehexDigit]() {
					goto l320
				}
				if !_rules[rulehexDigit]() {
					goto l320
				}
				if !_rules[rulehexDigit]() {
					goto l320
				}
				add(rulehexDigits, position321)
			}
			memoize(53, position320, tokenIndex320, true)
			return true
		l320:
			memoize(53, position320, tokenIndex320, false)
			position, tokenIndex = position320, tokenIndex320
			return false
		},
		/* 54 hexDigit <- <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{54, position}]; ok {
				return memoizedResult(memoized)
			}
			position322, tokenIndex322 := position, tokenIndex
			{
				position323 := position
				{
					switch buffer[position] {
					case 'A', 'B', 'C', 'D', 'E', 'F':
						position++
					case 'a', 'b', 'c', 'd', 'e', 'f':
						position++
					default:
						if c := buffer[position]; c < '0' || c > '9' {
							goto l322
						}
						position++
					}
				}

				add(rulehexDigit, position323)
			}
			memoize(54, position322, tokenIndex322, true)
			return true
		l322:
			memoize(54, position322, tokenIndex322, false)
			position, tokenIndex = position322, tokenIndex322
			return false
		},
		/* 55 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action44)> */
		nil,
		/* 56 regex <- <((!('/' / '\\') .) / ('\\' .))*> */
		nil,
		/* 57 squareBracketStart <- <('[' space)> */
		nil,
		/* 58 squareBracketEnd <- <(space ']')> */
		nil,
		/* 59 scriptSelectorStart <- <('(' space)> */
		nil,
		/* 60 scriptSelectorEnd <- <(space ')')> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{60, position}]; ok {
				return memoizedResult(memoized)
			}
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				_rules[rulespace]()
				if buffer[position] != ')' {
					goto l330
				}
				position++
				add(rulescriptSelectorEnd, position331)
			}
			memoize(60, position330, tokenIndex330, true)
			return true
		l330:
			memoize(60, position330, tokenIndex330, false)
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 61 filterSelectorStart <- <('?' '(' space)> */
		nil,
		/* 62 filterSelectorEnd <- <(space ')')> */
		nil,
		/* 63 subQueryStart <- <('(' space)> */
		nil,
		/* 64 subQueryEnd <- <(space ')')> */
		nil,
		/* 65 space <- <' '*> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{65, position}]; ok {
				return memoizedResult(memoized)
			}
			position336, tokenIndex336 := position, tokenIndex
			{
				position337 := position
			l338:
				{
					position339, tokenIndex339 := position, tokenIndex
					if buffer[position] != ' ' {
						goto l339
					}
					position++
					goto l338
				l339:
					position, tokenIndex = position339, tokenIndex339
				}
				add(rulespace, position337)
			}
			memoize(65, position336, tokenIndex336, true)
			return true
		},
		/* 67 Action0 <- <{
		    p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
		    p.setConnectedPath(p.root)
		}> */
		nil,
		nil,
		/* 69 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		nil,
		/* 70 Action2 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 71 Action3 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 72 Action4 <- <{
		    p.pushCurrentNodeIdentifier()
		}> */
		nil,
		/* 73 Action5 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		nil,
		/* 74 Action6 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		nil,
		/* 75 Action7 <- <{
		    p.setLastNodePath(text)
		}> */
		nil,
		/* 76 Action8 <- <{
		    p.setLastNodePath(text)
		}> */
		nil,
		/* 77 Action9 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		nil,
		/* 78 Action10 <- <{
		    p.push(text)
		}> */
		nil,
		/* 79 Action11 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		nil,
		/* 80 Action12 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		nil,
		/* 81 Action13 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		nil,
		/* 82 Action14 <- <{
		    p.pushChildSingleIdentifier(p.pop().(string))
		}> */
		nil,
		/* 83 Action15 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		nil,
		/* 84 Action16 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted {
		        step.number = 1
		    }

		    if step.number >= 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		nil,
		/* 85 Action17 <- <{
		    p.pushWildcardSubscript()
		}> */
		nil,
		/* 86 Action18 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		nil,
		/* 87 Action19 <- <{
		    p.pushOmittedIndexSubscript()
		}> */
		nil,
		/* 88 Action20 <- <{
		    p.pushIndexSubscript(text)
		}> */
		nil,
		/* 89 Action21 <- <{
		    p.pushScriptQualifier(text)
		}> */
		nil,
		/* 90 Action22 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		nil,
		/* 91 Action23 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		nil,
		/* 92 Action24 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		nil,
		/* 93 Action25 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxCompareQuery); ok {
		        leftIsCurrentNode := false
		        switch checkQuery.leftParam.(type) {
		        case *syntaxQueryParamCurrentNode, *syntaxQueryParamCurrentNodePath:
		            leftIsCurrentNode = true
		        }

		        rightIsCurrentNode := false
		        switch checkQuery.rightParam.(type) {
		        case *syntaxQueryParamCurrentNode, *syntaxQueryParamCurrentNodePath:
		            rightIsCurrentNode = true
		        }
		        if leftIsCurrentNode && rightIsCurrentNode {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		nil,
		/* 94 Action26 <- <{
		    jsonpathFilter := p.pop().(syntaxQuery)
		    p.pushLogicalNot(jsonpathFilter)
		}> */
		nil,
		/* 95 Action27 <- <{
		    rightParam := p.pop().(syntaxCompareParameter)
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		nil,
		/* 96 Action28 <- <{
		    rightParam := p.pop().(syntaxCompareParameter)
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		nil,
		/* 97 Action29 <- <{
		    rightParam := p.pop().(syntaxCompareParameter)
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		nil,
		/* 98 Action30 <- <{
		    rightParam := p.pop().(syntaxCompareParameter)
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		nil,
		/* 99 Action31 <- <{
		    rightParam := p.pop().(syntaxCompareParameter)
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		nil,
		/* 100 Action32 <- <{
		    rightParam := p.pop().(syntaxCompareParameter)
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		nil,
		/* 101 Action33 <- <{
		    leftParam := p.pop().(syntaxCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		nil,
		/* 102 Action34 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 103 Action35 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 104 Action36 <- <{
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.push(param)
		}> */
		nil,
		/* 105 Action37 <- <{
		    p.saveParams()
		}> */
		nil,
		/* 106 Action38 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootNodeIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
		    case *syntaxCurrentNodeIdentifier:
		        p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
		    }
		}> */
		nil,
		/* 107 Action39 <- <{
		    p.push(p.toFloat(text))
		}> */
		nil,
		/* 108 Action40 <- <{
		    p.push(true)
		}> */
		nil,
		/* 109 Action41 <- <{
		    p.push(false)
		}> */
		nil,
		/* 110 Action42 <- <{
		    p.push(p.unescapeSingleQuotedString(text))
		}> */
		nil,
		/* 111 Action43 <- <{
		    p.push(p.unescapeDoubleQuotedString(text))
		}> */
		nil,
		/* 112 Action44 <- <{
		    p.push(nil)
		}> */
		nil,
	}
	p.rules = _rules
	return nil
}
