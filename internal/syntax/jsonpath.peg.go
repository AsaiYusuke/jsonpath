// Code generated by peg -inline -switch internal/syntax/jsonpath.peg. DO NOT EDIT.

package syntax

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"slices"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleexpression
	ruleEND
	rulejsonpathQuery
	rulerootlessQuery
	rulejsonpathParameter
	rulerootIdentifier
	rulerootlessNode
	ruleparameterRootNode
	rulecurrentNodeIdentifier
	rulesegments
	rulesegment
	ruledescendantSegment
	rulechildSegment
	rulebracketedSelection
	rulefunction
	rulefunctionName
	rulememberNameShorthand
	rulenameChars
	rulesignsWithoutHyphenUnderscore
	rulecontrolCodeChars
	ruleselectors
	ruleobjectElementSelectors
	ruleobjectElementSelector
	rulewildcardSelector
	rulenameSelector
	rulearrayElementSelectors
	rulearrayElementSelector
	rulearraySliceSelector
	ruleanyIndex
	ruleomittedIndex
	ruleindexSelector
	ruleindexNumber
	rulesep
	rulesepArraySlice
	rulescriptSelector
	rulecommand
	rulefilterSelector
	rulequery
	ruleandQuery
	rulebasicQuery
	rulelogicOr
	rulelogicAnd
	rulelogicNot
	rulecomparator
	ruleqParam
	ruleqNumericParam
	ruleqLiteral
	rulesingleJsonpathFilter
	rulejsonpathFilter
	rulelNumber
	rulelBool
	rulelString
	rulehexDigits
	rulehexDigit
	rulelNull
	ruleregex
	rulesquareBracketStart
	rulesquareBracketEnd
	rulescriptSelectorStart
	rulescriptSelectorEnd
	rulefilterSelectorStart
	rulefilterSelectorEnd
	rulesubQueryStart
	rulesubQueryEnd
	rulespace
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
)

var rul3s = [...]string{
	"Unknown",
	"expression",
	"END",
	"jsonpathQuery",
	"rootlessQuery",
	"jsonpathParameter",
	"rootIdentifier",
	"rootlessNode",
	"parameterRootNode",
	"currentNodeIdentifier",
	"segments",
	"segment",
	"descendantSegment",
	"childSegment",
	"bracketedSelection",
	"function",
	"functionName",
	"memberNameShorthand",
	"nameChars",
	"signsWithoutHyphenUnderscore",
	"controlCodeChars",
	"selectors",
	"objectElementSelectors",
	"objectElementSelector",
	"wildcardSelector",
	"nameSelector",
	"arrayElementSelectors",
	"arrayElementSelector",
	"arraySliceSelector",
	"anyIndex",
	"omittedIndex",
	"indexSelector",
	"indexNumber",
	"sep",
	"sepArraySlice",
	"scriptSelector",
	"command",
	"filterSelector",
	"query",
	"andQuery",
	"basicQuery",
	"logicOr",
	"logicAnd",
	"logicNot",
	"comparator",
	"qParam",
	"qNumericParam",
	"qLiteral",
	"singleJsonpathFilter",
	"jsonpathFilter",
	"lNumber",
	"lBool",
	"lString",
	"hexDigits",
	"hexDigit",
	"lNull",
	"regex",
	"squareBracketStart",
	"squareBracketEnd",
	"scriptSelectorStart",
	"scriptSelectorEnd",
	"filterSelectorStart",
	"filterSelectorEnd",
	"subQueryStart",
	"subQueryEnd",
	"space",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
}

type Uint interface {
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type token[U Uint] struct {
	pegRule
	begin, end U
}

func (t *token[_]) String() string {
	// \x1B[34m = blue
	// \x1B[m   = normal (disable color)
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node[U Uint] struct {
	token[U]
	up, next *node[U]
}

func (n *node[U]) print(w io.Writer, pretty bool, buffer string) {
	var printFunc func(n *node[U], depth int)
	printFunc = func(n *node[U], depth int) {
		for n != nil {
			for range depth {
				fmt.Fprint(w, " ")
			}
			rule := rul3s[n.pegRule]
			quote := strconv.Quote(string([]rune(buffer)[n.begin:n.end]))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if n.up != nil {
				print(n.up, depth+1)
			}
			n = n.next
		}
	}
	printFunc(n, 0)
}

func (n *node[_]) Print(w io.Writer, buffer string) {
	n.print(w, false, buffer)
}

func (n *node[_]) PrettyPrint(w io.Writer, buffer string) {
	n.print(w, true, buffer)
}

type tokens[U Uint] struct {
	tree []token[U]
}

func (t *tokens[_]) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens[_]) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens[U]) AST() *node[U] {
	type element struct {
		node *node[U]
		down *element
	}
	tokenSlice := t.Tokens()
	var stack *element
	for _, token := range tokenSlice {
		if token.begin == token.end {
			continue
		}
		node := &node[U]{token: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens[_]) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens[_]) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens[_]) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens[U]) Add(rule pegRule, begin, end, index U) {
	tree, i := t.tree, int(index)
	newToken := token[U]{pegRule: rule, begin: begin, end: end}

	if i >= len(tree) {
		t.tree = append(tree, newToken)
		return
	}
	tree[i] = newToken
}

func (t *tokens[U]) Tokens() []token[U] {
	return t.tree
}

type pegJSONPathParser[U Uint] struct {
	jsonPathParser

	Buffer         string
	buffer         []rune
	rules          [113]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens[U]
}

func (p *pegJSONPathParser[_]) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *pegJSONPathParser[_]) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length := len(positions)
	translations := make(textPositionMap, length)
	posIdx := 0
	line := 1
	symbol := 0

	slices.Sort(positions)

	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[posIdx] {
			translations[positions[posIdx]] = textPosition{line, symbol}
			for posIdx++; posIdx < length; posIdx++ {
				if i == positions[posIdx] {
					return translations
				}
			}
		}
		if posIdx >= length {
			break
		}
	}

	return translations
}

type parseError[U Uint] struct {
	p        *pegJSONPathParser[U]
	maxToken token[U]
}

func (e *parseError[U]) Error() string {
	tokenSlice, err := []token[U]{e.maxToken}, "\n"
	positions, p := make([]int, 2*len(tokenSlice)), 0
	for _, t := range tokenSlice {
		positions[p], p = int(t.begin), p+1
		positions[p], p = int(t.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, t := range tokenSlice {
		begin, end := int(t.begin), int(t.end)
		err += fmt.Sprintf(format,
			rul3s[t.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *pegJSONPathParser[_]) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens.PrintSyntaxTree(p.Buffer)
	}
}

func (p *pegJSONPathParser[_]) WriteSyntaxTree(w io.Writer) {
	p.tokens.WriteSyntaxTree(w, p.Buffer)
}

func (p *pegJSONPathParser[_]) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *pegJSONPathParser[_]) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, t := range p.Tokens() {
		switch t.pegRule {

		case rulePegText:
			begin, end = int(t.begin), int(t.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
			p.setConnectedPath(p.root)

		case ruleAction1:

			panic(p.syntaxErr(
				begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))

		case ruleAction2:

			p.pushRootNodeIdentifier()

		case ruleAction3:

			p.pushRootNodeIdentifier()

		case ruleAction4:

			p.pushCurrentNodeIdentifier()

		case ruleAction5:

			p.setNodeChain()
			p.updateRootValueGroup()

		case ruleAction6:

			p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))

		case ruleAction7:

			p.setLastNodePath(text)

		case ruleAction8:

			p.setLastNodePath(text)

		case ruleAction9:

			p.pushFunction(text, p.pop().(string))

		case ruleAction10:

			p.push(text)

		case ruleAction11:

			p.pushChildSingleIdentifier(p.unescape(text))

		case ruleAction12:

			identifier2 := p.pop().(syntaxNode)
			identifier1 := p.pop().(syntaxNode)
			p.pushChildMultiIdentifier(identifier1, identifier2)

		case ruleAction13:

			p.pushChildWildcardIdentifier()

		case ruleAction14:

			p.pushChildSingleIdentifier(p.pop().(string))

		case ruleAction15:

			childIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion := p.pop().(*syntaxUnionQualifier)
			parentIndexUnion.merge(childIndexUnion)
			parentIndexUnion.setValueGroup()
			p.push(parentIndexUnion)

		case ruleAction16:

			step := p.pop().(*syntaxIndexSubscript)
			end := p.pop().(*syntaxIndexSubscript)
			start := p.pop().(*syntaxIndexSubscript)

			if step.isOmitted {
				step.number = 1
			}

			if step.number >= 0 {
				p.pushSlicePositiveStepSubscript(start, end, step)
			} else {
				p.pushSliceNegativeStepSubscript(start, end, step)
			}

		case ruleAction17:

			p.pushWildcardSubscript()

		case ruleAction18:

			p.pushUnionQualifier(p.pop().(syntaxSubscript))

		case ruleAction19:

			p.pushOmittedIndexSubscript()

		case ruleAction20:

			p.pushIndexSubscript(text)

		case ruleAction21:

			p.pushScriptQualifier(text)

		case ruleAction22:

			p.pushFilterQualifier(p.pop().(syntaxQuery))

		case ruleAction23:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalOr(leftQuery, rightQuery)

		case ruleAction24:

			rightQuery := p.pop().(syntaxQuery)
			leftQuery := p.pop().(syntaxQuery)
			p.pushLogicalAnd(leftQuery, rightQuery)

		case ruleAction25:

			query := p.pop()
			p.push(query)

			if logicalNot, ok := query.(*syntaxLogicalNot); ok {
				query = (*logicalNot).query
			}
			if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
				_, leftIsCurrentNode := checkQuery.leftParam.param.(*syntaxQueryParamCurrentNode)
				_, rightIsCurrentNode := checkQuery.rightParam.param.(*syntaxQueryParamCurrentNode)
				if leftIsCurrentNode && rightIsCurrentNode {
					panic(p.syntaxErr(
						begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
				}
			}

		case ruleAction26:

			_ = p.pop()
			jsonpathFilter := p.pop().(syntaxQuery)
			p.pushLogicalNot(jsonpathFilter)

		case ruleAction27:

			_ = p.pop()

		case ruleAction28:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareEQ(leftParam, rightParam)

		case ruleAction29:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareNE(leftParam, rightParam)

		case ruleAction30:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLE(leftParam, rightParam)

		case ruleAction31:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareLT(leftParam, rightParam)

		case ruleAction32:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGE(leftParam, rightParam)

		case ruleAction33:

			rightParam := p.pop().(*syntaxBasicCompareParameter)
			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareGT(leftParam, rightParam)

		case ruleAction34:

			leftParam := p.pop().(*syntaxBasicCompareParameter)
			p.pushCompareRegex(leftParam, text)

		case ruleAction35:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction36:

			p.pushCompareParameterLiteral(p.pop())

		case ruleAction37:

			isLiteral := p.pop().(bool)
			param := p.pop().(syntaxQueryJSONPathParameter)
			if param.isValueGroupParameter() {
				panic(p.syntaxErr(
					begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
			}
			p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)

		case ruleAction38:

			p.saveParams()

		case ruleAction39:

			p.loadParams()

			node := p.pop().(syntaxNode)
			checkNode := node
			if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
				checkNode = aggregateFunction.param
			}

			switch checkNode.(type) {
			case *syntaxRootNodeIdentifier:
				p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
				p.push(true)
			case *syntaxCurrentNodeIdentifier:
				p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
				p.push(false)
			}

		case ruleAction40:

			p.push(p.toFloat(text))

		case ruleAction41:

			p.push(true)

		case ruleAction42:

			p.push(false)

		case ruleAction43:

			p.push(p.unescapeSingleQuotedString(text))

		case ruleAction44:

			p.push(p.unescapeDoubleQuotedString(text))

		case ruleAction45:

			p.push(nil)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty[U Uint](pretty bool) func(*pegJSONPathParser[U]) error {
	return func(p *pegJSONPathParser[U]) error {
		p.Pretty = pretty
		return nil
	}
}

func Size[U Uint](size int) func(*pegJSONPathParser[U]) error {
	return func(p *pegJSONPathParser[U]) error {
		p.tokens = tokens[U]{tree: make([]token[U], 0, size)}
		return nil
	}
}

func DisableMemoize[U Uint]() func(*pegJSONPathParser[U]) error {
	return func(p *pegJSONPathParser[U]) error {
		p.disableMemoize = true
		return nil
	}
}

type memo[U Uint] struct {
	Matched bool
	Partial []token[U]
}

type memoKey[U Uint] struct {
	Rule     U
	Position U
}

func (p *pegJSONPathParser[U]) Init(options ...func(*pegJSONPathParser[U]) error) error {
	var (
		maxToken             token[U]
		position, tokenIndex U
		buffer               []rune
		memoization          map[memoKey[U]]memo[U]
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		maxToken = token[U]{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey[U]]memo[U])
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens = tree
		if matches {
			p.Trim(uint32(tokenIndex))
			return nil
		}
		return &parseError[U]{p, maxToken}
	}

	add := func(rule pegRule, begin U) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > maxToken.end {
			maxToken = token[U]{rule, begin, position}
		}
	}

	memoize := func(rule U, begin U, tokenIndexStart U, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey[U]{rule, begin}
		if !matched {
			memoization[key] = memo[U]{Matched: false}
		} else {
			memoization[key] = memo[U]{
				Matched: true,
				Partial: slices.Clone(tree.tree[tokenIndexStart:tokenIndex]),
			}
		}
	}

	memoizedResult := func(m memo[U]) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += U(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > maxToken.end {
			maxToken = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	_rules = [...]func() bool{
		nil,

		/* 0 expression <- <(((jsonpathQuery / rootlessQuery) END Action0) / ((jsonpathQuery / rootlessQuery)? <.*> Action1))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[rulejsonpathQuery]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[rulerootlessQuery]() {
							goto l3
						}
					}
				l4:
					{
						position6 := position
						{
							position7, tokenIndex7 := position, tokenIndex
							if !matchDot() {
								goto l7
							}
							goto l3
						l7:
							position, tokenIndex = position7, tokenIndex7
						}
						add(ruleEND, position6)
					}
					{
						add(ruleAction0, position)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position9, tokenIndex9 := position, tokenIndex
						{
							position11, tokenIndex11 := position, tokenIndex
							if !_rules[rulejsonpathQuery]() {
								goto l12
							}
							goto l11
						l12:
							position, tokenIndex = position11, tokenIndex11
							if !_rules[rulerootlessQuery]() {
								goto l9
							}
						}
					l11:
						goto l10
					l9:
						position, tokenIndex = position9, tokenIndex9
					}
				l10:
					{
						position13 := position
					l14:
						{
							position15, tokenIndex15 := position, tokenIndex
							if !matchDot() {
								goto l15
							}
							goto l14
						l15:
							position, tokenIndex = position15, tokenIndex15
						}
						add(rulePegText, position13)
					}
					{
						add(ruleAction1, position)
					}
				}
			l2:
				add(ruleexpression, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		},
		/* 1 END <- <!.> */
		nil,
		/* 2 jsonpathQuery <- <(space rootIdentifier segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				_rules[rulespace]()
				if !_rules[rulerootIdentifier]() {
					goto l18
				}
				_rules[rulesegments]()
				add(rulejsonpathQuery, position19)
			}
			memoize(2, position18, tokenIndex18, true)
			return true
		l18:
			memoize(2, position18, tokenIndex18, false)
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 3 rootlessQuery <- <(space rootlessNode segments)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{3, position}]; ok {
				return memoizedResult(memoized)
			}
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				_rules[rulespace]()
				{
					position22 := position
					{
						add(ruleAction3, position)
					}
					{
						position24, tokenIndex24 := position, tokenIndex
						if !_rules[rulesegment]() {
							goto l25
						}
						goto l24
					l25:
						position, tokenIndex = position24, tokenIndex24
						if !_rules[rulememberNameShorthand]() {
							goto l20
						}
					}
				l24:
					add(rulerootlessNode, position22)
				}
				_rules[rulesegments]()
				add(rulerootlessQuery, position21)
			}
			memoize(3, position20, tokenIndex20, true)
			return true
		l20:
			memoize(3, position20, tokenIndex20, false)
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 4 jsonpathParameter <- <(space parameterRootNode segments)> */
		nil,
		/* 5 rootIdentifier <- <('$' Action2)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{5, position}]; ok {
				return memoizedResult(memoized)
			}
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if buffer[position] != '$' {
					goto l27
				}
				position++
				{
					add(ruleAction2, position)
				}
				add(rulerootIdentifier, position28)
			}
			memoize(5, position27, tokenIndex27, true)
			return true
		l27:
			memoize(5, position27, tokenIndex27, false)
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 6 rootlessNode <- <(Action3 (segment / memberNameShorthand))> */
		nil,
		/* 7 parameterRootNode <- <(rootIdentifier / currentNodeIdentifier)> */
		nil,
		/* 8 currentNodeIdentifier <- <('@' Action4)> */
		nil,
		/* 9 segments <- <(segment* function* space Action5)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position33, tokenIndex33 := position, tokenIndex
			{
				position34 := position
			l35:
				{
					position36, tokenIndex36 := position, tokenIndex
					if !_rules[rulesegment]() {
						goto l36
					}
					goto l35
				l36:
					position, tokenIndex = position36, tokenIndex36
				}
			l37:
				{
					position38, tokenIndex38 := position, tokenIndex
					{
						position39 := position
						{
							position40 := position
							if buffer[position] != '.' {
								goto l38
							}
							position++
							{
								position41 := position
								{
									position42 := position
									if !_rules[rulenameChars]() {
										goto l38
									}
								l43:
									{
										position44, tokenIndex44 := position, tokenIndex
										if !_rules[rulenameChars]() {
											goto l44
										}
										goto l43
									l44:
										position, tokenIndex = position44, tokenIndex44
									}
									add(rulePegText, position42)
								}
								{
									add(ruleAction10, position)
								}
								add(rulefunctionName, position41)
							}
							if buffer[position] != '(' {
								goto l38
							}
							position++
							if buffer[position] != ')' {
								goto l38
							}
							position++
							add(rulePegText, position40)
						}
						{
							add(ruleAction9, position)
						}
						add(rulefunction, position39)
					}
					goto l37
				l38:
					position, tokenIndex = position38, tokenIndex38
				}
				_rules[rulespace]()
				{
					add(ruleAction5, position)
				}
				add(rulesegments, position34)
			}
			memoize(9, position33, tokenIndex33, true)
			return true
		},
		/* 10 segment <- <(descendantSegment / childSegment)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{10, position}]; ok {
				return memoizedResult(memoized)
			}
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				{
					position50, tokenIndex50 := position, tokenIndex
					{
						position52 := position
						if buffer[position] != '.' {
							goto l51
						}
						position++
						if buffer[position] != '.' {
							goto l51
						}
						position++
						{
							position53, tokenIndex53 := position, tokenIndex
							if !_rules[rulebracketedSelection]() {
								goto l54
							}
							goto l53
						l54:
							position, tokenIndex = position53, tokenIndex53
							if !_rules[rulememberNameShorthand]() {
								goto l51
							}
						}
					l53:
						{
							add(ruleAction6, position)
						}
						add(ruledescendantSegment, position52)
					}
					goto l50
				l51:
					position, tokenIndex = position50, tokenIndex50
					{
						position56 := position
						{
							position57, tokenIndex57 := position, tokenIndex
							{
								position59 := position
								if buffer[position] != '.' {
									goto l58
								}
								position++
								if !_rules[rulememberNameShorthand]() {
									goto l58
								}
								add(rulePegText, position59)
							}
							{
								add(ruleAction7, position)
							}
							goto l57
						l58:
							position, tokenIndex = position57, tokenIndex57
							if !_rules[rulebracketedSelection]() {
								goto l48
							}
						}
					l57:
						add(rulechildSegment, position56)
					}
				}
			l50:
				add(rulesegment, position49)
			}
			memoize(10, position48, tokenIndex48, true)
			return true
		l48:
			memoize(10, position48, tokenIndex48, false)
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 11 descendantSegment <- <('.' '.' (bracketedSelection / memberNameShorthand) Action6)> */
		nil,
		/* 12 childSegment <- <((<('.' memberNameShorthand)> Action7) / bracketedSelection)> */
		nil,
		/* 13 bracketedSelection <- <(<(squareBracketStart selectors squareBracketEnd)> Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position63, tokenIndex63 := position, tokenIndex
			{
				position64 := position
				{
					position65 := position
					{
						position66 := position
						if buffer[position] != '[' {
							goto l63
						}
						position++
						_rules[rulespace]()
						add(rulesquareBracketStart, position66)
					}
					{
						position67 := position
						{
							position68, tokenIndex68 := position, tokenIndex
							{
								position70 := position
								if !_rules[ruleobjectElementSelector]() {
									goto l69
								}
							l71:
								{
									position72, tokenIndex72 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l72
									}
									if !_rules[ruleobjectElementSelector]() {
										goto l72
									}
									{
										add(ruleAction12, position)
									}
									goto l71
								l72:
									position, tokenIndex = position72, tokenIndex72
								}
								{
									position74, tokenIndex74 := position, tokenIndex
									if !_rules[rulesep]() {
										goto l74
									}
									goto l69
								l74:
									position, tokenIndex = position74, tokenIndex74
								}
								add(ruleobjectElementSelectors, position70)
							}
							goto l68
						l69:
							position, tokenIndex = position68, tokenIndex68
							{
								switch buffer[position] {
								case '(':
									{
										position76 := position
										{
											position77 := position
											position++
											_rules[rulespace]()
											add(rulescriptSelectorStart, position77)
										}
										{
											position78 := position
											{
												position79 := position
												{
													position82, tokenIndex82 := position, tokenIndex
													if !_rules[rulescriptSelectorEnd]() {
														goto l82
													}
													goto l63
												l82:
													position, tokenIndex = position82, tokenIndex82
												}
												if !matchDot() {
													goto l63
												}
											l80:
												{
													position81, tokenIndex81 := position, tokenIndex
													{
														position83, tokenIndex83 := position, tokenIndex
														if !_rules[rulescriptSelectorEnd]() {
															goto l83
														}
														goto l81
													l83:
														position, tokenIndex = position83, tokenIndex83
													}
													if !matchDot() {
														goto l81
													}
													goto l80
												l81:
													position, tokenIndex = position81, tokenIndex81
												}
												add(rulecommand, position79)
											}
											add(rulePegText, position78)
										}
										if !_rules[rulescriptSelectorEnd]() {
											goto l63
										}
										{
											add(ruleAction21, position)
										}
										add(rulescriptSelector, position76)
									}
								case '?':
									{
										position85 := position
										{
											position86 := position
											position++
											if buffer[position] != '(' {
												goto l63
											}
											position++
											_rules[rulespace]()
											add(rulefilterSelectorStart, position86)
										}
										if !_rules[rulequery]() {
											goto l63
										}
										{
											position87 := position
											_rules[rulespace]()
											if buffer[position] != ')' {
												goto l63
											}
											position++
											add(rulefilterSelectorEnd, position87)
										}
										{
											add(ruleAction22, position)
										}
										add(rulefilterSelector, position85)
									}
								default:
									{
										position89 := position
										if !_rules[rulearrayElementSelector]() {
											goto l63
										}
									l90:
										{
											position91, tokenIndex91 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l91
											}
											if !_rules[rulearrayElementSelector]() {
												goto l91
											}
											{
												add(ruleAction15, position)
											}
											goto l90
										l91:
											position, tokenIndex = position91, tokenIndex91
										}
										{
											position93, tokenIndex93 := position, tokenIndex
											if !_rules[rulesep]() {
												goto l93
											}
											goto l63
										l93:
											position, tokenIndex = position93, tokenIndex93
										}
										add(rulearrayElementSelectors, position89)
									}
								}
							}

						}
					l68:
						add(ruleselectors, position67)
					}
					{
						position94 := position
						_rules[rulespace]()
						if buffer[position] != ']' {
							goto l63
						}
						position++
						add(rulesquareBracketEnd, position94)
					}
					add(rulePegText, position65)
				}
				{
					add(ruleAction8, position)
				}
				add(rulebracketedSelection, position64)
			}
			memoize(13, position63, tokenIndex63, true)
			return true
		l63:
			memoize(13, position63, tokenIndex63, false)
			position, tokenIndex = position63, tokenIndex63
			return false
		},
		/* 14 function <- <(<('.' functionName ('(' ')'))> Action9)> */
		nil,
		/* 15 functionName <- <(<nameChars+> Action10)> */
		nil,
		/* 16 memberNameShorthand <- <(wildcardSelector / (<(('\\' signsWithoutHyphenUnderscore) / (!(controlCodeChars / signsWithoutHyphenUnderscore) .))+> !('(' ')') Action11))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position98, tokenIndex98 := position, tokenIndex
			{
				position99 := position
				{
					position100, tokenIndex100 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l101
					}
					goto l100
				l101:
					position, tokenIndex = position100, tokenIndex100
					{
						position102 := position
						{
							position105, tokenIndex105 := position, tokenIndex
							if buffer[position] != '\\' {
								goto l106
							}
							position++
							if !_rules[rulesignsWithoutHyphenUnderscore]() {
								goto l106
							}
							goto l105
						l106:
							position, tokenIndex = position105, tokenIndex105
							{
								position107, tokenIndex107 := position, tokenIndex
								{
									position108, tokenIndex108 := position, tokenIndex
									{
										position110 := position
										{
											position111, tokenIndex111 := position, tokenIndex
											if c := buffer[position]; c < '\x00' || c > '\x1f' {
												goto l112
											}
											position++
											goto l111
										l112:
											position, tokenIndex = position111, tokenIndex111
											if buffer[position] != '\x7f' {
												goto l109
											}
											position++
										}
									l111:
										add(rulecontrolCodeChars, position110)
									}
									goto l108
								l109:
									position, tokenIndex = position108, tokenIndex108
									if !_rules[rulesignsWithoutHyphenUnderscore]() {
										goto l107
									}
								}
							l108:
								goto l98
							l107:
								position, tokenIndex = position107, tokenIndex107
							}
							if !matchDot() {
								goto l98
							}
						}
					l105:
					l103:
						{
							position104, tokenIndex104 := position, tokenIndex
							{
								position113, tokenIndex113 := position, tokenIndex
								if buffer[position] != '\\' {
									goto l114
								}
								position++
								if !_rules[rulesignsWithoutHyphenUnderscore]() {
									goto l114
								}
								goto l113
							l114:
								position, tokenIndex = position113, tokenIndex113
								{
									position115, tokenIndex115 := position, tokenIndex
									{
										position116, tokenIndex116 := position, tokenIndex
										{
											position118 := position
											{
												position119, tokenIndex119 := position, tokenIndex
												if c := buffer[position]; c < '\x00' || c > '\x1f' {
													goto l120
												}
												position++
												goto l119
											l120:
												position, tokenIndex = position119, tokenIndex119
												if buffer[position] != '\x7f' {
													goto l117
												}
												position++
											}
										l119:
											add(rulecontrolCodeChars, position118)
										}
										goto l116
									l117:
										position, tokenIndex = position116, tokenIndex116
										if !_rules[rulesignsWithoutHyphenUnderscore]() {
											goto l115
										}
									}
								l116:
									goto l104
								l115:
									position, tokenIndex = position115, tokenIndex115
								}
								if !matchDot() {
									goto l104
								}
							}
						l113:
							goto l103
						l104:
							position, tokenIndex = position104, tokenIndex104
						}
						add(rulePegText, position102)
					}
					{
						position121, tokenIndex121 := position, tokenIndex
						if buffer[position] != '(' {
							goto l121
						}
						position++
						if buffer[position] != ')' {
							goto l121
						}
						position++
						goto l98
					l121:
						position, tokenIndex = position121, tokenIndex121
					}
					{
						add(ruleAction11, position)
					}
				}
			l100:
				add(rulememberNameShorthand, position99)
			}
			memoize(16, position98, tokenIndex98, true)
			return true
		l98:
			memoize(16, position98, tokenIndex98, false)
			position, tokenIndex = position98, tokenIndex98
			return false
		},
		/* 17 nameChars <- <((&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				{
					switch buffer[position] {
					case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
						position++
					case '_':
						position++
					case '-':
						position++
					default:
						if c := buffer[position]; c < 'a' || c > 'z' {
							goto l123
						}
						position++
					}
				}

				add(rulenameChars, position124)
			}
			memoize(17, position123, tokenIndex123, true)
			return true
		l123:
			memoize(17, position123, tokenIndex123, false)
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 18 signsWithoutHyphenUnderscore <- <(!nameChars [ -~])> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{18, position}]; ok {
				return memoizedResult(memoized)
			}
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				{
					position128, tokenIndex128 := position, tokenIndex
					if !_rules[rulenameChars]() {
						goto l128
					}
					goto l126
				l128:
					position, tokenIndex = position128, tokenIndex128
				}
				if c := buffer[position]; c < ' ' || c > '~' {
					goto l126
				}
				position++
				add(rulesignsWithoutHyphenUnderscore, position127)
			}
			memoize(18, position126, tokenIndex126, true)
			return true
		l126:
			memoize(18, position126, tokenIndex126, false)
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 19 controlCodeChars <- <([\x00-\x1f] / '\x7f')> */
		nil,
		/* 20 selectors <- <(objectElementSelectors / ((&('(') scriptSelector) | (&('?') filterSelector) | (&(' ' | '*' | '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':') arrayElementSelectors)))> */
		nil,
		/* 21 objectElementSelectors <- <(objectElementSelector (sep objectElementSelector Action12)* !sep)> */
		nil,
		/* 22 objectElementSelector <- <(wildcardSelector / nameSelector)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{22, position}]; ok {
				return memoizedResult(memoized)
			}
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				{
					position134, tokenIndex134 := position, tokenIndex
					if !_rules[rulewildcardSelector]() {
						goto l135
					}
					goto l134
				l135:
					position, tokenIndex = position134, tokenIndex134
					{
						position136 := position
						if !_rules[rulelString]() {
							goto l132
						}
						{
							add(ruleAction14, position)
						}
						add(rulenameSelector, position136)
					}
				}
			l134:
				add(ruleobjectElementSelector, position133)
			}
			memoize(22, position132, tokenIndex132, true)
			return true
		l132:
			memoize(22, position132, tokenIndex132, false)
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 23 wildcardSelector <- <('*' Action13)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{23, position}]; ok {
				return memoizedResult(memoized)
			}
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				if buffer[position] != '*' {
					goto l138
				}
				position++
				{
					add(ruleAction13, position)
				}
				add(rulewildcardSelector, position139)
			}
			memoize(23, position138, tokenIndex138, true)
			return true
		l138:
			memoize(23, position138, tokenIndex138, false)
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 24 nameSelector <- <(lString Action14)> */
		nil,
		/* 25 arrayElementSelectors <- <(arrayElementSelector (sep arrayElementSelector Action15)* !sep)> */
		nil,
		/* 26 arrayElementSelector <- <(((arraySliceSelector Action16) / indexSelector / ('*' Action17)) Action18)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				{
					position145, tokenIndex145 := position, tokenIndex
					{
						position147 := position
						_rules[ruleanyIndex]()
						if !_rules[rulesepArraySlice]() {
							goto l146
						}
						_rules[ruleanyIndex]()
						{
							position148, tokenIndex148 := position, tokenIndex
							if !_rules[rulesepArraySlice]() {
								goto l149
							}
							_rules[ruleanyIndex]()
							goto l148
						l149:
							position, tokenIndex = position148, tokenIndex148
							_rules[ruleomittedIndex]()
						}
					l148:
						add(rulearraySliceSelector, position147)
					}
					{
						add(ruleAction16, position)
					}
					goto l145
				l146:
					position, tokenIndex = position145, tokenIndex145
					{
						position152 := position
						if !_rules[ruleindexNumber]() {
							goto l151
						}
						add(ruleindexSelector, position152)
					}
					goto l145
				l151:
					position, tokenIndex = position145, tokenIndex145
					if buffer[position] != '*' {
						goto l143
					}
					position++
					{
						add(ruleAction17, position)
					}
				}
			l145:
				{
					add(ruleAction18, position)
				}
				add(rulearrayElementSelector, position144)
			}
			memoize(26, position143, tokenIndex143, true)
			return true
		l143:
			memoize(26, position143, tokenIndex143, false)
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 27 arraySliceSelector <- <(anyIndex sepArraySlice anyIndex ((sepArraySlice anyIndex) / omittedIndex))> */
		nil,
		/* 28 anyIndex <- <(indexNumber / omittedIndex)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position156, tokenIndex156 := position, tokenIndex
			{
				position157 := position
				{
					position158, tokenIndex158 := position, tokenIndex
					if !_rules[ruleindexNumber]() {
						goto l159
					}
					goto l158
				l159:
					position, tokenIndex = position158, tokenIndex158
					_rules[ruleomittedIndex]()
				}
			l158:
				add(ruleanyIndex, position157)
			}
			memoize(28, position156, tokenIndex156, true)
			return true
		},
		/* 29 omittedIndex <- <Action19> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				{
					add(ruleAction19, position)
				}
				add(ruleomittedIndex, position161)
			}
			memoize(29, position160, tokenIndex160, true)
			return true
		},
		/* 30 indexSelector <- <indexNumber> */
		nil,
		/* 31 indexNumber <- <(<(('-' / '+')? [0-9]+)> Action20)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{31, position}]; ok {
				return memoizedResult(memoized)
			}
			position164, tokenIndex164 := position, tokenIndex
			{
				position165 := position
				{
					position166 := position
					{
						position167, tokenIndex167 := position, tokenIndex
						{
							position169, tokenIndex169 := position, tokenIndex
							if buffer[position] != '-' {
								goto l170
							}
							position++
							goto l169
						l170:
							position, tokenIndex = position169, tokenIndex169
							if buffer[position] != '+' {
								goto l167
							}
							position++
						}
					l169:
						goto l168
					l167:
						position, tokenIndex = position167, tokenIndex167
					}
				l168:
					if c := buffer[position]; c < '0' || c > '9' {
						goto l164
					}
					position++
				l171:
					{
						position172, tokenIndex172 := position, tokenIndex
						if c := buffer[position]; c < '0' || c > '9' {
							goto l172
						}
						position++
						goto l171
					l172:
						position, tokenIndex = position172, tokenIndex172
					}
					add(rulePegText, position166)
				}
				{
					add(ruleAction20, position)
				}
				add(ruleindexNumber, position165)
			}
			memoize(31, position164, tokenIndex164, true)
			return true
		l164:
			memoize(31, position164, tokenIndex164, false)
			position, tokenIndex = position164, tokenIndex164
			return false
		},
		/* 32 sep <- <(space ',' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{32, position}]; ok {
				return memoizedResult(memoized)
			}
			position174, tokenIndex174 := position, tokenIndex
			{
				position175 := position
				_rules[rulespace]()
				if buffer[position] != ',' {
					goto l174
				}
				position++
				_rules[rulespace]()
				add(rulesep, position175)
			}
			memoize(32, position174, tokenIndex174, true)
			return true
		l174:
			memoize(32, position174, tokenIndex174, false)
			position, tokenIndex = position174, tokenIndex174
			return false
		},
		/* 33 sepArraySlice <- <(space ':' space)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				_rules[rulespace]()
				if buffer[position] != ':' {
					goto l176
				}
				position++
				_rules[rulespace]()
				add(rulesepArraySlice, position177)
			}
			memoize(33, position176, tokenIndex176, true)
			return true
		l176:
			memoize(33, position176, tokenIndex176, false)
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 34 scriptSelector <- <(scriptSelectorStart <command> scriptSelectorEnd Action21)> */
		nil,
		/* 35 command <- <(!scriptSelectorEnd .)+> */
		nil,
		/* 36 filterSelector <- <(filterSelectorStart query filterSelectorEnd Action22)> */
		nil,
		/* 37 query <- <(andQuery (logicOr andQuery Action23)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{37, position}]; ok {
				return memoizedResult(memoized)
			}
			position181, tokenIndex181 := position, tokenIndex
			{
				position182 := position
				if !_rules[ruleandQuery]() {
					goto l181
				}
			l183:
				{
					position184, tokenIndex184 := position, tokenIndex
					{
						position185 := position
						_rules[rulespace]()
						if buffer[position] != '|' {
							goto l184
						}
						position++
						if buffer[position] != '|' {
							goto l184
						}
						position++
						_rules[rulespace]()
						add(rulelogicOr, position185)
					}
					if !_rules[ruleandQuery]() {
						goto l184
					}
					{
						add(ruleAction23, position)
					}
					goto l183
				l184:
					position, tokenIndex = position184, tokenIndex184
				}
				add(rulequery, position182)
			}
			memoize(37, position181, tokenIndex181, true)
			return true
		l181:
			memoize(37, position181, tokenIndex181, false)
			position, tokenIndex = position181, tokenIndex181
			return false
		},
		/* 38 andQuery <- <(basicQuery (logicAnd basicQuery Action24)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{38, position}]; ok {
				return memoizedResult(memoized)
			}
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				if !_rules[rulebasicQuery]() {
					goto l187
				}
			l189:
				{
					position190, tokenIndex190 := position, tokenIndex
					{
						position191 := position
						_rules[rulespace]()
						if buffer[position] != '&' {
							goto l190
						}
						position++
						if buffer[position] != '&' {
							goto l190
						}
						position++
						_rules[rulespace]()
						add(rulelogicAnd, position191)
					}
					if !_rules[rulebasicQuery]() {
						goto l190
					}
					{
						add(ruleAction24, position)
					}
					goto l189
				l190:
					position, tokenIndex = position190, tokenIndex190
				}
				add(ruleandQuery, position188)
			}
			memoize(38, position187, tokenIndex187, true)
			return true
		l187:
			memoize(38, position187, tokenIndex187, false)
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 39 basicQuery <- <((subQueryStart query subQueryEnd) / (<comparator> Action25) / ((logicNot jsonpathFilter Action26) / (jsonpathFilter Action27)))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				{
					position195, tokenIndex195 := position, tokenIndex
					{
						position197 := position
						if buffer[position] != '(' {
							goto l196
						}
						position++
						_rules[rulespace]()
						add(rulesubQueryStart, position197)
					}
					if !_rules[rulequery]() {
						goto l196
					}
					{
						position198 := position
						_rules[rulespace]()
						if buffer[position] != ')' {
							goto l196
						}
						position++
						add(rulesubQueryEnd, position198)
					}
					goto l195
				l196:
					position, tokenIndex = position195, tokenIndex195
					{
						position200 := position
						{
							position201 := position
							{
								position202, tokenIndex202 := position, tokenIndex
								if !_rules[ruleqParam]() {
									goto l203
								}
								_rules[rulespace]()
								{
									position204, tokenIndex204 := position, tokenIndex
									if buffer[position] != '=' {
										goto l205
									}
									position++
									if buffer[position] != '=' {
										goto l205
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqParam]() {
										goto l205
									}
									{
										add(ruleAction28, position)
									}
									goto l204
								l205:
									position, tokenIndex = position204, tokenIndex204
									if buffer[position] != '!' {
										goto l203
									}
									position++
									if buffer[position] != '=' {
										goto l203
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqParam]() {
										goto l203
									}
									{
										add(ruleAction29, position)
									}
								}
							l204:
								goto l202
							l203:
								position, tokenIndex = position202, tokenIndex202
								if !_rules[ruleqNumericParam]() {
									goto l208
								}
								_rules[rulespace]()
								{
									position209, tokenIndex209 := position, tokenIndex
									if buffer[position] != '<' {
										goto l210
									}
									position++
									if buffer[position] != '=' {
										goto l210
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l210
									}
									{
										add(ruleAction30, position)
									}
									goto l209
								l210:
									position, tokenIndex = position209, tokenIndex209
									if buffer[position] != '<' {
										goto l212
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l212
									}
									{
										add(ruleAction31, position)
									}
									goto l209
								l212:
									position, tokenIndex = position209, tokenIndex209
									if buffer[position] != '>' {
										goto l214
									}
									position++
									if buffer[position] != '=' {
										goto l214
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l214
									}
									{
										add(ruleAction32, position)
									}
									goto l209
								l214:
									position, tokenIndex = position209, tokenIndex209
									if buffer[position] != '>' {
										goto l208
									}
									position++
									_rules[rulespace]()
									if !_rules[ruleqNumericParam]() {
										goto l208
									}
									{
										add(ruleAction33, position)
									}
								}
							l209:
								goto l202
							l208:
								position, tokenIndex = position202, tokenIndex202
								if !_rules[rulesingleJsonpathFilter]() {
									goto l199
								}
								_rules[rulespace]()
								if buffer[position] != '=' {
									goto l199
								}
								position++
								if buffer[position] != '~' {
									goto l199
								}
								position++
								_rules[rulespace]()
								if buffer[position] != '/' {
									goto l199
								}
								position++
								{
									position217 := position
									{
										position218 := position
									l219:
										{
											position220, tokenIndex220 := position, tokenIndex
											{
												position221, tokenIndex221 := position, tokenIndex
												{
													position223, tokenIndex223 := position, tokenIndex
													{
														position224, tokenIndex224 := position, tokenIndex
														if buffer[position] != '/' {
															goto l225
														}
														position++
														goto l224
													l225:
														position, tokenIndex = position224, tokenIndex224
														if buffer[position] != '\\' {
															goto l223
														}
														position++
													}
												l224:
													goto l222
												l223:
													position, tokenIndex = position223, tokenIndex223
												}
												if !matchDot() {
													goto l222
												}
												goto l221
											l222:
												position, tokenIndex = position221, tokenIndex221
												if buffer[position] != '\\' {
													goto l220
												}
												position++
												if !matchDot() {
													goto l220
												}
											}
										l221:
											goto l219
										l220:
											position, tokenIndex = position220, tokenIndex220
										}
										add(ruleregex, position218)
									}
									add(rulePegText, position217)
								}
								if buffer[position] != '/' {
									goto l199
								}
								position++
								{
									add(ruleAction34, position)
								}
							}
						l202:
							add(rulecomparator, position201)
						}
						add(rulePegText, position200)
					}
					{
						add(ruleAction25, position)
					}
					goto l195
				l199:
					position, tokenIndex = position195, tokenIndex195
					{
						position228, tokenIndex228 := position, tokenIndex
						{
							position230 := position
							if buffer[position] != '!' {
								goto l229
							}
							position++
							_rules[rulespace]()
							add(rulelogicNot, position230)
						}
						if !_rules[rulejsonpathFilter]() {
							goto l229
						}
						{
							add(ruleAction26, position)
						}
						goto l228
					l229:
						position, tokenIndex = position228, tokenIndex228
						if !_rules[rulejsonpathFilter]() {
							goto l193
						}
						{
							add(ruleAction27, position)
						}
					}
				l228:
				}
			l195:
				add(rulebasicQuery, position194)
			}
			memoize(39, position193, tokenIndex193, true)
			return true
		l193:
			memoize(39, position193, tokenIndex193, false)
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 40 logicOr <- <(space ('|' '|') space)> */
		nil,
		/* 41 logicAnd <- <(space ('&' '&') space)> */
		nil,
		/* 42 logicNot <- <('!' space)> */
		nil,
		/* 43 comparator <- <((qParam space (('=' '=' space qParam Action28) / ('!' '=' space qParam Action29))) / (qNumericParam space (('<' '=' space qNumericParam Action30) / ('<' space qNumericParam Action31) / ('>' '=' space qNumericParam Action32) / ('>' space qNumericParam Action33))) / (singleJsonpathFilter space ('=' '~') space '/' <regex> '/' Action34))> */
		nil,
		/* 44 qParam <- <((qLiteral Action35) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position237, tokenIndex237 := position, tokenIndex
			{
				position238 := position
				{
					position239, tokenIndex239 := position, tokenIndex
					{
						position241 := position
						{
							switch buffer[position] {
							case 'N', 'n':
								{
									position243 := position
									{
										position244, tokenIndex244 := position, tokenIndex
										if buffer[position] != 'n' {
											goto l245
										}
										position++
										if buffer[position] != 'u' {
											goto l245
										}
										position++
										if buffer[position] != 'l' {
											goto l245
										}
										position++
										if buffer[position] != 'l' {
											goto l245
										}
										position++
										goto l244
									l245:
										position, tokenIndex = position244, tokenIndex244
										if buffer[position] != 'N' {
											goto l246
										}
										position++
										if buffer[position] != 'u' {
											goto l246
										}
										position++
										if buffer[position] != 'l' {
											goto l246
										}
										position++
										if buffer[position] != 'l' {
											goto l246
										}
										position++
										goto l244
									l246:
										position, tokenIndex = position244, tokenIndex244
										if buffer[position] != 'N' {
											goto l240
										}
										position++
										if buffer[position] != 'U' {
											goto l240
										}
										position++
										if buffer[position] != 'L' {
											goto l240
										}
										position++
										if buffer[position] != 'L' {
											goto l240
										}
										position++
									}
								l244:
									{
										add(ruleAction45, position)
									}
									add(rulelNull, position243)
								}
							case '"', '\'':
								if !_rules[rulelString]() {
									goto l240
								}
							case 'F', 'T', 'f', 't':
								{
									position248 := position
									{
										position249, tokenIndex249 := position, tokenIndex
										{
											position251, tokenIndex251 := position, tokenIndex
											if buffer[position] != 't' {
												goto l252
											}
											position++
											if buffer[position] != 'r' {
												goto l252
											}
											position++
											if buffer[position] != 'u' {
												goto l252
											}
											position++
											if buffer[position] != 'e' {
												goto l252
											}
											position++
											goto l251
										l252:
											position, tokenIndex = position251, tokenIndex251
											if buffer[position] != 'T' {
												goto l253
											}
											position++
											if buffer[position] != 'r' {
												goto l253
											}
											position++
											if buffer[position] != 'u' {
												goto l253
											}
											position++
											if buffer[position] != 'e' {
												goto l253
											}
											position++
											goto l251
										l253:
											position, tokenIndex = position251, tokenIndex251
											if buffer[position] != 'T' {
												goto l250
											}
											position++
											if buffer[position] != 'R' {
												goto l250
											}
											position++
											if buffer[position] != 'U' {
												goto l250
											}
											position++
											if buffer[position] != 'E' {
												goto l250
											}
											position++
										}
									l251:
										{
											add(ruleAction41, position)
										}
										goto l249
									l250:
										position, tokenIndex = position249, tokenIndex249
										{
											position255, tokenIndex255 := position, tokenIndex
											if buffer[position] != 'f' {
												goto l256
											}
											position++
											if buffer[position] != 'a' {
												goto l256
											}
											position++
											if buffer[position] != 'l' {
												goto l256
											}
											position++
											if buffer[position] != 's' {
												goto l256
											}
											position++
											if buffer[position] != 'e' {
												goto l256
											}
											position++
											goto l255
										l256:
											position, tokenIndex = position255, tokenIndex255
											if buffer[position] != 'F' {
												goto l257
											}
											position++
											if buffer[position] != 'a' {
												goto l257
											}
											position++
											if buffer[position] != 'l' {
												goto l257
											}
											position++
											if buffer[position] != 's' {
												goto l257
											}
											position++
											if buffer[position] != 'e' {
												goto l257
											}
											position++
											goto l255
										l257:
											position, tokenIndex = position255, tokenIndex255
											if buffer[position] != 'F' {
												goto l240
											}
											position++
											if buffer[position] != 'A' {
												goto l240
											}
											position++
											if buffer[position] != 'L' {
												goto l240
											}
											position++
											if buffer[position] != 'S' {
												goto l240
											}
											position++
											if buffer[position] != 'E' {
												goto l240
											}
											position++
										}
									l255:
										{
											add(ruleAction42, position)
										}
									}
								l249:
									add(rulelBool, position248)
								}
							default:
								if !_rules[rulelNumber]() {
									goto l240
								}
							}
						}

						add(ruleqLiteral, position241)
					}
					{
						add(ruleAction35, position)
					}
					goto l239
				l240:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[rulesingleJsonpathFilter]() {
						goto l237
					}
				}
			l239:
				add(ruleqParam, position238)
			}
			memoize(44, position237, tokenIndex237, true)
			return true
		l237:
			memoize(44, position237, tokenIndex237, false)
			position, tokenIndex = position237, tokenIndex237
			return false
		},
		/* 45 qNumericParam <- <((lNumber Action36) / singleJsonpathFilter)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position260, tokenIndex260 := position, tokenIndex
			{
				position261 := position
				{
					position262, tokenIndex262 := position, tokenIndex
					if !_rules[rulelNumber]() {
						goto l263
					}
					{
						add(ruleAction36, position)
					}
					goto l262
				l263:
					position, tokenIndex = position262, tokenIndex262
					if !_rules[rulesingleJsonpathFilter]() {
						goto l260
					}
				}
			l262:
				add(ruleqNumericParam, position261)
			}
			memoize(45, position260, tokenIndex260, true)
			return true
		l260:
			memoize(45, position260, tokenIndex260, false)
			position, tokenIndex = position260, tokenIndex260
			return false
		},
		/* 46 qLiteral <- <((&('N' | 'n') lNull) | (&('"' | '\'') lString) | (&('F' | 'T' | 'f' | 't') lBool) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') lNumber))> */
		nil,
		/* 47 singleJsonpathFilter <- <(<jsonpathFilter> Action37)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{47, position}]; ok {
				return memoizedResult(memoized)
			}
			position266, tokenIndex266 := position, tokenIndex
			{
				position267 := position
				{
					position268 := position
					if !_rules[rulejsonpathFilter]() {
						goto l266
					}
					add(rulePegText, position268)
				}
				{
					add(ruleAction37, position)
				}
				add(rulesingleJsonpathFilter, position267)
			}
			memoize(47, position266, tokenIndex266, true)
			return true
		l266:
			memoize(47, position266, tokenIndex266, false)
			position, tokenIndex = position266, tokenIndex266
			return false
		},
		/* 48 jsonpathFilter <- <(Action38 jsonpathParameter Action39)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{48, position}]; ok {
				return memoizedResult(memoized)
			}
			position270, tokenIndex270 := position, tokenIndex
			{
				position271 := position
				{
					add(ruleAction38, position)
				}
				{
					position273 := position
					_rules[rulespace]()
					{
						position274 := position
						{
							position275, tokenIndex275 := position, tokenIndex
							if !_rules[rulerootIdentifier]() {
								goto l276
							}
							goto l275
						l276:
							position, tokenIndex = position275, tokenIndex275
							{
								position277 := position
								if buffer[position] != '@' {
									goto l270
								}
								position++
								{
									add(ruleAction4, position)
								}
								add(rulecurrentNodeIdentifier, position277)
							}
						}
					l275:
						add(ruleparameterRootNode, position274)
					}
					_rules[rulesegments]()
					add(rulejsonpathParameter, position273)
				}
				{
					add(ruleAction39, position)
				}
				add(rulejsonpathFilter, position271)
			}
			memoize(48, position270, tokenIndex270, true)
			return true
		l270:
			memoize(48, position270, tokenIndex270, false)
			position, tokenIndex = position270, tokenIndex270
			return false
		},
		/* 49 lNumber <- <(<(('-' / '+')? [0-9] ((&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('.') '.') | (&('+') '+') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action40)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position280, tokenIndex280 := position, tokenIndex
			{
				position281 := position
				{
					position282 := position
					{
						position283, tokenIndex283 := position, tokenIndex
						{
							position285, tokenIndex285 := position, tokenIndex
							if buffer[position] != '-' {
								goto l286
							}
							position++
							goto l285
						l286:
							position, tokenIndex = position285, tokenIndex285
							if buffer[position] != '+' {
								goto l283
							}
							position++
						}
					l285:
						goto l284
					l283:
						position, tokenIndex = position283, tokenIndex283
					}
				l284:
					if c := buffer[position]; c < '0' || c > '9' {
						goto l280
					}
					position++
				l287:
					{
						position288, tokenIndex288 := position, tokenIndex
						{
							switch buffer[position] {
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								position++
							case '.':
								position++
							case '+':
								position++
							case '-':
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								position++
							default:
								if c := buffer[position]; c < 'a' || c > 'z' {
									goto l288
								}
								position++
							}
						}

						goto l287
					l288:
						position, tokenIndex = position288, tokenIndex288
					}
					add(rulePegText, position282)
				}
				{
					add(ruleAction40, position)
				}
				add(rulelNumber, position281)
			}
			memoize(49, position280, tokenIndex280, true)
			return true
		l280:
			memoize(49, position280, tokenIndex280, false)
			position, tokenIndex = position280, tokenIndex280
			return false
		},
		/* 50 lBool <- <(((('t' 'r' 'u' 'e') / ('T' 'r' 'u' 'e') / ('T' 'R' 'U' 'E')) Action41) / ((('f' 'a' 'l' 's' 'e') / ('F' 'a' 'l' 's' 'e') / ('F' 'A' 'L' 'S' 'E')) Action42))> */
		nil,
		/* 51 lString <- <(('\'' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('\'') '\''))) / (!('\'' / '\\') .))*> '\'' Action43) / ('"' <(('\\' ((&('u') hexDigits) | (&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('\\') '\\') | (&('/') '/') | (&('"') '"'))) / (!('"' / '\\') .))*> '"' Action44))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{51, position}]; ok {
				return memoizedResult(memoized)
			}
			position292, tokenIndex292 := position, tokenIndex
			{
				position293 := position
				{
					position294, tokenIndex294 := position, tokenIndex
					if buffer[position] != '\'' {
						goto l295
					}
					position++
					{
						position296 := position
					l297:
						{
							position298, tokenIndex298 := position, tokenIndex
							{
								position299, tokenIndex299 := position, tokenIndex
								if buffer[position] != '\\' {
									goto l300
								}
								position++
								{
									switch buffer[position] {
									case 'u':
										if !_rules[rulehexDigits]() {
											goto l300
										}
									case 't':
										position++
									case 'r':
										position++
									case 'n':
										position++
									case 'f':
										position++
									case 'b':
										position++
									case '\\':
										position++
									case '/':
										position++
									default:
										if buffer[position] != '\'' {
											goto l300
										}
										position++
									}
								}

								goto l299
							l300:
								position, tokenIndex = position299, tokenIndex299
								{
									position302, tokenIndex302 := position, tokenIndex
									{
										position303, tokenIndex303 := position, tokenIndex
										if buffer[position] != '\'' {
											goto l304
										}
										position++
										goto l303
									l304:
										position, tokenIndex = position303, tokenIndex303
										if buffer[position] != '\\' {
											goto l302
										}
										position++
									}
								l303:
									goto l298
								l302:
									position, tokenIndex = position302, tokenIndex302
								}
								if !matchDot() {
									goto l298
								}
							}
						l299:
							goto l297
						l298:
							position, tokenIndex = position298, tokenIndex298
						}
						add(rulePegText, position296)
					}
					if buffer[position] != '\'' {
						goto l295
					}
					position++
					{
						add(ruleAction43, position)
					}
					goto l294
				l295:
					position, tokenIndex = position294, tokenIndex294
					if buffer[position] != '"' {
						goto l292
					}
					position++
					{
						position306 := position
					l307:
						{
							position308, tokenIndex308 := position, tokenIndex
							{
								position309, tokenIndex309 := position, tokenIndex
								if buffer[position] != '\\' {
									goto l310
								}
								position++
								{
									switch buffer[position] {
									case 'u':
										if !_rules[rulehexDigits]() {
											goto l310
										}
									case 't':
										position++
									case 'r':
										position++
									case 'n':
										position++
									case 'f':
										position++
									case 'b':
										position++
									case '\\':
										position++
									case '/':
										position++
									default:
										if buffer[position] != '"' {
											goto l310
										}
										position++
									}
								}

								goto l309
							l310:
								position, tokenIndex = position309, tokenIndex309
								{
									position312, tokenIndex312 := position, tokenIndex
									{
										position313, tokenIndex313 := position, tokenIndex
										if buffer[position] != '"' {
											goto l314
										}
										position++
										goto l313
									l314:
										position, tokenIndex = position313, tokenIndex313
										if buffer[position] != '\\' {
											goto l312
										}
										position++
									}
								l313:
									goto l308
								l312:
									position, tokenIndex = position312, tokenIndex312
								}
								if !matchDot() {
									goto l308
								}
							}
						l309:
							goto l307
						l308:
							position, tokenIndex = position308, tokenIndex308
						}
						add(rulePegText, position306)
					}
					if buffer[position] != '"' {
						goto l292
					}
					position++
					{
						add(ruleAction44, position)
					}
				}
			l294:
				add(rulelString, position293)
			}
			memoize(51, position292, tokenIndex292, true)
			return true
		l292:
			memoize(51, position292, tokenIndex292, false)
			position, tokenIndex = position292, tokenIndex292
			return false
		},
		/* 52 hexDigits <- <('u' hexDigit hexDigit hexDigit hexDigit)> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{52, position}]; ok {
				return memoizedResult(memoized)
			}
			position316, tokenIndex316 := position, tokenIndex
			{
				position317 := position
				if buffer[position] != 'u' {
					goto l316
				}
				position++
				if !_rules[rulehexDigit]() {
					goto l316
				}
				if !_rules[rulehexDigit]() {
					goto l316
				}
				if !_rules[rulehexDigit]() {
					goto l316
				}
				if !_rules[rulehexDigit]() {
					goto l316
				}
				add(rulehexDigits, position317)
			}
			memoize(52, position316, tokenIndex316, true)
			return true
		l316:
			memoize(52, position316, tokenIndex316, false)
			position, tokenIndex = position316, tokenIndex316
			return false
		},
		/* 53 hexDigit <- <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{53, position}]; ok {
				return memoizedResult(memoized)
			}
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				{
					switch buffer[position] {
					case 'A', 'B', 'C', 'D', 'E', 'F':
						position++
					case 'a', 'b', 'c', 'd', 'e', 'f':
						position++
					default:
						if c := buffer[position]; c < '0' || c > '9' {
							goto l318
						}
						position++
					}
				}

				add(rulehexDigit, position319)
			}
			memoize(53, position318, tokenIndex318, true)
			return true
		l318:
			memoize(53, position318, tokenIndex318, false)
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 54 lNull <- <((('n' 'u' 'l' 'l') / ('N' 'u' 'l' 'l') / ('N' 'U' 'L' 'L')) Action45)> */
		nil,
		/* 55 regex <- <((!('/' / '\\') .) / ('\\' .))*> */
		nil,
		/* 56 squareBracketStart <- <('[' space)> */
		nil,
		/* 57 squareBracketEnd <- <(space ']')> */
		nil,
		/* 58 scriptSelectorStart <- <('(' space)> */
		nil,
		/* 59 scriptSelectorEnd <- <(space ')')> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{59, position}]; ok {
				return memoizedResult(memoized)
			}
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				_rules[rulespace]()
				if buffer[position] != ')' {
					goto l326
				}
				position++
				add(rulescriptSelectorEnd, position327)
			}
			memoize(59, position326, tokenIndex326, true)
			return true
		l326:
			memoize(59, position326, tokenIndex326, false)
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 60 filterSelectorStart <- <('?' '(' space)> */
		nil,
		/* 61 filterSelectorEnd <- <(space ')')> */
		nil,
		/* 62 subQueryStart <- <('(' space)> */
		nil,
		/* 63 subQueryEnd <- <(space ')')> */
		nil,
		/* 64 space <- <' '*> */
		func() bool {
			if memoized, ok := memoization[memoKey[U]{64, position}]; ok {
				return memoizedResult(memoized)
			}
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
			l334:
				{
					position335, tokenIndex335 := position, tokenIndex
					if buffer[position] != ' ' {
						goto l335
					}
					position++
					goto l334
				l335:
					position, tokenIndex = position335, tokenIndex335
				}
				add(rulespace, position333)
			}
			memoize(64, position332, tokenIndex332, true)
			return true
		},
		/* 66 Action0 <- <{
		    p.root = p.deleteRootNodeIdentifier(p.pop().(syntaxNode))
		    p.setConnectedPath(p.root)
		}> */
		nil,
		nil,
		/* 68 Action1 <- <{
		    panic(p.syntaxErr(
		        begin, msgErrorInvalidSyntaxUnrecognizedInput, buffer))
		}> */
		nil,
		/* 69 Action2 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 70 Action3 <- <{
		    p.pushRootNodeIdentifier()
		}> */
		nil,
		/* 71 Action4 <- <{
		    p.pushCurrentNodeIdentifier()
		}> */
		nil,
		/* 72 Action5 <- <{
		    p.setNodeChain()
		    p.updateRootValueGroup()
		}> */
		nil,
		/* 73 Action6 <- <{
		    p.pushRecursiveChildIdentifier(p.pop().(syntaxNode))
		}> */
		nil,
		/* 74 Action7 <- <{
		    p.setLastNodePath(text)
		}> */
		nil,
		/* 75 Action8 <- <{
		    p.setLastNodePath(text)
		}> */
		nil,
		/* 76 Action9 <- <{
		    p.pushFunction(text, p.pop().(string))
		}> */
		nil,
		/* 77 Action10 <- <{
		    p.push(text)
		}> */
		nil,
		/* 78 Action11 <- <{
		    p.pushChildSingleIdentifier(p.unescape(text))
		}> */
		nil,
		/* 79 Action12 <- <{
		    identifier2 := p.pop().(syntaxNode)
		    identifier1 := p.pop().(syntaxNode)
		    p.pushChildMultiIdentifier(identifier1, identifier2)
		}> */
		nil,
		/* 80 Action13 <- <{
		    p.pushChildWildcardIdentifier()
		}> */
		nil,
		/* 81 Action14 <- <{
		    p.pushChildSingleIdentifier(p.pop().(string))
		}> */
		nil,
		/* 82 Action15 <- <{
		    childIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion := p.pop().(*syntaxUnionQualifier)
		    parentIndexUnion.merge(childIndexUnion)
		    parentIndexUnion.setValueGroup()
		    p.push(parentIndexUnion)
		}> */
		nil,
		/* 83 Action16 <- <{
		    step  := p.pop().(*syntaxIndexSubscript)
		    end   := p.pop().(*syntaxIndexSubscript)
		    start := p.pop().(*syntaxIndexSubscript)

		    if step.isOmitted {
		        step.number = 1
		    }

		    if step.number >= 0 {
		        p.pushSlicePositiveStepSubscript(start, end, step)
		    } else {
		        p.pushSliceNegativeStepSubscript(start, end, step)
		    }
		}> */
		nil,
		/* 84 Action17 <- <{
		    p.pushWildcardSubscript()
		}> */
		nil,
		/* 85 Action18 <- <{
		    p.pushUnionQualifier(p.pop().(syntaxSubscript))
		}> */
		nil,
		/* 86 Action19 <- <{
		    p.pushOmittedIndexSubscript()
		}> */
		nil,
		/* 87 Action20 <- <{
		    p.pushIndexSubscript(text)
		}> */
		nil,
		/* 88 Action21 <- <{
		    p.pushScriptQualifier(text)
		}> */
		nil,
		/* 89 Action22 <- <{
		    p.pushFilterQualifier(p.pop().(syntaxQuery))
		}> */
		nil,
		/* 90 Action23 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalOr(leftQuery, rightQuery)
		}> */
		nil,
		/* 91 Action24 <- <{
		    rightQuery := p.pop().(syntaxQuery)
		    leftQuery := p.pop().(syntaxQuery)
		    p.pushLogicalAnd(leftQuery, rightQuery)
		}> */
		nil,
		/* 92 Action25 <- <{
		    query := p.pop()
		    p.push(query)

		    if logicalNot, ok := query.(*syntaxLogicalNot); ok {
		        query = (*logicalNot).query
		    }
		    if checkQuery, ok := query.(*syntaxBasicCompareQuery); ok {
		        _, leftIsCurrentNode := checkQuery.leftParam.param.(*syntaxQueryParamCurrentNode)
		        _, rightIsCurrentNode := checkQuery.rightParam.param.(*syntaxQueryParamCurrentNode)
		        if leftIsCurrentNode && rightIsCurrentNode {
		            panic(p.syntaxErr(
		                begin, msgErrorInvalidSyntaxTwoCurrentNode, buffer))
		        }
		    }
		}> */
		nil,
		/* 93 Action26 <- <{
		    _ = p.pop()
		    jsonpathFilter := p.pop().(syntaxQuery)
		    p.pushLogicalNot(jsonpathFilter)
		}> */
		nil,
		/* 94 Action27 <- <{
		    _ = p.pop()
		}> */
		nil,
		/* 95 Action28 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareEQ(leftParam, rightParam)
		}> */
		nil,
		/* 96 Action29 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareNE(leftParam, rightParam)
		}> */
		nil,
		/* 97 Action30 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLE(leftParam, rightParam)
		}> */
		nil,
		/* 98 Action31 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareLT(leftParam, rightParam)
		}> */
		nil,
		/* 99 Action32 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGE(leftParam, rightParam)
		}> */
		nil,
		/* 100 Action33 <- <{
		    rightParam := p.pop().(*syntaxBasicCompareParameter)
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareGT(leftParam, rightParam)
		}> */
		nil,
		/* 101 Action34 <- <{
		    leftParam := p.pop().(*syntaxBasicCompareParameter)
		    p.pushCompareRegex(leftParam, text)
		}> */
		nil,
		/* 102 Action35 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 103 Action36 <- <{
		    p.pushCompareParameterLiteral(p.pop())
		}> */
		nil,
		/* 104 Action37 <- <{
		    isLiteral := p.pop().(bool)
		    param := p.pop().(syntaxQueryJSONPathParameter)
		    if param.isValueGroupParameter() {
		        panic(p.syntaxErr(
		            begin, msgErrorInvalidSyntaxFilterValueGroup, buffer))
		    }
		    p.pushBasicCompareParameter(param.(syntaxQuery), isLiteral)
		}> */
		nil,
		/* 105 Action38 <- <{
		    p.saveParams()
		}> */
		nil,
		/* 106 Action39 <- <{
		    p.loadParams()

		    node := p.pop().(syntaxNode)
		    checkNode := node
		    if aggregateFunction, ok := node.(*syntaxAggregateFunction); ok {
		        checkNode = aggregateFunction.param
		    }

		    switch checkNode.(type) {
		    case *syntaxRootNodeIdentifier:
		        p.pushCompareParameterRoot(p.deleteRootNodeIdentifier(node))
		        p.push(true)
		    case *syntaxCurrentNodeIdentifier:
		        p.pushCompareParameterCurrentNode(p.deleteRootNodeIdentifier(node))
		        p.push(false)
		    }
		}> */
		nil,
		/* 107 Action40 <- <{
		    p.push(p.toFloat(text))
		}> */
		nil,
		/* 108 Action41 <- <{
		    p.push(true)
		}> */
		nil,
		/* 109 Action42 <- <{
		    p.push(false)
		}> */
		nil,
		/* 110 Action43 <- <{
		    p.push(p.unescapeSingleQuotedString(text))
		}> */
		nil,
		/* 111 Action44 <- <{
		    p.push(p.unescapeDoubleQuotedString(text))
		}> */
		nil,
		/* 112 Action45 <- <{
		    p.push(nil)
		}> */
		nil,
	}
	p.rules = _rules
	return nil
}
